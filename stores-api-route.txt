src/app/api/chat/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/chat?gameId=
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json({ error: "Missing gameId" }, { status: 400 });
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid gameId" }, { status: 400 });
  }
  const messages = await prisma.chat.findMany({
    where: { gameId },
    include: { user: true },
    orderBy: { createdAt: "asc" },
  });
  const result = messages.map((msg) => ({
    messageId: msg.id,
    userId: msg.userId,
    userName: msg.user.name,
    message: msg.message,
    createdAt: msg.createdAt,
  }));
  return NextResponse.json(result);
}

// POST /api/chat
export async function POST(request: Request) {
  const schema = z.object({
    gameId: z.number(),
    message: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { gameId, message } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId: farcasterId },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const game = await prisma.game.findUnique({ where: { id: gameId } });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const chat = await prisma.chat.create({
    data: {
      userId: user.id,
      gameId,
      message,
    },
  });
  return NextResponse.json(chat);
}


src/app/api/final/match/route.ts
import { prisma } from "@/server/db";
import { isMatch } from "@/lib/scoring";

export async function POST(req: Request) {
  try {
    const { userId, gameId, choiceId, targetId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const correct = isMatch(choiceId, targetId);
    const points = correct ? 100 : 0;

    await prisma.score.upsert({
      where: { userId_gameId: { userId, gameId } },
      update: { points: { increment: points } },
      create: { userId, gameId, points },
    });

    return Response.json({ correct, points });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/final/start/route.ts
import { prisma } from "@/server/db";

export async function GET() {
  try {
    const allQuestions = await prisma.question.findMany({
      take: 20,
      orderBy: { id: "asc" },
    });

    const pairs = allQuestions.map((q) => ({
      id: q.id,
      originalUrl: q.imageUrl,
      generatedUrl: q.imageUrl.replace("original", "ai"), // simple mock pattern
    }));

    return Response.json({ pairs });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/game/answer/route.ts
import { prisma } from "@/server/db";
import { calculateScore } from "@/lib/scoring";

export async function POST(req: Request) {
  try {
    const { userId, gameId, questionId, selected, timeTaken } =
      await req.json();

    if (!userId || !gameId || !questionId || !selected)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const question = await prisma.question.findUnique({
      where: { id: questionId },
    });
    if (!question)
      return Response.json({ error: "Question not found" }, { status: 404 });

    const correct = selected === question.correctAnswer;
    const points = correct ? calculateScore(timeTaken, 10) : 0;

    await prisma.score.upsert({
      where: { userId_gameId: { userId, gameId } },
      update: { points: { increment: points } },
      create: { userId, gameId, points },
    });

    return Response.json({ correct, points });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/game/start/route.ts
import { prisma } from "@/server/db";

export async function GET() {
  try {
    const questions = await prisma.question.findMany({
      take: 6,
      orderBy: { id: "asc" },
    });
    return Response.json({ questions });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/games/[id]/questions/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/games/[id]/questions
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const gameId = parseInt(params.id, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
  }
  const questions = await prisma.question.findMany({
    where: { gameId },
    select: {
      id: true,
      questionText: true,
      imageUrl: true,
      options: true,
    },
  });
  return NextResponse.json(questions);
}

// POST /api/games/[id]/questions
export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const gameId = parseInt(params.id, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
  }
  const schema = z.object({
    questionText: z.string().min(1),
    imageUrl: z.string().optional(),
    options: z.array(z.string().min(1)).min(2),
    correctIndex: z.number().min(0),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { questionText, imageUrl, options, correctIndex } = parseResult.data;
  if (correctIndex >= options.length) {
    return NextResponse.json(
      { error: "correctIndex out of range" },
      { status: 400 }
    );
  }
  // Check game exists
  const game = await prisma.game.findUnique({ where: { id: gameId } });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const question = await prisma.question.create({
    data: {
      gameId,
      questionText,
      imageUrl: imageUrl || null,
      options: options,
      correctIndex,
    },
  });
  return NextResponse.json(question);
}


src/app/api/games/[id]/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/games/[id]
export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const gameId = parseInt(params.id, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
  }
  const game = await prisma.game.findUnique({
    where: { id: gameId },
    include: { questions: true },
  });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  // Exclude correct answers in questions
  const questions = game.questions.map((q) => ({
    id: q.id,
    questionText: q.questionText,
    imageUrl: q.imageUrl,
    options: q.options,
  }));
  const { id, title, description, slug, startTime, endTime } = game;
  return NextResponse.json({
    id,
    title,
    description,
    slug,
    startTime,
    endTime,
    questions,
  });
}


src/app/api/games/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/games
export async function GET() {
  const games = await prisma.game.findMany({
    orderBy: { startTime: "asc" },
  });
  return NextResponse.json(games);
}

// POST /api/games
export async function POST(request: Request) {
  const schema = z.object({
    title: z.string().min(1),
    description: z.string().optional(),
    slug: z.string().min(1),
    startTime: z.string(),
    endTime: z.string(),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { title, description, slug, startTime, endTime } = parseResult.data;
  const start = new Date(startTime);
  const end = new Date(endTime);
  if (isNaN(start.getTime()) || isNaN(end.getTime())) {
    return NextResponse.json({ error: "Invalid date format" }, { status: 400 });
  }
  if (start >= end) {
    return NextResponse.json(
      { error: "startTime must be before endTime" },
      { status: 400 }
    );
  }
  const game = await prisma.game.create({
    data: {
      title,
      description,
      slug,
      startTime: start,
      endTime: end,
    },
  });
  return NextResponse.json(game);
}


src/app/api/leaderboard/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

export type LeaderboardUser = {
  id: string;
  rank: number;
  name: string;
  avatarUrl: string;
  score: number;
};

const PAGE_SIZE = 25;
const prisma = new PrismaClient();

// GET /api/leaderboard?tab=current|allTime&page=0
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const tabParam = (searchParams.get("tab") || "allTime") as
    | "current"
    | "allTime";
  const pageParam = searchParams.get("page") ?? "0";

  if (tabParam !== "current" && tabParam !== "allTime") {
    return NextResponse.json(
      { error: "Invalid `tab`. Use `current` or `allTime`." },
      { status: 400 }
    );
  }
  const page = Number(pageParam);
  if (!Number.isFinite(page) || page < 0) {
    return NextResponse.json(
      { error: "Invalid `page` (>= 0)." },
      { status: 400 }
    );
  }

  // Determine dataset
  let users: LeaderboardUser[] = [];
  if (tabParam === "current") {
    // Find current active game (ongoing or latest)
    const now = new Date();
    let game = await prisma.game.findFirst({
      where: { startTime: { lte: now }, endTime: { gte: now } },
      orderBy: { startTime: "desc" },
    });
    if (!game) {
      // fallback to latest finished game
      game = await prisma.game.findFirst({
        where: { endTime: { lte: now } },
        orderBy: { endTime: "desc" },
      });
    }
    if (game) {
      const scores = await prisma.score.findMany({
        where: { gameId: game.id },
        include: { user: true },
        orderBy: { score: "desc" },
      });
      users = scores.map((s, idx) => ({
        id: s.userId.toString(),
        rank: idx + 1,
        name: s.user.name || "",
        avatarUrl: s.user.avatarUrl || "",
        score: s.score,
      }));
    }
  } else {
    // All-time: sum scores for each user
    const groups = await prisma.score.groupBy({
      by: ["userId"],
      _sum: { score: true },
      orderBy: { _sum: { score: "desc" } },
    });
    const userIds = groups.map((g) => g.userId);
    const usersData = await prisma.user.findMany({
      where: { id: { in: userIds } },
    });
    users = groups.map((g, idx) => {
      const user = usersData.find((u) => u.id === g.userId);
      return {
        id: g.userId.toString(),
        rank: idx + 1,
        name: user?.name || "",
        avatarUrl: user?.avatarUrl || "",
        score: g._sum.score || 0,
      };
    });
  }

  // Paginate
  const start = page * PAGE_SIZE;
  const end = start + PAGE_SIZE;
  const pageUsers = users.slice(start, end);
  const hasMore = end < users.length;
  return NextResponse.json({ users: pageUsers, hasMore });
}

export const dynamic = "force-dynamic";


src/app/api/lobby/join/route.ts
import { prisma } from "@/server/db";

export async function POST(req: Request) {
  try {
    const { userId, gameId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    await prisma.chat.create({
      data: {
        userId,
        gameId,
        message: "joined the lobby.",
      },
    });

    return Response.json({ success: true });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/lobby/stats/route.ts
import { prisma } from "@/server/db";

export async function GET() {
  try {
    const tickets = await prisma.ticket.findMany({
      where: { status: "confirmed" },
      include: { user: true },
    });

    const totalTickets = tickets.length;
    const totalPrize = totalTickets * 50; // each ticket costs 50 USDC

    // Return top 10 players by activity
    const players = tickets.map((t) => ({
      username: t.user.username,
      wallet: t.user.wallet,
      pfpUrl: t.user.pfpUrl,
    }));

    return Response.json({
      totalTickets,
      totalPrize,
      players,
    });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/profile/history/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/profile/history
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
    orderBy: { game: { endTime: "asc" } },
  });
  const history = scores.map((s, index) => ({
    round: `Round ${index + 1}`,
    winnings: s.score,
  }));
  return NextResponse.json(history);
}


src/app/api/profile/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/profile
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const { id, name, wallet, avatarUrl, referralCode } = user;
  return NextResponse.json({ id, name, wallet, avatarUrl, referralCode });
}

// PUT /api/profile
export async function PUT(request: Request) {
  const schema = z.object({
    name: z.string().optional(),
    wallet: z.string().optional(),
    avatarUrl: z.string().url().optional(),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { name, wallet, avatarUrl } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const updated = await prisma.user.update({
    where: { id: user.id },
    data: {
      name: name !== undefined ? name : user.name,
      wallet: wallet !== undefined ? wallet : user.wallet,
      avatarUrl: avatarUrl !== undefined ? avatarUrl : user.avatarUrl,
    },
  });
  const {
    id,
    name: newName,
    wallet: newWallet,
    avatarUrl: newAvatar,
    referralCode,
  } = updated;
  return NextResponse.json({
    id,
    name: newName,
    wallet: newWallet,
    avatarUrl: newAvatar,
    referralCode,
  });
}


src/app/api/profile/stats/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/profile/stats
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
  });
  const totalGames = scores.length;
  if (totalGames === 0) {
    return NextResponse.json({
      totalGames: 0,
      wins: 0,
      winRate: 0,
      totalWon: 0,
      highestScore: 0,
      avgScore: 0,
      currentStreak: 0,
      bestRank: 0,
    });
  }
  let wins = 0;
  let bestRank = totalGames > 0 ? totalGames : 0;
  let totalWon = 0;
  let highestScore = 0;
  // Sort scores by game endTime descending for streak
  scores.sort((a, b) => {
    const aTime = a.game.endTime?.getTime() || 0;
    const bTime = b.game.endTime?.getTime() || 0;
    return bTime - aTime;
  });
  let currentStreak = 0;
  let streakCounting = false;
  for (const s of scores) {
    totalWon += s.score;
    highestScore = Math.max(highestScore, s.score);
    // Calculate rank for this game
    const countBetter = await prisma.score.count({
      where: { gameId: s.gameId, score: { gt: s.score } },
    });
    const rank = countBetter + 1;
    bestRank = Math.min(bestRank, rank);
    if (!streakCounting) {
      if (rank === 1) {
        currentStreak = 1;
        streakCounting = true;
      }
    } else {
      if (rank === 1) {
        currentStreak++;
      } else {
        break;
      }
    }
    if (rank === 1) wins++;
  }
  const avgScore = totalWon / totalGames;
  const winRate = (wins / totalGames) * 100;
  return NextResponse.json({
    totalGames,
    wins,
    winRate: Math.round(winRate * 10) / 10,
    totalWon,
    highestScore,
    avgScore: Math.round(avgScore * 100) / 100,
    currentStreak,
    bestRank,
  });
}


src/app/api/referrals/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/referrals
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId },
    include: { referralsSent: { include: { invitee: true } } },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const referrals = user.referralsSent.map((ref) => ({
    inviteeId: ref.invitee.id,
    inviteeFarcasterId: ref.invitee.farcasterId,
  }));
  return NextResponse.json({ referralCode: user.referralCode, referrals });
}

// POST /api/referrals
export async function POST(request: Request) {
  const schema = z.object({
    code: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json(
      { valid: false, message: "Invalid JSON" },
      { status: 400 }
    );
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json(
      { valid: false, message: "Invalid input" },
      { status: 400 }
    );
  }
  const { code } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json(
      { valid: false, message: "Unauthorized" },
      { status: 401 }
    );
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json(
      { valid: false, message: "User not found" },
      { status: 404 }
    );
  }
  const inviter = await prisma.user.findUnique({
    where: { referralCode: code },
  });
  if (!inviter) {
    return NextResponse.json(
      { valid: false, message: "Invite code not found" },
      { status: 400 }
    );
  }
  if (inviter.id === user.id) {
    return NextResponse.json(
      { valid: false, message: "Cannot use your own invite code" },
      { status: 400 }
    );
  }
  const existing = await prisma.referral.findFirst({
    where: { inviterId: inviter.id, inviteeId: user.id },
  });
  if (existing) {
    return NextResponse.json(
      { valid: false, message: "Referral already recorded" },
      { status: 400 }
    );
  }
  await prisma.referral.create({
    data: { inviterId: inviter.id, inviteeId: user.id },
  });
  return NextResponse.json({ valid: true });
}


src/app/api/tickets/buy/route.ts
import { prisma } from "@/server/db";
import { randomBytes } from "crypto";

export async function POST(req: Request) {
  try {
    const { userId, gameId, amount, txHash } = await req.json();
    if (!userId || !gameId || !amount)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const code = randomBytes(4).toString("hex").toUpperCase();

    const ticket = await prisma.ticket.create({
      data: {
        userId,
        gameId,
        amountUSDC: amount,
        code,
        txHash: txHash || null,
        status: txHash ? "confirmed" : "pending",
      },
    });

    return Response.json(ticket);
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


src/app/api/tickets/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/tickets
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const tickets = await prisma.ticket.findMany({
    where: { userId: user.id },
    include: { game: true },
  });
  const result = tickets.map((ticket) => ({
    ticketId: ticket.id,
    gameId: ticket.gameId,
    gameTitle: ticket.game.title,
    createdAt: ticket.createdAt,
  }));
  return NextResponse.json(result);
}

// POST /api/tickets
export async function POST(request: Request) {
  const schema = z.object({
    typeId: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { typeId } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  // Find game by slug or typeId
  const game = await prisma.game.findUnique({ where: { slug: typeId } });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const now = new Date();
  if (now >= game.startTime) {
    return NextResponse.json(
      { error: "Game has already started" },
      { status: 400 }
    );
  }
  const existing = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId: game.id },
  });
  if (existing) {
    return NextResponse.json(
      { error: "Ticket already purchased" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.create({
    data: { userId: user.id, gameId: game.id },
  });
  return NextResponse.json({
    ticketId: ticket.id,
    waffleType: game.title,
    message: "Purchase successful",
  });
}


src/app/api/tickets/verify/route.ts
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/tickets/verify
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json(
      { valid: false, message: "Unauthorized" },
      { status: 401 }
    );
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json(
      { valid: false, message: "User not found" },
      { status: 404 }
    );
  }
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json(
      { valid: false, message: "Missing gameId" },
      { status: 400 }
    );
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json(
      { valid: false, message: "Invalid gameId" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId },
  });
  if (!ticket) {
    return NextResponse.json({ valid: false, message: "Ticket not found" });
  }
  return NextResponse.json({ valid: true });
}


src/app/api/user/init/route.ts
import { prisma } from "@/server/db";

export async function POST(req: Request) {
  try {
    const { fid, username, pfpUrl, walletAddress } = await req.json();

    if (!fid) {
      return Response.json({ error: "Missing fid" }, { status: 400 });
    }

    const user = await prisma.user.upsert({
      where: { farcasterId: fid.toString() },
      update: {
        username,
        wallet: walletAddress || undefined,
        pfpUrl,
      },
      create: {
        farcasterId: fid.toString(),
        username,
        wallet: walletAddress,
        pfpUrl,
      },
    });

    return Response.json(user);
  } catch (error: any) {
    console.error("Error initializing user:", error);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}


