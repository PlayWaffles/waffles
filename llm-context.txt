--- File: ./.next/package.json ---
{"type": "commonjs"}
--- File: ./package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint",
    "postinstall": "prisma generate"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@coinbase/onchainkit": "^1.1.1",
    "@farcaster/miniapp-sdk": "^0.2.1",
    "@farcaster/quick-auth": "^0.0.8",
    "@neynar/nodejs-sdk": "^3.34.0",
    "@prisma/client": "6.18.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@supabase/supabase-js": "^2.76.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.24",
    "frontend": "link:",
    "lucide-react": "^0.546.0",
    "next": "15.5.6",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "sonner": "^2.0.7",
    "swr": "2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.4.0",
    "viem": "^2.38.3",
    "wagmi": "^2.18.2",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.6",
    "prisma": "6.18.0",
    "tailwindcss": "^4",
    "tsx": "^4.20.6",
    "typescript": "^5"
  },
  "packageManager": "pnpm@9.15.4+sha512.b2dc20e2fc72b3e18848459b37359a32064663e5627a51e4c74b2c29dd8e8e0491483c3abb40789cfd578bf362fb6ba8261b05f0387d76792ed6e23ea3b1b6a0"
}

--- File: ./.env ---
# Environment variables declared in this file are NOT automatically loaded by Prisma.
# Please add `import "dotenv/config";` to your `prisma.config.ts` file, or use the Prisma CLI with Bun
# to load environment variables from .env files: https://pris.ly/prisma-config-env-vars.
# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# === DATABASE (Prisma / Supabase) ===
# Local Prisma Postgres dev proxy (active by default for local dev)
# DATABASE_URL="prisma+postgres://localhost:51213/?api_key=eyJkYXRhYmFzZVVybCI6InBvc3RncmVzOi8vcG9zdGdyZXM6cG9zdGdyZXNAbG9jYWxob3N0OjUxMjE0L3RlbXBsYXRlMT9zc2xtb2RlPWRpc2FibGUmY29ubmVjdGlvbl9saW1pdD0xJmNvbm5lY3RfdGltZW91dD0wJm1heF9pZGxlX2Nvbm5lY3Rpb25fbGlmZXRpbWU9MCZwb29sX3RpbWVvdXQ9MCZzaW5nbGVfdXNlX2Nvbm5lY3Rpb25zPXRydWUmc29ja2V0X3RpbWVvdXQ9MCIsIm5hbWUiOiJkZWZhdWx0Iiwic2hhZG93RGF0YWJhc2VVcmwiOiJwb3N0Z3JlczovL3Bvc3RncmVzOnBvc3RncmVzQGxvY2FsaG9zdDo1MTIxNS90ZW1wbGF0ZTE_c3NsbW9kZT1kaXNhYmxlJmNvbm5lY3Rpb25fbGltaXQ9MSZjb25uZWN0X3RpbWVvdXQ9MCZtYXhfaWRsZV9jb25uZWN0aW9uX2xpZmV0aW1lPTAmcG9vbF90aW1lb3V0PTAmc2luZ2xlX3VzZV9jb25uZWN0aW9ucz10cnVlJnNvY2tldF90aW1lb3V0PTAifQ"

# Supabase via connection pooling (for production/deployment)
DATABASE_URL="postgres://postgres:WafflesSupremacy@1.0@db.hizkyaqomaburfcsdymo.supabase.co:5432/postgres?pgbouncer=true"

# Supabase direct connection (Used for migrations)
# DIRECT_URL="postgresql://postgres.fuoqnzdloxjgbmqcvuqs:vjvKrnek7Kip6qhO@aws-1-eu-west-1.pooler.supabase.com:5432/postgres"

# === SUPABASE (Client) ===
NEXT_PUBLIC_SUPABASE_URL=https://hizkyaqomaburfcsdymo.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhpemt5YXFvbWFidXJmY3NkeW1vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyNzgzMDYsImV4cCI6MjA3Njg1NDMwNn0.382bnE4iv_L2Cc4lTOMoVb0B5Y1jcFYVdMIP36V-jSY

# === FARCASTER / NEYNAR ===
NEYNAR_API_KEY=BDC7F176-D550-4D9E-BBF6-0B5DC52E5785 # Server-side only

# === ONCHAINKIT ===
NEXT_PUBLIC_ONCHAINKIT_API_KEY=jrY4mos7-wh-8MFia-Am2Bii7mGStOxx # Client-side OK

# === APP / DEPLOYMENT ===
NEXT_PUBLIC_URL=http://localhost:3000

# === CONTRACTS / WALLETS ===
NEXT_PUBLIC_WAFFLE_MAIN_ADDRESS=0x0b3d62DF33521cdcE79E87586d7C1534b00EcAd7
NEXT_PUBLIC_USDC_ADDRESS=0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913
--- File: ./next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "**",
        port: "",
        pathname: "**",
      },
      {
        protocol: "https",
        hostname: "res.cloudinary.com",
      },
      {
        protocol: "https",
        hostname: "**.supabase.co", // For Supabase storage
      },
    ],
  },
};

export default nextConfig;

--- File: ./src/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/waitlist/opengraph-image.png ---
[Content not included: Binary file]

--- File: ./src/app/waitlist/_components/ShareButton.tsx ---
"use client";
import { useCallback } from "react";
import { useComposeCast } from "@coinbase/onchainkit/minikit";
import { notify } from "@/components/ui/Toaster";
import { env } from "@/lib/env";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

export function ShareButton({
  userFid,
  className,
}: {
  userFid: number;
  className?: string;
}) {
  const { composeCastAsync } = useComposeCast();
  const share = useCallback(async () => {
    const message = `I'm on the Waffles waitlist! Join me at ${window.location.origin}/waitlist?ref=${userFid}`;
    notify.info("Opening Farcaster composer...");
    try {
      const result = await composeCastAsync({
        text: message,
        embeds: [env.rootUrl ? { url: env.rootUrl } : undefined].filter(
          Boolean
        ) as unknown as [string],
      });
      if (result?.cast) {
        notify.success("Shared successfully!");
      } else {
        notify.info("Share cancelled.");
      }
    } catch {
      notify.error("Failed to share waitlist.");
    }
  }, [userFid, composeCastAsync]);
  return (
    <FancyBorderButton onClick={share} className={className}>
      SHARE
    </FancyBorderButton>
  );
}

--- File: ./src/app/waitlist/_components/waitlistClient.tsx ---
"use client";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { CardStack } from "@/components/CardStack";
import { motion } from "framer-motion";
import Image from "next/image";
import { Suspense } from "react";
import { ShareButton } from "./ShareButton";
import { joinWaitlistAction } from "@/actions/waitlist";
import { useRouter } from "next/navigation";

export function WaitlistClient({
  waitlist,
  fid,
  referrerFid,
}: {
  waitlist: {
    onList: boolean;
    rank: number | null;
    invites: number;
  };
  fid: number;
  referrerFid: number | null;
}) {
  const router = useRouter();
  async function join() {
    if (!fid) return;
    try {
      const formData = new FormData();
      formData.set("fid", String(fid));
      formData.set("referrerFid", referrerFid ? String(referrerFid) : "");
      await joinWaitlistAction(formData);
      router.push("/waitlist");
    } catch (error) {
      console.error("Error joining waitlist:", error);
    }
  }

  // Define the array of splash images based on the design
  const splashImages = [
    "/images/splash/crew-1.png",
    "/images/splash/crew-2.png",
    "/images/splash/crew-3.png",
    "/images/splash/crew-4.png",
    "/images/splash/crew-5.png",
    "/images/splash/crew-6.png",
  ];

  return (
    <div className="relative min-h-screen w-full  overflow-hidden">
      <main className="relative w-full max-w-[420px] mx-auto text-white pt-[env(safe-area-inset-top)] px-4">
        <motion.div
          initial={{ opacity: 0, y: -12 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6 }}
          className="mt-6 flex justify-center"
        >
          <div className="flex flex-row items-center justify-center mt-10">
            <Image
              src="/logo-onboarding.png"
              alt="WAFFLES logo"
              width={200}
              height={150}
              priority
              className="object-contain"
            />
          </div>
        </motion.div>
        <motion.div
          initial={{ opacity: 0, y: 16 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.7, delay: 0.1 }}
          className="flex justify-center mt-[7vh]"
        >
          <motion.div
            animate={{ y: [0, -8, 0] }}
            transition={{ duration: 3.2, repeat: Infinity, ease: "easeInOut" }}
          >
            <Image
              src="/images/illustrations/waitlist-scroll.svg"
              width={170}
              height={189}
              alt="scroll"
              className="w-[38vw] max-w-[170px]"
            />
          </motion.div>
        </motion.div>
        <motion.div
          initial={{ opacity: 0, y: 12 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.55, delay: 0.2 }}
          className="mt-[2vh] flex flex-col items-center text-center"
        >
          {waitlist.onList ? (
            <>
              <h1 className="font-body text-white text-[clamp(32px,8vw,44px)] leading-[92%]">
                YOU&apos;RE ON <br /> THE LIST
              </h1>
              <p className="text-[#99A0AE] font-display text-[clamp(14px,3.4vw,18px)] leading-[130%] mt-3">
                {waitlist.rank
                  ? `You're #${waitlist.rank} on the waitlist.`
                  : "You're on the waitlist!"}
                <br />
                You&apos;ve invited {waitlist.invites} friend
                {waitlist.invites === 1 ? "" : "s"}. Share to move up faster.
              </p>
              <Suspense fallback={null}>
                {/* Client component for sharing */}
                <ShareButton userFid={fid} className="mt-6" />
              </Suspense>
            </>
          ) : (
            <>
              <h1 className="font-body text-white text-[clamp(32px,8vw,44px)] leading-[92%]">
                JOIN THE WAITLIST
              </h1>
              <p className="text-[#99A0AE] font-display text-[clamp(14px,3.4vw,18px)] leading-[130%] mt-3">
                Join now to be first to play when Waffles launches
              </p>
              <form action={join} className="mt-6">
                <FancyBorderButton type="submit">
                  GET ME ON THE LIST
                </FancyBorderButton>
              </form>
            </>
          )}
        </motion.div>
        <motion.div
          className="mt-8 mb-[env(safe-area-inset-bottom)] pb-6 flex items-center justify-center gap-2"
          animate={{ y: [0, -4, 0] }}
          transition={{ duration: 4, repeat: Infinity, ease: "easeInOut" }}
        >
          <CardStack
            images={[
              { src: "/images/avatars/a.png" },
              { src: "/images/avatars/b.png" },
              { src: "/images/avatars/c.png" },
              { src: "/images/avatars/d.png" },
            ]}
            size="clamp(30px, 9vw, 42px)"
            borderColor="#FFFFFF"
            rotations={[-8, 5, -5, 7]}
          />
          <p className="text-[#99A0AE] font-display text-[clamp(14px,3.4vw,18px)] leading-[130%] mt-3">
            You and {waitlist.invites} friends are on the list
          </p>
        </motion.div>
      </main>

      {/* --- ADDED THIS SECTION --- */}
      {/* This div positions the splash characters at the bottom of the screen */}
      <div className="absolute bottom-0 w-full flex justify-center items-end pointer-events-none">
        <div className="flex flex-row items-end -space-x-4">
          {splashImages.map((src, index) => (
            <Image
              key={src}
              src={src}
              alt={`Splash character ${index + 1}`}
              width={68}
              height={88}
              className="h-20 w-auto object-contain"
            />
          ))}
        </div>
      </div>
      {/* --- END OF ADDED SECTION --- */}
    </div>
  );
}

--- File: ./src/app/waitlist/page.tsx ---
"use server";

import { redirect } from "next/navigation";

import { prisma } from "@/lib/db";

import { WaitlistClient } from "./_components/waitlistClient";
import { getCurrentUserFid } from "@/lib/auth";

import { minikitConfig } from "../../../minikit.config";
import { Metadata } from "next";

export async function generateMetadata(): Promise<Metadata> {
  return {
    title: minikitConfig.miniapp.name,
    description: minikitConfig.miniapp.description,
    other: {
      "fc:frame": JSON.stringify({
        version: minikitConfig.miniapp.version,
        imageUrl: minikitConfig.miniapp.heroImageUrl,
        button: {
          title: `Launch ${minikitConfig.miniapp.name}`,
          action: {
            name: `Launch ${minikitConfig.miniapp.name}`,
            type: "launch_frame",
            url: minikitConfig.miniapp.homeUrl,
            splashImageUrl: minikitConfig.miniapp.splashImageUrl,
            splashBackgroundColor: minikitConfig.miniapp.splashBackgroundColor,
          },
        },
      }),
    },
  };
}
// Get the current user's model by fid
async function getCurrentUserByFid(fid: number) {
  return prisma.user.findUnique({ where: { fid } });
}

async function getWaitlistStatus(userId: number) {
  const waitlistEntry = await prisma.waitlist.findUnique({
    where: { userId },
  });

  if (!waitlistEntry) return { onList: false, rank: null, invites: 0 };

  // Determine rank by ordering by createdAt
  const earlierCount = await prisma.waitlist.count({
    where: { createdAt: { lt: waitlistEntry.createdAt } },
  });

  return {
    onList: true,
    rank: earlierCount + 1,
    invites: waitlistEntry.invites ?? 0,
  };
}

export default async function WaitlistPage({
  searchParams,
}: {
  searchParams: Promise<{ ref?: string }>;
}) {
  const referrerFid = (await searchParams).ref;
  const fid = await getCurrentUserFid();
  if (!fid) return redirect("/profile");

  const user = await getCurrentUserByFid(fid);
  if (!user) return redirect("/profile");

  const waitlist = await getWaitlistStatus(user.id);

  console.log("waitlist", waitlist);

  return (
    <WaitlistClient
      waitlist={waitlist}
      fid={fid}
      referrerFid={referrerFid ? parseInt(referrerFid) : null}
    />
  );
}

--- File: ./src/app/favicon.ico ---
[Content not included: Binary file]

--- File: ./src/app/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/opengraph-image.tsx ---
import { ImageResponse } from "next/og";
import { env } from "@/lib/env";

// Image metadata
export const size = {
  width: 1200,
  height: 630,
};

export const contentType = "image/png";

// Image generation
export default async function Image() {
  return new ImageResponse(
    (
      <div
        style={{
          width: "100%",
          height: "100%",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          background: "white",
        }}
        tw="relative"
      >
        <img
          src={`${env.rootUrl || ""}/logo.png`}
          alt="Waffles Logo"
          width={120}
          height={94}
          style={{
            marginRight: "44px",
            objectFit: "contain",
            display: "block",
          }}
        />
        <span
          style={{
            fontSize: 96,
            fontWeight: 900,
            color: "#1e1e1e",
            letterSpacing: "0.08em",
            fontFamily:
              "ui-sans-serif, system-ui, Helvetica, Arial, sans-serif",
            textTransform: "uppercase",
            lineHeight: 1,
            display: "block",
          }}
        >
          Waffles
        </span>
      </div>
    ),
    {
      ...size,
    }
  );
}

--- File: ./src/app/.well-known/farcaster.json/route.ts ---
import { withValidManifest } from "@coinbase/onchainkit/minikit";
import { minikitConfig } from "../../../../minikit.config";

import { type NextRequest } from "next/server";

export async function GET(req: NextRequest) {
  try {
    const validatedManifest = withValidManifest(minikitConfig);
    return Response.json(validatedManifest);
  } catch (error) {
    console.error("Error validating Farcaster manifest:", error);
    return Response.json(
      { error: "Failed to load Farcaster manifest" },
      { status: 500 }
    );
  }
}

export const dynamic = "force-dynamic";

--- File: ./src/app/(authenticated)/lobby/_components/GameSummary.tsx ---
"use client";

import Image from "next/image";

export function GameSummaryCard({
  avatarUrl,
  username,
  theme,
  prizePool,
}: {
  avatarUrl: string;
  username: string;
  theme: string;
  prizePool: number;
}) {
  const formattedPrize = prizePool.toLocaleString("en-US", {
    style: "currency",
    currency: "USD",
  });

  return (
    <div
      className="
        relative flex flex-col box-border
        w-[361px] h-[151px]
        border border-[#FFC931] rounded-[16px]
        mx-auto
        mt-8
      "
    >
      {/* ─────────── Top Row: User joined ─────────── */}
      <div className="absolute top-[16px] left-[14px] flex flex-row items-center gap-[10px] w-[295px] h-[54px]">
        <div className="w-[54px] h-[54px] rounded-full overflow-hidden bg-[#D9D9D9]">
          <Image
            src={avatarUrl}
            alt="User avatar"
            width={54}
            height={54}
            className="object-cover"
          />
        </div>

        <div className="flex flex-col justify-center items-start w-[159px] h-[48px]">
          <span className="font-body text-white text-[23px] leading-[130%]">
            {username}
          </span>
          <span className="font-display text-[#99A0AE] text-[14px] leading-[130%] tracking-[-0.03em]">
            has joined the next game
          </span>
        </div>
      </div>

      {/* ─────────── Bottom Row: Prize Pool + Theme ─────────── */}
      <div className="absolute bottom-[15px] left-[15px] flex flex-row items-center gap-[12px]">
        {/* Prize Pool */}
        <div className="flex flex-row items-center justify-center gap-[8.5px] w-[87.79px] h-[32px]">
          <Image
            src="/images/illustrations/money-stack.svg"
            alt="Prize icon"
            width={27.25}
            height={28.44}
            className="object-contain"
          />
          <div className="flex flex-col justify-center items-start w-[52px] h-[32px]">
            <span className="font-display text-[#99A0AE] text-[11.38px] leading-[130%] tracking-[-0.03em]">
              Prize pool
            </span>
            <span className="font-body text-white text-[17.07px] leading-[100%]">
              {formattedPrize}
            </span>
          </div>
        </div>

        {/* Theme */}
        <div className="flex flex-row items-center justify-center gap-[8.5px] w-[106.65px] h-[32px]">
          <Image
            src={`/images/themes/${theme}.svg`}
            alt="Football icon"
            width={29.11}
            height={28.43}
            className="object-contain"
          />
          <div className="flex flex-col justify-center items-start w-[69px] h-[32px]">
            <span className="font-display text-[#99A0AE] text-[11.38px] leading-[130%] tracking-[-0.03em]">
              Theme
            </span>
            <span className="font-body text-white text-[17.07px] leading-[100%]">
              {theme.toUpperCase()}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/_components/Share.tsx ---
"use client";

import Image from "next/image";
import { cn, getWeekdayString } from "@/lib/utils";
import { GameSummaryCard } from "./GameSummary";
import Link from "next/link";

// Props for the main Share component
type ShareViewProps = {
  gameTitle: string;
  theme: string;
  username: string;
  avatarUrl: string;
  startTime: Date;
  prizePool: number | null;
  onShare: () => void;
  gameId: number;
};

/**
 * Share component displayed after successfully purchasing a ticket.
 * It's purely presentational, receiving all data and actions via props.
 */
export function Share({
  gameTitle,
  theme,
  username,
  avatarUrl,
  prizePool,
  startTime,
  gameId,
  onShare,
}: ShareViewProps) {
  console.log("avatarUrl", startTime);
  console.log("theme", theme);
  console.log("username", username);
  console.log("avatarUrl", avatarUrl);
  console.log("prizePool", prizePool);
  console.log("onShare", onShare);
  return (
    // Outer container ensures full viewport height and applies noise background
    <div className="min-h-[100dvh] w-full z-50">
      {" "}
      {/* Centered content area with padding */}
      <div className="mx-auto flex min-h-[100dvh] w-full max-w-[420px] flex-col items-center px-5 pb-[calc(env(safe-area-inset-bottom)+48px)] pt-14">
        {" "}
        {/* Waffle ticket illustration */}
        <Image
          src="/images/illustrations/waffles.svg"
          alt="Pixel waffle"
          width={228}
          height={132}
          priority
          className="mb-8 h-auto w-[228px]"
        />
        {/* Main heading */}
        <h1
          className="text-foreground text-center font-edit-undo"
          style={{
            fontSize: "42px",
            lineHeight: "0.92",
            letterSpacing: "-0.03em",
          }}
        >
          WAFFLE SECURED!
        </h1>
        {/* Sub-heading */}
        <p className="mt-3 text-center text-base font-display text-[#99A0AE]">
          {" "}
          You&apos;re in. See you Friday.
          {/* {getWeekdayString(new Date(startTime).getDay())} */}
        </p>
        <GameSummaryCard
          avatarUrl={avatarUrl}
          username={username}
          theme={theme}
          prizePool={prizePool ?? 0}
        />
        {/* Share Button */}
        <button
          onClick={onShare}
          className={cn(
            "mt-8 w-full rounded-[14px] bg-white px-6 py-4 text-center font-edit-undo text-2xl text-[#FB72FF]",
            "border-r-[5px] border-b-[5px] border-[#FB72FF] transition active:translate-x-[2px] active:translate-y-[2px]"
          )}
        >
          SHARE TICKET
        </button>{" "}
        {/* Back to Home Button */}
        <button className="mt-6 text-sm font-edit-undo uppercase text-[#00CFF2] transition hover:text-[#33defa]">
          <Link href={`/game/${gameId}`}>BACK TO HOME</Link>
        </button>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/page.tsx ---
import {
  fetchUpcomingGames,
  fetchUserWithGameDetailsAndReferral,
} from "@/lib/data";
import LobbyPageClientImpl from "./lobbyClient";

import { redirect } from "next/navigation";
import { getCurrentUserFid } from "@/lib/auth";

export default async function LobbyPage() {
  const games = await fetchUpcomingGames();

  const userFid = await getCurrentUserFid();
  if (!userFid) {
    return null;
  }

  // if there is no active game, redirect to waitlist
  if (games.length === 0) {
    console.info("No active game found, redirecting to waitlist");
    return redirect("/waitlist");
  }

  const userInfo = await fetchUserWithGameDetailsAndReferral(
    userFid,
    games[0].id
  );

  // if (!userInfo) {
  //   return (
  //     <div className="flex flex-col items-center justify-center min-h-[80dvh] text-center px-4">
  //       User not found. likely not onboarded yet
  //     </div>
  //   );
  // }

  return <LobbyPageClientImpl games={games} userInfo={userInfo} />;
}

export const dynamic = "force-dynamic";

--- File: ./src/app/(authenticated)/lobby/lobbyClient.tsx ---
"use client";

import React, { useCallback, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { useComposeCast } from "@coinbase/onchainkit/minikit";
import LogoIcon from "@/components/logo/LogoIcon";
import { cn } from "@/lib/utils";
import { WalletIcon } from "@/components/icons";
import { BottomNav } from "@/components/BottomNav";
import Image from "next/image";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { Share } from "./_components/Share";
import { base } from "wagmi/chains";

import { purchaseTicketAction } from "@/actions/ticket";

import { notify } from "@/components/ui/Toaster";

import { HydratedGame, HydratedUser } from "@/state/types";
import { CardStack } from "@/components/CardStack";
import { motion } from "framer-motion";

import { useAccount } from "wagmi";

type LobbyPageClientImplProps = {
  games: HydratedGame[];
  userInfo: HydratedUser | null;
};

export default function LobbyPageClientImpl({
  games,
  userInfo,
}: LobbyPageClientImplProps) {
  const router = useRouter();
  const account = useAccount();
  const [activeGame] = useState(games[0]);
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [showShare, setShowShare] = useState(false);
  const [purchaseError, setPurchaseError] = useState<string | null>(null);

  // OnchainKit Hooks
  // const { sendTokenAsync } = useSendToken();
  const { composeCastAsync } = useComposeCast();
  const { roundedBalance } = useGetTokenBalance(
    account.address as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      chainId: base.id,
      decimals: 6,
      image: "/images/tokens/usdc.png",
      name: "USDC",
      symbol: "USDC",
    }
  );

  // --- Handlers ---
  const handlePurchase = async () => {
    if (!userInfo || !activeGame.config) {
      setPurchaseError("User or game data is missing.");
      return;
    }

    setIsPurchasing(true);
    setPurchaseError(null);
    notify.info("Processing purchase (test mode, no transaction sent)...");

    let txHash: string | null = null;
    try {
      // SKIP sending token transaction for now, just call server action directly.
      // Simulate a txHash for test purposes.
      txHash =
        "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdfa";

      // 2. Call Server Action to record/confirm purchase
      const formData = new FormData();
      formData.append("fid", String(userInfo?.fid));
      formData.append("gameId", String(activeGame.id));
      if (txHash) {
        formData.append("txHash", txHash);
      }

      const result = await purchaseTicketAction(null, formData);
      console.log("resultttttttttttt: ", result);

      if (result.success) {
        notify.success(
          result.alreadyExists
            ? "Ticket purchase confirmed!"
            : "Ticket secured!"
        );

        router.refresh();
        setShowShare(true); // Show the share screen
      } else {
        throw new Error(result.error);
      }
    } catch (err) {
      console.error("Ticket purchase failed:", err);
      const message =
        err instanceof Error ? err.message : "An unknown error occurred.";

      // Refine error messages
      let displayError = "Ticket purchase failed. Please try again.";
      if (message.toLowerCase().includes("user rejected")) {
        displayError = "Transaction cancelled.";
      } else if (message.includes("Invite required")) {
        displayError = "Redeem an invite code before buying a ticket.";
      } else if (message.includes("insufficient funds")) {
        displayError = "Insufficient funds for transaction.";
      } else if (
        message.includes("already purchased") ||
        message.includes("already exists")
      ) {
        displayError = "You already have a ticket for this game.";
        router.refresh();
      } else if (message) {
        displayError = message;
      }

      setPurchaseError(displayError);
      notify.error(displayError);
    } finally {
      setIsPurchasing(false);
    }
  };

  const shareTicket = useCallback(async () => {
    //
    if (!userInfo?.tickets[0] || !activeGame) return; // Use combined ticket state

    try {
      const message = `Just secured my waffle ticket for ${activeGame.name}! 🧇`;
      const result = await composeCastAsync({
        text: message,
        embeds: [env.rootUrl ? { url: env.rootUrl } : undefined].filter(
          Boolean
        ) as [],
      });

      if (result?.cast) {
        notify.success("Shared successfully!");
        console.log("Cast created successfully:", result.cast.hash);
      } else {
        notify.info("Cast cancelled.");
        console.log("User cancelled the cast");
      }
    } catch (error) {
      console.error("Error sharing cast:", error);
      notify.error("Unable to share your ticket right now.");
    }
  }, [userInfo?.tickets, activeGame, composeCastAsync]);

  // --- Derived State ---
  const prizePool = useMemo(() => {
    const ticketPrice = activeGame?.config?.ticketPrice ?? 50;
    const additionPrizePool = activeGame?.config?.additionPrizePool ?? 0;

    const calculatedPool =
      activeGame._count.tickets * ticketPrice + additionPrizePool;
    return calculatedPool;
  }, [activeGame]);
  const theme = useMemo(() => {
    return activeGame?.config?.theme ? activeGame.config.theme : "FOOTBALL";
  }, [activeGame?.config?.theme]);

  const spotsAvatars = useMemo(() => {
    return [
      "/images/avatars/a.png",
      "/images/avatars/b.png",
      "/images/avatars/c.png",
      "/images/avatars/d.png",
    ];
  }, []);

  if (!userInfo) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[80dvh] text-center px-4">
        User not found
      </div>
    );
  }

  if (!activeGame) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[80dvh] text-center px-4">
        Game not found
      </div>
    );
  }

  return (
    <div className="min-h-screen flex flex-col text-white ">
      {/* ─────────────── Header ─────────────── */}
      <header
        className={cn(
          "p-2 flex items-center justify-between border-b border-border bg-[#191919]"
        )}
      >
        <LogoIcon />
        <div
          className="flex flex-row justify-center items-center px-3 py-1.5 gap-1 rounded-full"
          style={{
            width: 96,
            height: 28,
            background: "rgba(249,249,249,0.1)",
            borderRadius: 900,
          }}
        >
          <span
            className="flex items-center justify-center"
            style={{
              width: 16,
              height: 16,
              flex: "none",
              order: 0,
              flexGrow: 0,
              position: "relative",
            }}
          >
            <WalletIcon className="w-4 h-4 text-white" />
          </span>
          <span
            className="font-edit-undo text-white"
            style={{
              fontStyle: "normal",
              fontWeight: 400,
              fontSize: 16,
              lineHeight: "14px",
              width: 52,
              height: 14,
              textAlign: "center" as const,
              flex: "none",
              order: 1,
              flexGrow: 0,
              display: "inline-block",
            }}
          >{`$${roundedBalance}`}</span>
        </div>
      </header>
      {/* ─────────────── Main Content ─────────────── */}

      {/* MAIN CONTENT */}
      <div className="flex-1 flex flex-col items-center gap-3 justify-center overflow-y-auto pt-20">
        {showShare ? (
          <Share
            gameTitle={activeGame.name}
            theme={theme}
            username={userInfo?.name || "Player"}
            avatarUrl={userInfo?.imageUrl || "/images/avatars/a.png"}
            prizePool={prizePool}
            startTime={activeGame.startTime}
            onShare={shareTicket}
            gameId={activeGame.id}
          />
        ) : (
          <>
            <main className="flex flex-col items-center justify-center flex-1 w-full px-4 pb-40 pt-14 text-center">
              <div className="flex flex-row items-center justify-between w-[350px] h-[50px] mx-auto">
                <div className="flex flex-col justify-center items-start h-full">
                  <p className="font-body text-[#99A0AE] text-sm leading-[130%] tracking-[-0.03em]">
                    Next game theme
                  </p>
                  <h1 className="font-edit-undo text-white text-[32px] leading-none">
                    {theme.toUpperCase()}
                  </h1>
                </div>
                <Image
                  src={`/images/themes/${theme}.svg`}
                  alt={theme.toUpperCase()}
                  width={40}
                  height={40}
                  className="object-contain"
                />
              </div>

              <motion.div
                initial={{ y: 15, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ duration: 0.7, ease: "easeOut" }}
              >
                <Image
                  src="/images/illustrations/waffles.svg"
                  alt="Waffle"
                  width={230}
                  height={130}
                  priority
                  className="mx-auto mb-8"
                />
              </motion.div>

              <h2 className="font-edit-undo text-3xl sm:text-[2.5rem] mb-4">
                GET YOUR WAFFLE
              </h2>

              <div className="w-full max-w-md border border-white/10 rounded-2xl flex flex-wrap justify-center gap-8 px-4 py-6 mb-8">
                <div className="flex flex-col items-center gap-2">
                  <Image
                    src="/images/illustrations/seats.svg"
                    alt="Spots"
                    width={48}
                    height={40}
                  />
                  <div className="text-[#99A0AE] font-display text-base">
                    Spots
                  </div>
                  <div className="font-edit-undo text-3xl">
                    {activeGame?._count?.tickets ?? 0}/
                    {activeGame?.config?.maxPlayers ?? 0}
                  </div>
                </div>
                <div className="flex flex-col items-center gap-2">
                  <Image
                    src="/images/illustrations/money-stack.svg"
                    alt="Prize"
                    width={48}
                    height={40}
                  />
                  <div className="text-[#99A0AE] font-display text-base">
                    Prize pool
                  </div>
                  <div className="font-edit-undo text-3xl">${prizePool}</div>
                </div>
                <div className="w-full max-w-[400px] px-4">
                  <FancyBorderButton
                    onClick={handlePurchase}
                    disabled={isPurchasing}
                  >
                    {isPurchasing
                      ? "PROCESSING..."
                      : userInfo?.tickets[0]?.status !== "confirmed"
                      ? `BUY WAFFLE ($${
                          activeGame?.config?.ticketPrice ?? "?"
                        })`
                      : `GAME LOBBY`}
                  </FancyBorderButton>
                  {purchaseError && (
                    <p className="mt-3 text-center text-sm text-red-400">
                      {purchaseError}
                    </p>
                  )}
                </div>
              </div>

              <div className="flex flex-col items-center mt-8">
                <CardStack
                  images={spotsAvatars.map((ava) => ({ src: ava }))}
                  size="clamp(32px,7vw,48px)"
                  borderColor="#fff"
                />
                <p className="font-display text-[#99A0AE] text-sm mt-2">
                  and 2 others have joined the game
                </p>
              </div>
            </main>
            <BottomNav />
          </>
        )}
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/useInfiniteLoader.ts ---
// src/app/(authenticated)/leaderboard/_components/useInfiniteLoader.ts
"use client"; // Explicitly mark as client-side hook

import { useEffect, useRef, type RefObject } from "react"; // Add type import

/**
 * Custom hook to detect when an element scrolls into view, triggering a callback.
 * Useful for implementing infinite scrolling/loading.
 *
 * @param onHit Callback function to execute when the target element becomes visible.
 * @param rootMargin Optional margin around the root viewport to adjust trigger point.
 * @param threshold The visibility threshold (0 to 1) required to trigger `onHit`.
 * @param deps Dependency array to re-initialize the observer if needed.
 * @returns A ref object to attach to the target DOM element.
 */
export function useInfiniteLoader(
  onHit: () => void, // Callback when element is visible
  rootMargin: string = "400px 0px 800px 0px", // Default trigger margin (preload early)
  threshold: number = 0, // Trigger as soon as any part is visible
  deps: unknown[] = [] // Dependencies for re-running useEffect
): [RefObject<HTMLDivElement>] {
  // Explicit return type
  const ref = useRef<HTMLDivElement>(null); // Ref for the target element

  useEffect(() => {
    const element = ref.current; // Get the current element from the ref
    if (!element) return; // Exit if element is not yet available

    // Create an Intersection Observer instance
    const observer = new IntersectionObserver(
      ([entry]) => {
        // Callback executed when intersection status changes
        if (entry.isIntersecting) {
          // If the element is intersecting the viewport (or rootMargin)
          onHit(); // Call the provided callback function
        }
      },
      {
        root: null, // Observe intersection relative to the browser viewport
        rootMargin: rootMargin, // Use the provided or default margin
        threshold: threshold, // Use the provided or default threshold
      }
    );

    // Start observing the target element
    observer.observe(element); //

    // Cleanup function: disconnect the observer when the component unmounts
    // or when dependencies change, preventing memory leaks.
    return () => observer.disconnect(); //

    // Re-run the effect if `onHit`, `rootMargin`, `threshold`, or any elements in `deps` change.
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [onHit, rootMargin, threshold, ...deps]); // Include all relevant dependencies

  // Return the ref to be attached to the target DOM element
  return [ref as RefObject<HTMLDivElement>]; //
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Tabs.tsx ---
"use client";

import { useCallback } from "react";
import { useSearchParams, useRouter, usePathname } from "next/navigation";
import { PixelButton } from "@/components/buttons/PixelButton";
import { cn } from "@/lib/utils";

export type LeaderboardTabKey = "current" | "allTime";
const TABS: { key: LeaderboardTabKey; label: string }[] = [
  { key: "current", label: "Current game" },
  { key: "allTime", label: "All time" },
];

export function Tabs() {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();

  const activeTab = (searchParams.get("tab") || "current") as LeaderboardTabKey;

  const handleTabChange = useCallback(
    (newTab: LeaderboardTabKey) => {
      const params = new URLSearchParams(searchParams);
      params.set("tab", newTab);
      router.push(`${pathname}?${params.toString()}`, { scroll: false });
    },
    [router, pathname, searchParams]
  );

  return (
    <div className="inline-flex items-center gap-2" role="tablist">
      {TABS.map(({ key, label }) => {
        const selected = activeTab === key;
        return (
          <PixelButton
            key={key}
            role="tab"
            aria-selected={selected}
            backgroundColor={selected ? "white" : ""}
            textColor={selected ? "black" : "var(--color-waffle-gold)"}
            borderColor={"var(--color-waffle-gold)"}
            onClick={() => handleTabChange(key)}
            borderWidth={4}
            className={cn(
              "px-4 py-2 text-xs sm:px-6 sm:py-2 sm:text-sm",
              selected ? "font-bold" : "opacity-80 hover:opacity-100",
              selected ? "" : "bg-[#191919] ",
              "transition"
            )}
            tabIndex={selected ? 0 : -1}
            disabled={selected}
          >
            {label}
          </PixelButton>
        );
      })}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Row.tsx ---
import { LeaderboardEntry } from "@/state/types";
import { UsdcIcon } from "@/components/icons";
import Image from "next/image";
import { cn } from "@/lib/utils";

interface RowProps {
  entry: LeaderboardEntry;
  isCurrentUser?: boolean;
}

export function Row({ entry, isCurrentUser = false }: RowProps) {
  const formattedPoints = entry.points.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });

  return (
    <div
      className={cn(
        "panel flex h-12 items-center justify-between rounded-xl px-4",
        isCurrentUser &&
          "bg-blue-900/30 border-blue-500/50 ring-1 ring-blue-500/60"
      )}
    >
      <div className="flex items-center gap-2">
        <div className="grid h-7 w-7 place-items-center rounded-full bg-white/10 shrink-0">
          <span className="text-xs leading-tight">{entry.rank}</span>
        </div>
        <div className="flex items-center gap-2 min-w-0">
          <div className="relative h-7 w-7 rounded-full bg-white/10 shrink-0">
            {entry.pfpUrl ? (
              <Image
                src={entry.pfpUrl}
                alt={entry.username || "Unknown User"}
                width={28}
                height={28}
                className="rounded-full bg-[#F0F3F4] object-cover"
                draggable={false}
              />
            ) : (
              <span className="absolute inset-0 flex items-center justify-center text-xs leading-tight">
                {entry.username?.charAt(0)?.toUpperCase() || "U"}
              </span>
            )}
          </div>
          <div className="text-sm leading-tight truncate">{entry.username}</div>
        </div>
      </div>
      <div className="flex items-center gap-2 shrink-0">
        <UsdcIcon className="h-4 w-4" />
        <div className="font-display font-medium text-base tracking-tight">
          {formattedPoints}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Top3.tsx ---
"use client";

import { TrophyIcon, UsdcIcon } from "@/components/icons";
import Image from "next/image";
import { cn } from "@/lib/utils";
import { LeaderboardEntry } from "@/state/types";

interface Top3Props {
  entries: LeaderboardEntry[];
  currentUserId?: number | null;
}

const cardStyles = [
  {
    bg: "bg-gradient-to-r from-transparent via-yellow-500/5 to-yellow-500/15",
    border: "border-yellow-400/30",
    trophy: "#FFC931",
  },
  {
    bg: "bg-gradient-to-r from-transparent via-cyan-500/5 to-cyan-500/15",
    border: "border-cyan-400/30",
    trophy: "#19ABD3",
  },
  {
    bg: "bg-gradient-to-r from-transparent via-orange-500/5 to-orange-500/15",
    border: "border-orange-400/30",
    trophy: "#D34D19",
  },
];

export function Top3({ entries, currentUserId }: Top3Props) {
  const topEntries = entries?.slice(0, 3) ?? [];

  if (topEntries.length === 0) return null;

  return (
    <div
      className="
        flex w-full flex-nowrap items-stretch
        gap-[var(--gap)]
      "
      style={
        {
          "--gap": "clamp(0.25rem, 2.2vw, 1rem)",
          "--pad": "clamp(0.5rem, 2.2vw, 1rem)",
          "--radius": "clamp(0.75rem, 2vw, 1rem)",
        } as React.CSSProperties
      }
    >
      {topEntries.map((entry, i) => {
        const isCurrentUser =
          currentUserId != null && String(entry.id) === String(currentUserId);
        const styles = cardStyles[i] ?? cardStyles[cardStyles.length - 1];

        const formattedPoints = entry.points.toLocaleString(undefined, {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        });

        return (
          <article
            key={entry.rank ?? i}
            className={cn(
              "basis-1/3 min-w-0 flex-1",
              "rounded-[var(--radius)] border",
              "p-[var(--pad)] bg-clip-padding",
              "flex flex-col gap-[calc(var(--pad)*0.8)]",
              "transition-shadow hover:shadow-lg",
              styles.bg,
              styles.border,
              isCurrentUser &&
                "ring-2 ring-offset-2 ring-offset-black ring-blue-400"
            )}
          >
            <TrophyIcon
              color={styles.trophy}
              className="flex-shrink-0"
              style={{
                width: "clamp(14px, 2.8vw, 20px)",
                height: "clamp(14px, 2.8vw, 20px)",
              }}
              aria-label={`Place ${i + 1}`}
            />

            <div className="flex min-w-0 items-center gap-[calc(var(--pad)*0.5)]">
              <div
                className="relative rounded-full bg-white/10 overflow-hidden shrink-0"
                style={{
                  width: "clamp(18px, 3vw, 24px)",
                  height: "clamp(18px, 3vw, 24px)",
                }}
              >
                {entry.pfpUrl ? (
                  <Image
                    src={entry.pfpUrl}
                    alt={entry.username || "Unknown User"}
                    fill
                    sizes="24px"
                    className="object-cover"
                    draggable={false}
                  />
                ) : (
                  <span className="absolute inset-0 flex items-center justify-center text-[calc(var(--pad)*0.6)] font-bold text-white/70">
                    {entry.username?.charAt(0)?.toUpperCase() || "U"}
                  </span>
                )}
              </div>
              <span
                title={entry.username || "Unknown User"}
                className="
                  min-w-0 truncate text-white font-body font-normal leading-tight
                "
                style={{ fontSize: "clamp(0.7rem, 2.3vw, 0.95rem)" }}
              >
                {entry.username}
              </span>
            </div>

            <div className="mt-auto flex items-center gap-[calc(var(--pad)*0.5)]">
              <UsdcIcon
                className="flex-shrink-0"
                style={{
                  width: "clamp(14px, 2.8vw, 20px)",
                  height: "clamp(14px, 2.8vw, 20px)",
                }}
              />
              <span
                className="font-display font-medium tracking-tight leading-[1.1]"
                style={{ fontSize: "clamp(0.85rem, 2.6vw, 1rem)" }}
              >
                {formattedPoints}
              </span>
            </div>
          </article>
        );
      })}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/page.tsx ---
"use client";

import Image from "next/image";
import { useEffect, useMemo, useRef, useCallback } from "react";
import { useSearchParams } from "next/navigation";
import useSWRInfinite from "swr/infinite";
import { Tabs, type LeaderboardTabKey } from "./_components/Tabs";
import { Top3 } from "./_components/Top3";
import { Row } from "./_components/Row";
import { WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { useInfiniteLoader } from "./_components/useInfiniteLoader";
import { useMiniUser } from "@/hooks/useMiniUser";
import { LeaderboardEntry } from "@/state/types";

export type TabKey = "current" | "allTime";

interface LeaderboardUser {
  id: number;
  rank: number;
  fid: number;
  name: string;
  points: number;
  imageUrl: string | null;
}

// Fetcher function for SWR
// Note: Adapts to useSWRInfinite key format
const fetcher = (url: string) =>
  fetch(url, { cache: "no-store" }).then((res) => {
    if (!res.ok) {
      throw new Error("Failed to fetch leaderboard data");
    }
    return res.json();
  });

// Define the expected API response structure
interface LeaderboardApiResponse {
  users: LeaderboardUser[];
  hasMore: boolean;
  me: LeaderboardUser | null;
  totalPlayers?: number;
  totalPoints?: number;
}

export default function LeaderboardPage() {
  const searchParams = useSearchParams();
  const user = useMiniUser();

  const activeTab = (searchParams.get("tab") || "current") as LeaderboardTabKey;

  const getKey = useCallback(
    (
      pageIndex: number,
      previousPageData: LeaderboardApiResponse | null
    ): string | null => {
      if (previousPageData && !previousPageData.hasMore) return null;

      if (pageIndex === 0)
        return `/api/leaderboard?tab=${activeTab}&page=0${
          user.fid ? `&userId=${user.fid}` : ""
        }`;

      return `/api/leaderboard?tab=${activeTab}&page=${pageIndex}${
        user.fid ? `&userId=${user.fid}` : ""
      }`;
    },
    [activeTab, user.fid]
  );

  const {
    data,
    error,
    isLoading: isLoadingInitial,
    isValidating,
    setSize,
    size,
  } = useSWRInfinite<LeaderboardApiResponse>(getKey, fetcher, {
    revalidateFirstPage: true,
    // Tweak revalidation options as needed
    // revalidateOnFocus: true,
    // refreshInterval: activeTab === 'current' ? 15000 : 0, // Auto-refresh current tab
  });

  // --- Data Processing ---
  const entries: LeaderboardEntry[] = useMemo(() => {
    if (!data) return [];
    return data.flatMap((page) =>
      page.users.map((u) => ({
        id: u.id,
        fid: u.fid,
        rank: u.rank,
        username: u.name,
        points: u.points,
        pfpUrl: u.imageUrl,
      }))
    );
  }, [data]);

  const hasMore = data ? data[data.length - 1]?.hasMore ?? false : true;
  const isLoadingMore =
    isLoadingInitial ||
    (size > 0 && data && typeof data[size - 1] === "undefined" && isValidating);
  const isEmpty = !isLoadingInitial && entries.length === 0;
  const currentError = error ? error.message || "Failed to load data" : null;

  // Extract 'me' data from the *first* page's response if available
  const me = useMemo(() => {
    const meData = data?.[0]?.me;
    return meData
      ? {
          id: meData.id,
          rank: meData.rank,
          username: meData.name,
          points: meData.points,
          pfpUrl: meData.imageUrl,
        }
      : null;
  }, [data]);
  const currentUserId = user.fid;

  // --- Infinite Loading Trigger ---
  const [loaderRef] = useInfiniteLoader(
    () => {
      if (!isLoadingMore && hasMore) {
        setSize(size + 1);
      }
    },
    "0px 0px 600px 0px",
    0,
    [isLoadingMore, hasMore]
  );

  // --- Hero Animation ---
  const crownRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const el = crownRef.current;
    if (!el) return;
    const observer = new IntersectionObserver(
      ([entry]) => {
        const ratio = 1 - entry.intersectionRatio;
        document.documentElement.style.setProperty(
          "--lb-progress",
          `${Math.min(Math.max(ratio, 0), 1)}`
        );
      },
      { threshold: Array.from({ length: 21 }, (_, i) => i / 20) }
    );
    observer.observe(el);
    return () => observer.disconnect();
  }, []);

  // --- Auto-refresh for 'current' tab --- (moved into useSWRInfinite options)
  // useEffect(() => {
  //   if (activeTab !== "current") return;
  //   const interval = setInterval(() => {
  //     mutate(getKey(0, null)); // Revalidate the first page
  //   }, 15000);
  //   return () => clearInterval(interval);
  // }, [activeTab, getKey, mutate]);

  // ───────────────────────── RENDER ─────────────────────────
  return (
    <main className="flex-1 overflow-y-auto ">
      <header className="sticky top-0 z-20 w-full border-b border-white/20 px-4 py-3 bg-[#191919]">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between ">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center"
                style={{ fontSize: "clamp(0.95rem, 1.9vw, 1rem)" }}
              >
                $...
              </span>
            </div>
          </div>
        </div>
      </header>
      {/* HERO + TABS */}
      <section className="mx-auto max-w-screen-sm px-4 pt-6 md:pt-10 relative">
        <div ref={crownRef} className="relative grid place-items-center">
          <Image
            src="/images/chest-crown.png"
            alt=""
            width={320}
            height={260}
            priority
            className="h-[180px] w-auto md:h-[220px] will-change-transform transition-[opacity,transform] duration-300"
            style={{
              opacity: `calc(1 - var(--lb-progress, 0))`,
              transform: `translateY(calc(-8px * var(--lb-progress, 0))) scale(calc(1 - 0.05 * var(--lb-progress, 0)))`,
            }}
          />
        </div>
        {/* Sticky Header with Title, Tabs, Description */}
        <div className="sticky top-[61px] z-10 -mx-4 px-4 pb-2 pt-1 backdrop-blur-sm">
          <h1 className="text-center font-body text-2xl md:text-3xl tracking-wide">
            LEADERBOARD
          </h1>
          <div className="mt-5 flex items-center justify-center gap-6">
            <Tabs />
          </div>
          <p className="mt-4 text-center text-muted font-display">
            {activeTab === "current"
              ? "Real-time standings from the current game"
              : "The greatest of all time"}
          </p>
        </div>
      </section>
      {/* LIST */}
      <section className="mx-auto max-w-screen-sm px-4 pb-24 pt-4 space-y-4">
        {!isLoadingInitial && entries.length > 0 && (
          <Top3 entries={entries.slice(0, 3)} currentUserId={currentUserId} />
        )}
        {/* Render rest of the list */}
        <div className="space-y-3">
          {entries.slice(3).map((e) => (
            <Row
              key={`${activeTab}-${e.rank}-${e.id}`}
              entry={e}
              isCurrentUser={
                currentUserId != null && String(e.id) === String(currentUserId)
              }
            />
          ))}
          {/* Loading Indicator */}
          {isLoadingMore && (
            <div className="h-12 rounded-xl panel animate-pulse" />
          )}
          {/* Error Message */}
          {currentError && !isValidating && (
            <div className="panel px-4 py-3 text-sm text-danger">
              {currentError}
            </div>
          )}
          {/* Empty State */}
          {isEmpty && !currentError && (
            <div className="panel px-4 py-6 text-center text-sm text-muted">
              Nothing here yet.
            </div>
          )}
          {/* Infinite Scroll Trigger Element */}
          {hasMore && !isLoadingMore && !currentError && (
            <div ref={loaderRef} className="h-10 w-full" />
          )}
          {/* End of List Indicator */}
          {!hasMore && !isLoadingInitial && !isEmpty && !currentError && (
            <div className="panel px-4 py-3 text-center text-sm text-muted">
              End of list.
            </div>
          )}
        </div>
      </section>
      <BottomNav />
    </main>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/score/_components/scoreClient.tsx ---
"use client";

import WinningsCard from "./WinningsCard";
import Leaderboard from "./Leaderboard";
import Image from "next/image";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { useAccount } from "wagmi";
import { env } from "@/lib/env";
import { base } from "viem/chains";
import { cn } from "@/lib/utils";
import LogoIcon from "@/components/logo/LogoIcon";
import { FlashIcon, WalletIcon } from "@/components/icons";
import { useRouter } from "next/navigation";

interface LeaderboardEntry {
  username: string;
  avatarUrl?: string | null;
  score: number;
}

interface Props {
  category: string;
  winnings: number;
  score: number;
  rank: number;
  percentile: number; // 0–100
  leaderboard: LeaderboardEntry[];
  userInfo: {
    username: string;
    avatarUrl: string;
  };
}

export default function ScorePageClient({
  category,
  winnings,
  score,
  rank,
  percentile,
  leaderboard,
  userInfo,
}: Props) {
  const account = useAccount();
  const router = useRouter();
  const { roundedBalance } = useGetTokenBalance(
    account.address as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      chainId: base.id,
      decimals: 6,
      image: "/images/tokens/usdc.png",
      name: "USDC",
      symbol: "USDC",
      // Removed unnecessary token details if configured globally or relying on defaults
    }
  );
  return (
    <div className="h-[100dvh] flex flex-col text-white overflow-hidden">
      {/* ─────────────── Header ─────────────── */}
      <header
        className={cn(
          "p-2 flex items-center justify-between border-b border-border bg-[#191919]"
        )}
      >
        <LogoIcon />
        <div
          className="flex flex-row justify-center items-center px-3 py-1.5 gap-1 rounded-full"
          style={{
            width: 96,
            height: 28,
            background: "rgba(249,249,249,0.1)",
            borderRadius: 900,
          }}
        >
          <span
            className="flex items-center justify-center"
            style={{
              width: 16,
              height: 16,
              flex: "none",
              order: 0,
              flexGrow: 0,
              position: "relative",
            }}
          >
            <WalletIcon className="w-4 h-4 text-white" />
          </span>
          <span
            className="font-edit-undo text-white"
            style={{
              fontStyle: "normal",
              fontWeight: 400,
              fontSize: 16,
              lineHeight: "14px",
              width: 52,
              height: 14,
              textAlign: "center" as const,
              flex: "none",
              order: 1,
              flexGrow: 0,
              display: "inline-block",
            }}
          >{`$${roundedBalance ? roundedBalance : "---"}`}</span>
        </div>
      </header>
      <div className="w-full mt-10  text-white flex flex-col items-center  flex-1 overflow-y-auto">
        <Image
          src="/images/illustrations/waffles.svg"
          alt="waffle"
          width={200}
          height={200}
          className="mb-4"
        />

        <h1 className="font-pixel text-[44px] leading-none">GAME OVER</h1>
        <p className="text-[#99A0AE] text-[16px] font-sans mt-1 uppercase">
          {category} & Anime
        </p>

        <WinningsCard
          winnings={winnings}
          score={score}
          rank={rank}
          avatarUrl={userInfo.avatarUrl}
          username={userInfo.username}
        />

        <p className="text-white/80 text-sm mt-3 flex items-center gap-2 font-display">
          <FlashIcon className="w-4 h-4 text-[#FFC931]" />
          You finished faster than {percentile}% of your friends
        </p>

        <div className="w-full max-w-[360px] mt-6 flex flex-col gap-3">
          <FancyBorderButton className="text-[#14B985] border-[#14B985]">
            SHARE SCORE
          </FancyBorderButton>
          <button
            className="
            flex flex-row justify-center items-center
            font-body
            text-[#00CFF2]
            bg-transparent
            border-none
            mt-1"
            onClick={() => router.push("/lobby")}
          >
            <span
              className="
              w-[107px] h-[21px] flex items-end justify-center text-center flex-none order-1"
            >
              BACK TO HOME
            </span>
          </button>
        </div>

        <Leaderboard entries={leaderboard} className="mt-10" />
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/score/_components/Leaderboard.tsx ---
import Image from "next/image";
import clsx from "clsx";
import Link from "next/link";
import { FlashIcon } from "@/components/icons";

// The medal SVGs (using public paths)
const TROPHY_PATHS = [
  "/images/trophies/gold.svg",
  "/images/trophies/silver.svg",
  "/images/trophies/bronze.svg",
];

// Background color themes for top 3 positions to match the design
const THEMES = [
  "bg-gradient-to-r from-[#211900] to-[#092009] border-[#F4C542]/30", // Gold/green for 1st
  "bg-gradient-to-r from-[#22252E] to-[#14273E] border-[#BCCBEF]/25", // Silver/blue for 2nd
  "bg-gradient-to-r from-[#3D2313] to-[#18100B] border-[#FFA95C]/30", // Bronze/orange for 3rd
];

interface Entry {
  username: string;
  avatarUrl?: string | null;
  score: number;
}

interface Props {
  entries: Entry[];
  className?: string;
}

export default function Leaderboard({ entries, className }: Props) {
  return (
    <div
      className={clsx("w-full max-w-[420px] flex flex-col gap-3", className)}
    >
      <div className="flex justify-between items-center mb-2">
        <h2 className="font-body text-[22px]">TOP 3 FINISHERS</h2>
        <Link
          href="/leaderboard"
          className="text-[#00CFF2] font-body text-[18px]"
        >
          VIEW LEADERBOARD
        </Link>
      </div>
      {entries.slice(0, 3).map((e, i) => (
        <div
          key={e.username}
          className={clsx(
            // Themed dark gradient backgrounds & border per position
            "flex items-center justify-between rounded-2xl p-3 min-h-[56px] border shadow-lg",
            THEMES[i] || THEMES[2]
          )}
        >
          {/* Trophy icon */}
          <span className="mr-4 flex-shrink-0 flex items-center w-[38px] h-[49px]">
            <Image
              src={TROPHY_PATHS[i] || TROPHY_PATHS[2]}
              width={38}
              height={49}
              alt=""
              priority
              unoptimized
            />
          </span>
          {/* User info (avatar and username) */}
          <span className="flex items-center gap-3 flex-1 min-w-0">
            <Image
              src={e.avatarUrl ?? "/images/avatar-default.png"}
              width={36}
              height={36}
              alt=""
              className="rounded-full border-2 border-white/20"
            />
            <span className="font-body text-[18px] text-white truncate">
              {e.username}
            </span>
          </span>
          {/* Score with lightning icon */}
          <span className="flex items-center gap-2 min-w-[90px] justify-end">
            <FlashIcon className="w-5 h-5 text-[#FFC931]" />
            <span className="font-body text-[22px] text-white drop-shadow-[0_1px_1px_rgba(0,0,0,0.24)]">
              {e.score.toLocaleString()}
            </span>
          </span>
        </div>
      ))}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/score/_components/WinningsCard.tsx ---
import Image from "next/image";
import { FlashIcon, TrendIcon } from "@/components/icons";

interface Props {
  winnings: number;
  score: number;
  rank: number;
  username: string;
  avatarUrl: string;
}

function getTrophy(rank: number) {
  if (rank === 1) return "/images/trophies/gold.svg";
  if (rank === 2) return "/images/trophies/silver.svg";
  if (rank === 3) return "/images/trophies/bronze.svg";
  return "/images/trophies/participant.svg";
}

export default function WinningsCard({
  winnings,
  score,
  rank,
  username,
  avatarUrl,
}: Props) {
  const trophy = getTrophy(rank);

  return (
    <div
      className="
        w-full max-w-sm
        rounded-3xl
        p-4 sm:p-5
        bg-gradient-to-b from-transparent to-[#1BF5B0]/12
        border border-white/5
        flex flex-col gap-4
        my-5
      "
    >
      {/* Top Row */}
      <div className="flex items-center justify-between w-full">
        <p className="text-[#99A0AE] font-display text-base sm:text-[15px]">
          Winnings
        </p>

        <div className="flex items-center gap-2">
          {avatarUrl && (
            <Image
              src={avatarUrl}
              alt={username}
              width={22}
              height={22}
              className="rounded-full w-5 h-5 sm:w-6 sm:h-6"
            />
          )}
          <span className="font-body text-base sm:text-lg text-white leading-none">
            {username}
          </span>
        </div>
      </div>

      {/* Winnings + Trophy */}
      <div className="flex items-center justify-between w-full">
        <p
          className="
            font-body
            text-[clamp(2.2rem,6vw,3rem)]
            leading-none
            text-[#14B985]
          "
        >
          ${winnings.toLocaleString()}
        </p>

        <Image
          src={trophy}
          alt="trophy"
          width={40}
          height={40}
          className="w-8 h-8 sm:w-10 sm:h-10"
        />
      </div>

      {/* Stats */}
      <div className="grid grid-cols-2 gap-3 w-full">
        {/* Score */}
        <div
          className="
            flex flex-col gap-1
            bg-white/5 border border-white/10
            rounded-2xl p-3 sm:p-4
          "
        >
          <span className="text-[#99A0AE] text-sm font-display">Score</span>

          <div className="flex items-center gap-2">
            <FlashIcon className="w-5 h-5 text-[#FFC931]" />
            <span className="font-body text-[clamp(1rem,2vw,1.25rem)] text-white leading-none">
              {score.toLocaleString()}
            </span>
          </div>
        </div>

        {/* Rank */}
        <div
          className="
            flex flex-col gap-1
            bg-white/5 border border-white/10
            rounded-2xl p-3 sm:p-4
          "
        >
          <span className="text-[#99A0AE] text-sm font-display">Rank</span>

          <div className="flex items-center gap-2">
            <TrendIcon className="w-5 h-5 text-[#14B985]" />
            <span className="font-body text-[clamp(1rem,2vw,1.25rem)] text-white leading-none">
              {rank}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/score/page.tsx ---
import { prisma } from "@/lib/db";
import { notFound } from "next/navigation";
import React from "react";
import ScorePageClient from "./_components/scoreClient";
import { getCurrentUserFid } from "@/lib/auth";

export default async function ScorePage({
  params,
}: {
  params: Promise<{ gameId: string }>;
}) {
  const { gameId } = await params;
  const fid = await getCurrentUserFid();

  if (!fid) {
    return <div>User not logged in</div>;
  }

  // Look up the user's score for the game by joining Score -> User (using fid)
  const userScore = await prisma.score.findFirst({
    where: {
      gameId: Number(gameId),
      user: { fid: fid },
    },
    include: {
      game: {
        select: {
          config: {
            select: { theme: true },
          },
        },
      },
      user: {
        select: { id: true, imageUrl: true, name: true },
      },
    },
  });

  if (!userScore || !userScore.user) return notFound();

  // Get leaderboard top 3 for this game
  const leaderboard = await prisma.score.findMany({
    where: { gameId: Number(gameId) },
    orderBy: { points: "desc" },
    take: 3,
    include: {
      user: {
        select: {
          name: true,
          imageUrl: true,
        },
      },
    },
  });

  // Get all scores for this game for percentile+rank
  const allScores = await prisma.score.findMany({
    where: { gameId: Number(gameId) },
    orderBy: { points: "desc" },
    select: { userId: true },
  });

  // Find user's rank using their internal userId
  const sortedUserIds = allScores.map((s) => s.userId);
  const userRank = sortedUserIds.indexOf(userScore.user.id) + 1;
  const percentile =
    allScores.length > 0
      ? Math.round(((allScores.length - userRank) / allScores.length) * 100)
      : 0;

  // If we had real winnings, we'd calculate by pool logic. Here, 0 for now.
  const winnings = 50;

  return (
    <ScorePageClient
      userInfo={{
        username: userScore.user.name ?? "",
        avatarUrl: userScore.user.imageUrl ?? "",
      }}
      category={userScore.game?.config?.theme ?? "UNKNOWN"}
      winnings={winnings}
      score={userScore.points}
      rank={userRank}
      percentile={percentile}
      leaderboard={leaderboard.map((r) => ({
        username: r.user?.name ?? "anon",
        avatarUrl: r.user?.imageUrl ?? "",
        score: r.points,
      }))}
    />
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/GradientMask.tsx ---
"use client";

import Image from "next/image";
import { cn } from "@/lib/utils";

interface GradientMaskProps {
  className?: string;
  height?: number;
  src?: string;
  alt?: string;
}

/**
 * Renders a bottom fade overlay using CSS masks.
 * Can mask either a provided image or create a fade-to-background effect.
 * Designed to sit visually on top of other content without blocking interactions.
 */
export default function GradientMask({
  className,
  height = 136,
  src,
  alt = "",
}: GradientMaskProps) {
  return (
    <div
      aria-hidden="true"
      className={cn(
        "pointer-events-none absolute left-1/2 -translate-x-1/2 w-[min(94vw,40rem)] z-10",
        className
      )}
      style={{ height: `${height}px` }}
    >
      {src ? (
        <div className="relative h-full w-full">
          <Image
            src={src}
            alt={alt}
            fill
            sizes="(max-width: 768px) 94vw, 40rem"
            className={cn(
              "object-cover",

              "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]", // Standard mask
              "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]" // Webkit prefix for compatibility
            )}
            priority
          />
        </div>
      ) : (
        <div
          className={cn(
            "h-full w-full",

            "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "bg-background"
          )}
        />
      )}
    </div>
  );
} //

--- File: ./src/app/(authenticated)/game/[gameId]/_components/QuestionCard.tsx ---
// ───────────────────────── QuestionCard.tsx ─────────────────────────
"use client";

import * as React from "react";
import { HydratedGame } from "@/state/types";

import { cn } from "@/lib/utils";
import Image from "next/image";
import { PixelButton } from "@/components/buttons/PixelButton";
import { PALETTES } from "@/lib/constants";

type QuestionCardProps = {
  question: HydratedGame["questions"][0];
  onSelectAnswer: (option: string) => void;
  selectedOption: string | null;
  isSubmitting: boolean; // <-- ADDED PROP
};

export default function QuestionCard({
  question,
  onSelectAnswer,
  selectedOption,
  isSubmitting, // <-- ADDED PROP
}: QuestionCardProps) {
  const chosenIdx = selectedOption
    ? question.options.indexOf(selectedOption)
    : null;
  return (
    <section
      className="mx-auto w-full max-w-screen-sm px-4 pb-8 pt-8 animate-up"
      aria-live="polite"
    >
      {/* Game Title */}
      <div
        className="
          mx-auto 
          mb-4
          flex 
          items-center 
          justify-center 
          select-none
          w-[206px] 
          font-normal 
          text-[36px] 
          leading-[0.92] 
          text-center 
          tracking-[-0.03em]
          text-white
          font-body
          flex-none
          order-0
          grow-0
        "
      >
        Guess the Movie
      </div>

      {/* Image Section */}
      <figure
        className="mx-auto mb-8 w-full flex justify-center"
        style={{ borderRadius: 10 }}
      >
        <div
          className="relative w-full overflow-hidden"
          style={{
            aspectRatio: "299/158",
            borderRadius: 10,
            maxWidth: 380,
            minWidth: 200,
            background: "#17171a",
            border: "1px solid #313136",
            boxShadow: "0 8px 0 #000",
          }}
        >
          {question.imageUrl ? (
            <Image
              src={question.imageUrl}
              alt={question.text}
              fill
              className="object-cover w-full h-full"
              style={{ borderRadius: 10 }}
              priority
              sizes="(max-width: 600px) 95vw, 380px"
            />
          ) : (
            <div className="absolute inset-0 flex items-center justify-center text-muted">
              No image available
            </div>
          )}
        </div>
      </figure>

      {/* Options */}
      <ul className={cn("mx-auto flex w-full flex-col gap-4")}>
        {question.options.map((opt, idx) => {
          const isChosen = idx === chosenIdx;
          const palette = PALETTES[idx % PALETTES.length];

          // UPDATED: Dim if an answer is selected and it's not this one,
          // OR if we are submitting and it's not the chosen one.
          const isDimmed =
            (selectedOption !== null && !isChosen) ||
            (isSubmitting && !isChosen);
          // UPDATED: Disable if submitting and it's not the chosen one.
          const isDisabled = isSubmitting && !isChosen;

          return (
            <li
              key={idx}
              className={cn(
                "min-w-0 flex justify-center transition-all", // Added transition
                // UPDATED: Apply dimmed styles
                isDimmed && "opacity-50 w-10/12 mx-auto"
              )}
            >
              <PixelButton
                aria-pressed={isChosen}
                tabIndex={-1}
                backgroundColor={palette.bg}
                textColor={palette.text}
                borderColor={palette.border}
                onClick={() => {
                  onSelectAnswer(opt);
                }}
                disabled={isDisabled} // <-- UPDATED: Apply disabled state
              >
                <span className="block w-full mx-auto truncate select-none">
                  {opt}
                </span>
              </PixelButton>
            </li>
          );
        })}
      </ul>

      {/* Submitted Footer */}
      {chosenIdx !== null && (
        <div
          className={cn(
            "mx-auto mt-10 text-center text-sm text-white/80 font-semibold transition-opacity md:text-base",
            "opacity-100"
          )}
          aria-live="polite"
        >
          {/* UPDATED: Show different text when submitting */}
          {isSubmitting
            ? "Submitting..."
            : "Answer submitted! Wait for the next question…"}
        </div>
      )}
    </section>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/ChatTickerOverlay.tsx ---
import Image from "next/image";
import { useEffect, useRef, useState } from "react";

const ALL_MESSAGES = [
  {
    name: "rugpull847",
    message: "game tuff man",
  },
  {
    name: "ianbowenthe",
    message: "LFGGGG",
  },
  {
    name: "funddswen",
    message: "Next round come onnnn",
  },
];

export default function ChatTickerOverlay({
  bottomOffset,
}: {
  bottomOffset: number;
}) {
  const messageIndex = useRef(0);
  const [chats, setChats] = useState<
    { id: number; name: string; message: string; avatarUrl: string }[]
  >([]);

  useEffect(() => {
    const interval = setInterval(() => {
      const idx = messageIndex.current % ALL_MESSAGES.length;
      const msg = ALL_MESSAGES[idx];
      // Manipulate the avatarUrl, e.g. "/images/lobby/1.jpg", "/images/lobby/2.jpg", ...
      const avatarNum = (idx % 6) + 1; // e.g. numbers 1-6 cycling
      const avatarUrl = `/images/lobby/${avatarNum}.jpg`;

      messageIndex.current++;
      setChats((prevChats) => {
        const newList = [...prevChats, { ...msg, avatarUrl, id: Date.now() }];
        return newList.slice(-5); // keep only the last 5
      });
    }, 3000);

    return () => clearInterval(interval);
  }, []);

  return (
    <div
      className="absolute left-0 right-0 h-[136px] overflow-hidden"
      style={{ bottom: `${bottomOffset}px` }}
    >
      {/* Gradient Overlay */}
      <div
        className="absolute inset-0 z-10"
        style={{
          background:
            "linear-gradient(to bottom, #0E0E0E 0%, #0E0E0E 6%, transparent 100%)",
        }}
      />

      {/* Chat Content */}
      <div className="flex flex-col justify-end h-full px-4 space-y-3">
        {chats.map((chat) => (
          <div
            key={chat.id}
            className="flex items-center gap-2 animate-fade-in"
          >
            <Image
              src={chat.avatarUrl}
              alt={`${chat.name} avatar`}
              width={20}
              height={20}
              className="rounded-full"
            />
            <span className="text-sm font-medium text-white">{chat.name}</span>
            <span className="text-sm font-medium text-white/70 font-display">
              {chat.message}
            </span>
          </div>
        ))}
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/RoundCountdownView.tsx ---
// ───────────────────────── RoundCountdownView.tsx ─────────────────────────
"use client";

// REMOVED: import { UseTimerResult } from "@/hooks/useTimer";

const BLUE = "#1E8BFF";

/**
 * New props interface for the component.
 * These values are now passed down from the parent (QuestionView).
 */
interface RoundCountdownViewProps {
  percent: number; // Percent remaining (1.0 -> 0.0)
  secondsLeft: number; // Seconds remaining (e.g., 15, 14, ...)
  totalSeconds: number; // Total duration in seconds (e.g., 15)
}

export default function RoundCountdownView({
  percent,
  secondsLeft,
  totalSeconds,
}: RoundCountdownViewProps) {
  // The 'percent' prop (1.0 -> 0.0) is the same as the old 'ratio'
  const ratio = percent;

  return (
    <div className="animate-up">
      <section className="mx-auto w-full max-w-screen-sm px-4 pt-10 pb-8">
        <p className="mb-6 text-center text-white/85">PLEASE WAIT</p>
        <h1
          className="mb-8 text-center font-bold leading-tight whitespace-nowrap overflow-hidden text-ellipsis"
          style={{
            fontSize: "clamp(1.15rem, 7vw, 2.5rem)",
            letterSpacing: "-0.03em",
          }}
        >
          NEXT&nbsp;ROUND&nbsp;IN
        </h1>

        <div className="grid place-items-center">
          <CountdownCircle
            ratio={ratio}
            total={totalSeconds}
            secondsLeft={secondsLeft}
          />
        </div>

        <p className="mt-10 text-center text-muted text-lg font-display">
          Get ready for the next round!
        </p>
      </section>

      {/* Overlays/extensions can live here; keep them inert wrt timers */}
      {/* <ChatDrawer gameId={gameId} fid={fid} /> */}
    </div>
  );
}

function CountdownCircle({
  ratio,
  total,
  secondsLeft,
}: {
  total: number; // total seconds in this round break
  ratio: number; // 1.0 → 0.0 progress (percent remaining)
  secondsLeft: number; // integer seconds left
}) {
  const size = 240;
  const stroke = 14;
  const r = (size - stroke) / 2;
  const circumference = 2 * Math.PI * r;

  // 'ratio' is percent remaining (1.0 -> 0).
  // This formula makes the dashOffset go from 0 (full circle)
  // to 'circumference' (empty circle) as ratio goes from 1 to 0.
  const dashOffset = circumference * (1 - ratio);
  // const angle = ratio * 360 - 90; // For the commented-out dot

  return (
    <div
      className="relative"
      style={{ width: size, height: size }}
      aria-label="Next round countdown"
      role="timer"
      aria-live="polite"
      aria-valuemin={0}
      aria-valuemax={total}
      aria-valuenow={secondsLeft}
    >
      <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
        <circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke="rgba(255,255,255,0.15)"
          strokeWidth={stroke}
        />

        {/* Progress Ring */}
        <g transform={`rotate(-90 ${size / 2} ${size / 2})`}>
          <circle
            cx={size / 2}
            cy={size / 2}
            r={r}
            fill="none"
            stroke={BLUE}
            strokeWidth={stroke}
            strokeLinecap="round"
            strokeDasharray={circumference}
            strokeDashoffset={dashOffset}
            style={{ transition: "stroke-dashoffset 0.2s linear" }}
          />
        </g>
      </svg>

      {/* Moving progress dot (commented out in original) */}
      {/* <div
        className="absolute left-1/2 top-1/2"
        style={{
          transform: `translate(-50%, -50%) rotate(${angle}deg)`,
          transition: "transform 0.2s linear",
          width: size,
          height: size,
          pointerEvents: "none",
        }}
      >
        <span
          className="absolute block rounded-full"
          style={{
            width: stroke + 6,
            height: stroke + 6,
            background: BLUE,
            left: "50%",
            top: "50%",
            transform: `translate(-50%, -50%) translateY(${-r}px)`,
            boxShadow: "0 0 0 2px rgba(30,139,255,0.35)",
          }}
        />
      </div> */}

      {/* Timer Text */}
      <div className="pointer-events-none absolute inset-0 grid place-items-center">
        <span
          className="font-bold leading-none text-white tabular-nums"
          style={{
            fontSize: "clamp(2.5rem, 10vw, 7rem)",
          }}
        >
          {String(secondsLeft).padStart(2, "0")}
        </span>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/JoinGameView.tsx ---
"use client";

import { useCallback, useMemo } from "react";
import Image from "next/image";
import { motion, useMotionValue } from "framer-motion";
import { CardStack } from "@/components/CardStack";

import { useRouter } from "next/navigation";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { cn } from "@/lib/utils";
import { HydratedGame, HydratedUser } from "@/state/types";
import { joinGameAction } from "@/actions/game";

export default function JoinGameView({
  game,
  userInfo,
  friends,
}: {
  game: HydratedGame;
  userInfo: HydratedUser;
  friends: { fid: number; username: string; pfpUrl: string }[];
}) {
  const router = useRouter();

  const joinedCount = game?._count.tickets ?? 0;
  const avatars = useMemo(() => {
    return friends.slice(0, 4).map((friend) => ({
      src: friend.pfpUrl,
      alt: friend.username,
    }));
  }, [friends]);

  const bx = useMotionValue(0);
  const by = useMotionValue(0);
  const onBtnMove: React.PointerEventHandler<HTMLButtonElement> = (e) => {
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    bx.set(e.clientX - (rect.left + rect.width / 2));
    by.set(e.clientY - (rect.top + rect.height / 2));
  };
  const onBtnLeave = () => {
    bx.set(0);
    by.set(0);
  };

  const canJoin = Boolean(
    userInfo?.tickets.length && userInfo.tickets.length > 0
  );
  const handleJoin = useCallback(async () => {
    if (!canJoin) {
      router.replace("/lobby");
      return;
    }
    if (typeof window !== "undefined" && "vibrate" in navigator) {
      navigator.vibrate?.(10);
    }
    const result = await joinGameAction({ fid: userInfo.fid, gameId: game.id });
    if (result.success) {
      router.refresh();
    } else {
      console.error("Failed to join game:", result.error);
    }
  }, [canJoin, router, userInfo.fid, game.id]);

  const joinedLabel = joinedCount === 1 ? "person has" : "people have";

  const isDisabledByLoadingOrError = false;
  const buttonText = canJoin ? "JOIN GAME" : "GET TICKET";

  return (
    <div className="relative flex h-[100dvh] w-full overflow-hidden bg-black text-white">
      <Image
        src="/images/game-hero.gif"
        alt="Game background animation"
        fill
        priority
        className="object-cover"
      />
      <div className="absolute inset-0 bg-gradient-to-b from-black/20 via-black/60 to-black/95 pointer-events-none" />

      <div className="absolute inset-x-0 bottom-0 flex flex-col items-center justify-end px-6 pb-10 gap-6 pointer-events-none">
        <motion.div className="pointer-events-auto w-full max-w-sm">
          <FancyBorderButton
            aria-label={buttonText}
            onPointerMove={onBtnMove}
            onPointerLeave={onBtnLeave}
            disabled={isDisabledByLoadingOrError}
            onClick={handleJoin}
            className={cn(
              "w-full rounded-[18px] border-b-[6px] border-r-[6px] border-[#FFC931] bg-white px-6 py-4 text-center shadow-[0_6px_0_0_#FFC931] transition",
              isDisabledByLoadingOrError && "opacity-60 cursor-not-allowed"
            )}
          >
            <span className="block font-body text-2xl leading-none text-[#F5BB1B]">
              {buttonText}
            </span>
          </FancyBorderButton>
          {/* {statsError && !isLoadingStats && ( */}
          {/* <p className="text-center text-red-400 text-xs mt-2 pointer-events-auto">
              {" "}
              {statsError.message || "Could not load player count."}
            </p>
          )} */}
        </motion.div>

        <div className="flex items-center justify-center gap-3 pointer-events-auto">
          <CardStack
            images={avatars}
            size="clamp(32px, 7vw, 52px)"
            rotations={[-8.7, 5.85, -3.57, 7.56]}
            ariaLabel={`${joinedCount} players have joined`}
          />
          <span className="text-sm font-body text-[#DBE0F0]">
            {joinedCount} {joinedLabel} joined the game
          </span>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/LeaveGameDrawer.tsx ---
"use client";

import { useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";
import { cn } from "@/lib/utils";

interface LeaveGameDrawerProps {
  open: boolean;
  onClose: () => void;
  onConfirmLeave: () => void;
}

export default function LeaveGameDrawer({
  open,
  onClose,
  onConfirmLeave,
}: LeaveGameDrawerProps) {
  useEffect(() => {
    if (!open) return;
    const originalOverflow = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = originalOverflow;
    };
  }, [open]);

  useEffect(() => {
    if (!open) return;
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === "Escape") {
        onClose();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [open, onClose]);

  return (
    <AnimatePresence>
      {open && (
        <motion.div
          role="dialog"
          aria-modal="true"
          aria-labelledby="leave-game-title"
          className="fixed inset-0 z-100 font-display"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
        >
          <div
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onClose}
            aria-hidden="true"
          />
          <motion.div
            className="absolute inset-x-0 bottom-0"
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", stiffness: 240, damping: 28 }}
          >
            {/* Full width background container */}
            <div
              className="w-full rounded-t-2xl overflow-hidden noise bg-gradient-to-b from-[#1E1E1E] to-black"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Full width header background */}
              <div className="relative w-full border-b border-white/5 bg-[#191919]">
                {/* Slug indicator stays centered and max width contained */}
                <div className="mx-auto w-full max-w-[480px] px-4 pt-3 pb-3 relative">
                  <div className="absolute left-1/2 top-2 -translate-x-1/2 h-[5px] w-9 rounded-[2.5px] bg-white/40" />
                  <div className="pt-5 text-center">
                    {/* <p>Optional Timer or Title Here</p> */}
                  </div>
                </div>
              </div>
              {/* Content */}
              <div
                className="px-4"
                style={{
                  maxHeight: "min(75vh, 644px)",
                  overflowY: "auto",
                }}
              >
                <div className="mx-auto w-full max-w-[393px] pt-8 pb-6 text-center">
                  <div className="mb-3 inline-block">
                    <Image
                      src="/images/illustrations/leave-door.svg"
                      alt=""
                      width={84}
                      height={90}
                      priority
                    />
                  </div>
                  <h2
                    id="leave-game-title"
                    className="font-body text-white"
                    style={{
                      fontSize: "44px",
                      lineHeight: "0.92",
                      letterSpacing: "-0.03em",
                    }}
                  >
                    RAGE QUIT?
                  </h2>
                  <div className="mt-2 mb-6">
                    <p className="font-display font-medium text-[16px] leading-[130%] tracking-[-0.03em] text-[#99A0AE]">
                      Leaving so soon?
                    </p>
                  </div>
                  <button
                    onClick={onClose}
                    className={cn(
                      "group w-full rounded-xl bg-white px-4 py-[12px] border-0 relative text-center select-none",
                      "border-r-[5px] border-b-[5px] border-[#14B985]",
                      "transition active:translate-y-[2px] active:border-b-[3px]"
                    )}
                  >
                    <span
                      className="block font-body text-[#14B985]"
                      style={{
                        fontSize: "26px",
                        lineHeight: "1.15",
                        letterSpacing: "-0.02em",
                      }}
                    >
                      STAY
                    </span>
                  </button>
                  {/* Secondary CTA (YES, LEAVE) */}
                  <div className="mt-3">
                    <button
                      onClick={onConfirmLeave}
                      className="w-full rounded-xl px-4 py-[12px] text-center transition hover:bg-white/5 active:bg-white/10"
                    >
                      <span
                        className="font-body text-[#00CFF2]"
                        style={{
                          fontSize: "18px",
                          lineHeight: "1.15",
                          letterSpacing: "-0.02em",
                        }}
                      >
                        YES, LEAVE
                      </span>
                    </button>
                  </div>
                  <div className="h-4" />
                </div>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/WaitingView.tsx ---
"use client";

import { useMemo, useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import { Clock } from "@/components/icons";
import { AvatarDiamond } from "./AvatarDiamond";

import { calculatePrizePool, cn } from "@/lib/utils";
import { HydratedGame, HydratedUser } from "@/state/types";

import { BottomNav } from "@/components/BottomNav";
import ChatTickerOverlay from "./ChatTickerOverlay";
import { Chat } from "./Chat";

/**
 * Formats milliseconds into a MM:SS string.
 */
const formatMsToMMSS = (ms: number): string => {
  const totalSeconds = Math.max(0, Math.ceil(ms / 1000));
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
    2,
    "0"
  )}`;
};

/**
 * View displayed while waiting for the next game to start.
 * Shows a countdown, prize pool, player avatars, and chat.
 */
export default function WaitingView({
  game,
  startTime,
  userInfo,
}: {
  game: HydratedGame;
  startTime: string | Date;
  userInfo: HydratedUser;
}) {
  const router = useRouter();
  const [chatOpen, setChatOpen] = useState(false);
  // Timer logic for countdown
  const [now, setNow] = useState(Date.now());
  const startTimeMs = useMemo(() => new Date(startTime).getTime(), [startTime]);

  useEffect(() => {
    const interval = setInterval(() => {
      const newNow = Date.now();
      setNow(newNow);

      if (newNow >= startTimeMs) {
        clearInterval(interval);
        router.refresh(); // Transition to the game
      }
    }, 1000);

    return () => clearInterval(interval);
  }, [startTimeMs, router]);

  // Calculate remaining time, never negative
  const remainingMs = Math.max(0, startTimeMs - now);
  const formattedTime = formatMsToMMSS(remainingMs);

  // Full player avatars list
  const diamondAvatars = useMemo(() => {
    const players = [
      { username: "Player 1", pfpUrl: "/images/lobby/1.jpg" },
      { username: "Player 2", pfpUrl: "/images/lobby/2.jpg" },
      { username: "Player 3", pfpUrl: "/images/lobby/3.jpg" },
      { username: "Player 4", pfpUrl: "/images/lobby/4.jpg" },
      { username: "Player 5", pfpUrl: "/images/lobby/5.jpg" },
      { username: "Player 6", pfpUrl: "/images/lobby/6.jpg" },
      { username: "Player 7", pfpUrl: "/images/lobby/7.jpg" },
      { username: "Player 8", pfpUrl: "/images/lobby/8.jpg" },
      { username: "Player 9", pfpUrl: "/images/lobby/9.jpg" },
      { username: "Player 10", pfpUrl: "/images/lobby/10.jpg" },
      { username: "Player 11", pfpUrl: "/images/lobby/11.jpg" },
      { username: "Player 12", pfpUrl: "/images/lobby/12.jpg" },
      { username: "Player 13", pfpUrl: "/images/lobby/13.jpg" },
      { username: "Player 14", pfpUrl: "/images/lobby/14.jpg" },
      { username: "Player 15", pfpUrl: "/images/lobby/15.jpg" },
      { username: "Player 16", pfpUrl: "/images/lobby/16.jpg" },
      { username: "Player 17", pfpUrl: "/images/lobby/17.jpg" },
      { username: "Player 18", pfpUrl: "/images/lobby/18.jpg" },
      { username: "Player 19", pfpUrl: "/images/lobby/19.jpg" },
      { username: "Player 20", pfpUrl: "/images/lobby/20.jpg" },
      { username: "Player 21", pfpUrl: "/images/lobby/21.jpg" },
      { username: "Player 22", pfpUrl: "/images/lobby/22.jpg" },
      { username: "Player 23", pfpUrl: "/images/lobby/23.jpg" },
      { username: "Player 24", pfpUrl: "/images/lobby/24.jpg" },
      { username: "Player 25", pfpUrl: "/images/lobby/25.jpg" },
    ];
    return players.map((player) => ({
      id: player.username,
      src: player.pfpUrl,
      alt: player.username,
    }));
  }, []);

  // Format prize pool, default to "$0.00"
  const formattedPrizePool = `$${calculatePrizePool(game).toLocaleString(
    "en-US",
    { minimumFractionDigits: 2, maximumFractionDigits: 2 }
  )}`;
  const playerCount = game?._count.tickets ?? 0;

  return (
    <div
      className={cn(
        "w-full min-h-[92dvh] flex flex-col flex-1 text-foreground overflow-hidden items-center relative max-w-screen-sm mx-auto px-4"
      )}
    >
      <section className="flex-1 flex flex-col items-center gap-3 w-full pt-6 pb-4 overflow-visible">
        <div className="flex w-full h-10 min-h-[38px] items-center justify-center gap-0.5 p-2 sm:p-3">
          <div className="order-0 flex h-7 sm:h-[28px] min-w-0 flex-1 flex-col justify-center gap-3.5 font-body">
            <div className="order-0 flex h-7 sm:h-[28px] min-w-0 w-full flex-row items-center gap-2">
              <span
                className="h-7 w-7 flex-none sm:h-[28px] sm:w-[28px]"
                aria-label="Countdown"
              >
                <Clock />
              </span>
              <span
                className="truncate pl-1 select-none text-white font-normal leading-[0.92] tracking-tight"
                style={{
                  fontSize: "clamp(1rem,4vw,1.6rem)",
                  letterSpacing: "-0.03em",
                }}
              >
                GAME STARTS IN
              </span>
            </div>
          </div>
          <div className="order-1 box-border z-0 flex h-10 min-w-[64px] w-[clamp(72px,20vw,110px)] max-w-[140px] flex-none flex-row items-center justify-center rounded-full border-2 border-[var(--color-neon-pink)] px-4 py-1 sm:px-5 sm:py-2 tabular-nums">
            <span className="px-0 flex items-end justify-center w-full min-w-0 select-none not-italic text-center text-xs leading-[115%] text-[var(--color-neon-pink)]">
              {formattedTime}
            </span>
          </div>
        </div>
        {/* Prize Pool Display */}
        <div className="flex w-full min-h-24 flex-col items-center justify-end gap-1 pb-2.5">
          <p className="w-auto min-w-[60px] sm:min-w-[80px] select-none text-center font-display font-medium leading-[1.3] tracking-tight text-muted text-[0.95rem] sm:text-base md:text-lg">
            Current prize pool
          </p>
          <div className="flex min-h-10 sm:min-h-[2.7rem] w-full items-center justify-center px-2 sm:px-4">
            <span className="block min-w-[70px] sm:min-w-[90px] select-none text-center font-body font-normal leading-[0.92] tracking-tight text-success text-[clamp(2rem,6vw,3rem)]">
              {formattedPrizePool}
            </span>
          </div>
        </div>
        <div className="w-full flex justify-center">
          <AvatarDiamond
            avatars={diamondAvatars}
            cellMin={32}
            cellMax={54}
            gap={2}
            className="scale-95 sm:scale-100"
          />
        </div>
        <p className="mt-1 min-w-[120px] text-center font-display font-medium tracking-[-0.03em] text-muted text-[clamp(13px,4vw,16px)] leading-[130%]">
          {playerCount} {playerCount === 1 ? "player has" : "players have"}{" "}
          joined
        </p>
      </section>
      <ChatTickerOverlay bottomOffset={150} />
      <ChatInput
        onOpenChat={() => {
          setChatOpen(true);
        }}
        bottomOffset={60}
      />
      <BottomNav />
      <Chat
        isOpen={chatOpen}
        onClose={() => {
          setChatOpen(false);
        }}
      />
    </div>
  );
}

// --- Chat Input Component ---
const ChatInput = ({
  onOpenChat,
  bottomOffset,
}: {
  onOpenChat: () => void;
  bottomOffset: number;
}) => {
  return (
    <div
      className="absolute left-0 right-0 h-[78px] w-full px-4 pt-3 pb-5"
      style={{ bottom: `${bottomOffset}px` }} // Use dynamic bottom offset
    >
      <button
        onClick={onOpenChat}
        className="flex h-full w-full items-center rounded-full bg-white/5 px-4 py-[14px] text-white/40 transition-all duration-200 ease-in-out
                   hover:bg-white/10
                   active:bg-white/15
                   focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2 focus-visible:ring-offset-black"
        style={{
          fontSize: "14px",
          fontWeight: 500,
          letterSpacing: "-0.03em",
          lineHeight: "130%",
        }}
      >
        Type...
      </button>
    </div>
  );
};

--- File: ./src/app/(authenticated)/game/[gameId]/_components/QuestionView.tsx ---
// ───────────────────────── QuestionView.tsx ─────────────────────────
"use client";
import * as React from "react";
import { useRouter } from "next/navigation";
import SoundManager from "@/lib/SoundManager";
import { notify } from "@/components/ui/Toaster";
import { HydratedGame, HydratedUser } from "@/state/types";
import { submitAnswerAction } from "@/actions/game";
import QuestionCard from "./QuestionCard";
import { QuestionHeader } from "./QuestionCardHeader";
import { isSnapshot, formatMsToMMSS } from "@/lib/utils"; // Import new helper
import RoundCountdownView from "./RoundCountdownView";
import { useUserPreferences } from "@/components/providers/userPreference";

// ───────────────────────── CONSTANTS ─────────────────────────
const NEXT_QUESTION_DELAY_SECONDS = 3;
const TIMER_PRECISION_MS = 100; // Update timer every 100ms

// Define the states the question view can be in
type QuestionState = "SHOWING_ROUND_BREAK" | "SHOWING_QUESTION" | "SHOWING_GAP";

// ───────────────────────── COMPONENT ─────────────────────────
export default function QuestionView({
  game,
  userInfo,
}: {
  game: HydratedGame;
  userInfo: HydratedUser;
}) {
  const { prefs } = useUserPreferences();
  const router = useRouter();

  // State for the currently selected option
  const [selectedOption, setSelectedOption] = React.useState<string | null>(
    null
  );
  // NEW: State to track network request
  const [isSubmitting, setIsSubmitting] = React.useState(false);

  // Refs to hold the latest state for use in intervals
  const selectedOptionRef = React.useRef(selectedOption);
  React.useEffect(() => {
    selectedOptionRef.current = selectedOption;
  }, [selectedOption]);

  // Game configuration
  const questionTimeLimitMs = (game?.config?.questionTimeLimit ?? 10) * 1000;
  const roundTimeLimitMs = (game?.config?.roundTimeLimit ?? 15) * 1000;
  const gapTimeLimitMs = NEXT_QUESTION_DELAY_SECONDS * 1000;

  // Question progress
  const answeredIds = new Set(
    userInfo?.answers?.map((a) => a.questionId) ?? []
  );
  const unansweredQuestions =
    game?.questions?.filter((q) => !answeredIds.has(q.id)) ?? [];
  const totalQuestions = game?.questions?.length ?? 0;
  const answeredCount = totalQuestions - unansweredQuestions.length;
  const currentQuestion = unansweredQuestions[0];
  const currentQuestionId = currentQuestion?.id;

  // Timer and State Machine State
  const [state, setState] = React.useState<QuestionState>(() => {
    // Determine initial state when component loads
    const isBreak =
      isSnapshot(answeredCount, totalQuestions) &&
      answeredCount > 0 &&
      answeredCount !== totalQuestions;
    return isBreak ? "SHOWING_ROUND_BREAK" : "SHOWING_QUESTION";
  });
  const [deadline, setDeadline] = React.useState<number>(0);
  const [now, setNow] = React.useState<number>(Date.now());
  const questionStartTimeRef = React.useRef<number | null>(null);

  // React.useEffect(() => {
  //   if (!currentQuestion) return;
  //   const soundUrl = currentQuestion.soundUrl;
  //   if (!prefs.soundEnabled) return;

  //   // PLAY SOUND WHEN QUESTION SHOWS
  //   SoundManager.play("questionStart", { volume: 0.9 });

  //   return () => {
  //     // STOP SOUND WHEN QUESTION ENDS OR COMPONENT UNMOUNTS
  //     SoundManager.stop("questionStart");
  //   };
  // }, [prefs.soundEnabled, currentQuestion]);

  // ───────────────────────── QUESTION SOUND ─────────────────────────
  React.useEffect(() => {
    if (!currentQuestion) return;
    if (!prefs.soundEnabled) return;

    // Stop any leftover sounds before playing new one
    SoundManager.stopAll();

    // PLAY THE QUESTION'S SOUND FILE
    console.log("playing question sound", currentQuestion.soundUrl);
    SoundManager.play(currentQuestion.soundUrl!, { volume: 1 });

    return () => {
      // STOP WHEN QUESTION ENDS OR COMPONENT UNMOUNTS
      console.log("stopping question sound", currentQuestion.soundUrl);
      SoundManager.stop(currentQuestion.soundUrl!);
    };
  }, [currentQuestion, prefs.soundEnabled]);

  React.useEffect(() => {
    if (state === "SHOWING_ROUND_BREAK" && prefs.soundEnabled) {
      console.log("playing round break sound");
      SoundManager.play("roundBreak", { loop: true, volume: 0.4 });
      return () => {
        console.log("stopping round break sound");
        SoundManager.stop("roundBreak");
      };
    }
  }, [state, prefs.soundEnabled]);

  // ───────────────────────── ANSWER SUBMISSION ─────────────────────────
  // Memoize the submission handler
  const handleAnswerClick = React.useCallback(
    async (option: string, questionId: number) => {
      if (!game || !questionId) return;
      if (prefs.soundEnabled) SoundManager.play("click");
      if (!userInfo.fid) {
        notify.error("Cannot submit answer: User not identified.");
        return;
      }

      setIsSubmitting(true); // <-- SET LOADING STATE

      const timeTakenMs =
        questionStartTimeRef.current != null
          ? Date.now() - questionStartTimeRef.current
          : 0;
      const timeTakenSeconds = timeTakenMs / 1000;

      const result = await submitAnswerAction({
        fid: userInfo.fid,
        gameId: game.id,
        questionId,
        selected: option,
        timeTaken: timeTakenSeconds,
      });

      // Check if this was the last question
      // Note: answeredCount is from props, so it's 1 behind the *new* count
      if (answeredCount + 1 === totalQuestions) {
        router.push(`/game/${game.id}/score`);
        return;
      }

      // Refresh to get the next question data
      if (!result.success) {
        notify.error("Submission failed:");
        setIsSubmitting(false); // <-- UNSET ON ERROR
        setSelectedOption(null);
      } else {
        setIsSubmitting(false);
        setSelectedOption(null);
        router.refresh(); // <-- Success will trigger unmount
      }
    },
    [
      userInfo.fid,
      game,
      prefs.soundEnabled,
      router,
      answeredCount,
      totalQuestions,
    ]
  );

  // Ref to hold the latest version of the submission handler
  const handleAnswerClickRef = React.useRef(handleAnswerClick);
  React.useEffect(() => {
    handleAnswerClickRef.current = handleAnswerClick;
  }, [handleAnswerClick]);

  // ───────────────────────── TIMER STATE MACHINE ─────────────────────────
  React.useEffect(() => {
    // This effect runs when the question changes (based on currentQuestionId)
    if (!currentQuestionId) {
      // No more questions, submission handler will redirect
      return;
    }

    // 1. Set initial state and deadline for this question
    const startTime = Date.now();
    setNow(startTime);

    const isBreak =
      isSnapshot(answeredCount, totalQuestions) &&
      answeredCount > 0 &&
      answeredCount !== totalQuestions;

    const initialState: QuestionState = isBreak
      ? "SHOWING_ROUND_BREAK"
      : "SHOWING_QUESTION";
    let currentDeadline: number;

    if (initialState === "SHOWING_ROUND_BREAK") {
      currentDeadline = startTime + roundTimeLimitMs;
    } else {
      // This is the start of the question
      questionStartTimeRef.current = startTime;
      currentDeadline = startTime + questionTimeLimitMs;
    }

    setState(initialState);
    setDeadline(currentDeadline);

    // 2. Start the interval timer
    const interval = setInterval(() => {
      const timeNow = Date.now();
      setNow(timeNow); // Update 'now' for UI rendering

      // 3. Check if the deadline has been reached
      if (timeNow > currentDeadline) {
        // Time's up, transition to the next state
        setState((prevState) => {
          if (prevState === "SHOWING_ROUND_BREAK") {
            // Break is over, start the question
            questionStartTimeRef.current = timeNow;
            currentDeadline = timeNow + questionTimeLimitMs;
            setDeadline(currentDeadline);
            return "SHOWING_QUESTION";
          }

          if (prevState === "SHOWING_QUESTION") {
            // Question time is over, start the gap
            currentDeadline = timeNow + gapTimeLimitMs;
            setDeadline(currentDeadline);
            return "SHOWING_GAP";
          }

          if (prevState === "SHOWING_GAP") {
            // Gap time is over, submit the answer
            clearInterval(interval); // Stop the timer

            // Use refs to get the latest values
            const finalOption = selectedOptionRef.current ?? "noanswer";
            handleAnswerClickRef.current(finalOption, currentQuestionId);

            // Submission will trigger refresh/redirect, so just stop
            return prevState;
          }

          return prevState; // Should not happen
        });
      }
    }, TIMER_PRECISION_MS);

    // 4. Cleanup
    return () => {
      clearInterval(interval);
    };
  }, [
    currentQuestionId, // This is the key dependency
    answeredCount,
    totalQuestions,
    roundTimeLimitMs,
    questionTimeLimitMs,
    gapTimeLimitMs,
    // handleAnswerClickRef and selectedOptionRef are refs, not needed here
  ]);

  // ───────────────────────── RENDER VALUES ─────────────────────────
  const remainingTimeMs = Math.max(0, deadline - now);
  const formattedTime = formatMsToMMSS(remainingTimeMs);

  let percent = 0;
  if (state === "SHOWING_QUESTION") {
    percent =
      questionTimeLimitMs > 0 ? remainingTimeMs / questionTimeLimitMs : 0;
  } else if (state === "SHOWING_GAP") {
    percent = gapTimeLimitMs > 0 ? remainingTimeMs / gapTimeLimitMs : 0;
  } else if (state === "SHOWING_ROUND_BREAK") {
    percent = roundTimeLimitMs > 0 ? remainingTimeMs / roundTimeLimitMs : 0;
  }
  percent = Math.max(0, Math.min(1, percent)); // Clamp between 0 and 1

  // ───────────────────────── RENDER ─────────────────────────
  return (
    <div className="w-full max-w-md sm:max-w-lg mx-auto mt-4">
      {state === "SHOWING_ROUND_BREAK" ? (
        // Pass timer values to the round countdown view
        <RoundCountdownView
          percent={percent}
          secondsLeft={Math.ceil(remainingTimeMs / 1000)} // <-- FIX: Pass seconds
          totalSeconds={Math.ceil(roundTimeLimitMs / 1000)} // <-- FIX: Pass seconds
        />
      ) : (
        <>
          <QuestionHeader
            state={state}
            formattedTime={formattedTime}
            percent={percent}
            currentQuestion={answeredCount} // Note: This is 0-indexed for the *next* question
            totalQuestions={totalQuestions}
            questionTimeLimit={questionTimeLimitMs / 1000} // Pass in seconds
          />
          <QuestionCard
            question={currentQuestion}
            onSelectAnswer={(option) => {
              if (isSubmitting) return; // <-- Don't allow clicks while submitting
              setSelectedOption(option);
            }}
            selectedOption={selectedOption}
            isSubmitting={isSubmitting} // <-- Pass state down
          />
        </>
      )}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/AvatarDiamond.tsx ---
"use client";

import * as React from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";

type Avatar = {
  id: string | number;
  src: string;
  alt?: string;
  opacity?: number;
};

type Props = {
  avatars: Avatar[];
  cellMin?: number;
  cellMax?: number;
  gap?: number;
  className?: string;
};

/**
 * Renders a fixed diamond pattern grid of avatars.
 * The pattern has 5 rows and 7 columns, with specific cells filled.
 * Purely presentational component.
 */
export function AvatarDiamond({
  avatars,
  cellMin = 32,
  cellMax = 54,
  gap = 2,
  className = "",
}: Props) {
  // Fixed pattern defining which grid cells (1-based column index) are filled in each row
  const pattern: number[][] = [
    [2, 4, 6], // Row 1
    [1, 3, 5, 7], // Row 2
    [2, 4, 6], // Row 3
    [1, 3, 5, 7], // Row 4
    [2, 4, 6], // Row 5
  ];
  // Calculate the total capacity of the diamond pattern
  const capacity = pattern.reduce((n, row) => n + row.length, 0);
  // Limit the input avatars to the diamond's capacity
  const data = avatars.slice(0, capacity);

  // Map the pattern to slot data including row, column, and avatar info
  const slots: { row: number; col: number; avatar?: Avatar }[] = [];
  let avatarIndex = 0;
  pattern.forEach((cols, rowIndex) => {
    cols.forEach((colIndex) => {
      slots.push({
        row: rowIndex + 1,
        col: colIndex,
        avatar: data[avatarIndex++],
      });
    });
  });

  // Define CSS variables for responsive sizing based on props
  const styleVariables = {
    "--cell": `clamp(${cellMin}px, 7.5vw, ${cellMax}px)`,
    "--tile": "calc(var(--cell) - 4px)",
    "--gap": `${gap}px`,
  } as React.CSSProperties;

  return (
    <div
      className={cn(
        "relative grid gap-[var(--gap)]",
        "[grid-template-columns:repeat(7,var(--cell))]",
        "[grid-auto-rows:var(--cell)]",
        className
      )}
      style={styleVariables}
      aria-label="Avatar grid"
      role="grid"
    >
      {slots.map((slot) => (
        <div
          key={`r${slot.row}-c${slot.col}`}
          role="gridcell"
          className="relative"
          style={{
            gridColumnStart: slot.col,
            gridRowStart: slot.row,
            opacity: slot.avatar?.opacity ?? 1,
          }}
          aria-hidden={!slot.avatar}
        >
          <Tile avatar={slot.avatar} />
        </div>
      ))}
    </div>
  );
}

/**
 * Internal component to render a single avatar tile within the diamond grid.
 */
function Tile({ avatar }: { avatar?: Avatar }) {
  // If no avatar data, render an empty div to maintain grid structure
  if (!avatar) return <div className="size-[var(--cell)]" aria-hidden="true" />;

  return (
    <div className="relative size-[var(--cell)]">
      <Image
        src={avatar.src}
        alt={avatar.alt ?? `Avatar ${avatar.id}`}
        fill
        sizes="var(--tile)"
        className="absolute left-[2px] top-[2px] size-[var(--tile)] rounded-sm border border-[#464646] object-cover bg-[#F0F3F4]"
        draggable={false}
      />
      <span
        className="absolute left-0 top-0 size-1 bg-white/30"
        aria-hidden="true"
      />{" "}
      <span
        className="absolute right-0 top-0 size-1 bg-white/30"
        aria-hidden="true"
      />{" "}
      <span
        className="absolute right-0 bottom-0 size-1 bg-white/30"
        aria-hidden="true"
      />{" "}
      <span
        className="absolute left-0 bottom-0 size-1 bg-white/30"
        aria-hidden="true"
      />{" "}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/QuestionCardHeader.tsx ---
// ───────────────────────── QuestionCardHeader.tsx ─────────────────────────
"use client";
import { SoundOffIcon, SoundOnIcon } from "@/components/icons";

import Image from "next/image";
import { formatMsToMMSS } from "@/lib/utils"; // Import helper
import { useUserPreferences } from "@/components/providers/userPreference";

// Define the states from QuestionView
type QuestionState = "SHOWING_ROUND_BREAK" | "SHOWING_QUESTION" | "SHOWING_GAP";

interface QuestionHeaderProps {
  currentQuestion: number;
  totalQuestions: number;
  questionTimeLimit: number; // In seconds
  state: QuestionState;
  formattedTime: string;
  percent: number; // A value from 0 to 1
}

export function QuestionHeader({
  currentQuestion,
  totalQuestions,
  questionTimeLimit, // in seconds
  state,
  formattedTime,
  percent,
}: QuestionHeaderProps) {
  const { prefs, toggleSound } = useUserPreferences();

  // Format the default time limit (e.g., "00:10")
  const defaultFormattedTime = formatMsToMMSS(questionTimeLimit * 1000);

  // Note: currentQuestion is the count of *answered* questions.
  // For display, we want to show the *current* question number (which is answered + 1)
  const displayQuestionNum = currentQuestion + 1;

  return (
    <div className="w-full flex items-center justify-between px-3 py-2 ">
      {/* Left: Question Index */}
      <span className="font-editundo text-white text-[18px] leading-none tracking-tight">
        {String(displayQuestionNum).padStart(2, "0")}/
        {String(totalQuestions).padStart(2, "0")}
      </span>
      {/* Center: Sound Button */}
      <button
        onClick={toggleSound}
        className=" bg-white/15 rounded-full p-2 backdrop-blur-sm active:scale-95 transition-transform mr-auto ml-3"
        aria-label={prefs.soundEnabled ? "Mute sound" : "Unmute sound"}
        type="button"
      >
        {prefs.soundEnabled ? (
          <SoundOnIcon className="w-4 h-4 text-white" />
        ) : (
          <SoundOffIcon className="w-4 h-4 text-white" />
        )}
      </button>

      {/* TIMER MODES */}
      {state === "SHOWING_QUESTION" && (
        <div className="flex items-center gap-2">
          <span className="font-pixel text-white text-lg">{formattedTime}</span>
          <CapsuleProgress progress={percent} />
        </div>
      )}
      {state === "SHOWING_GAP" && (
        <div className="flex items-center gap-1">
          <Image
            src="/images/icons/clock.svg"
            width={30}
            height={30}
            alt="clock"
            className="w-full h-full"
          />
          <span className="font-pixel text-[#B93814] text-2xl">
            {formattedTime}
          </span>
        </div>
      )}

      {/* Fallback: Show the default time limit if not running */}
      {state !== "SHOWING_QUESTION" && state !== "SHOWING_GAP" && (
        <span className="font-pixel text-white text-lg">
          {defaultFormattedTime}
        </span>
      )}
    </div>
  );
}

export function CapsuleProgress({ progress }: { progress: number }) {
  return (
    <div className="relative w-[78px] h-[12px]">
      <svg
        width="78"
        height="12"
        viewBox="0 0 78 12"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        className="absolute inset-0"
      >
        {/* BACKGROUND (static) */}
        <path d="M4.65347 0.0181034C4.67876 0.0181034..." fill="#4A0B0B" />
        <path d="M5.07078 0.271509C5.09185 0.271509..." fill="#BE3C2B" />
        <path d="M5.91797 1.0453C5.93905 1.0453..." fill="#B55E2C" />
        <path d="M5.91797 1.0453C5.93905 1.0453..." fill="#E9DCCB" />
      </svg>

      {/* FOREGROUND (masked) */}
      <svg
        width="78"
        height="12"
        viewBox="0 0 78 12"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
        className="absolute inset-0"
        style={{
          clipPath: `inset(0 ${(1 - progress) * 100}% 0 0)`,
          transition: "clip-path 0.15s linear",
        }}
      >
        <path d="M4.65347 0.0181034C4.67876 0.0181034..." fill="#4A0B0B" />
        <path d="M5.07078 0.271509C5.09185 0.271509..." fill="#BE3C2B" />
        <path d="M5.91797 1.0453C5.93905 1.0453..." fill="#B55E2C" />
        <path d="M5.91797 1.0453C5.93905 1.0453..." fill="#E9DCCB" />
        <path d="M51.4162 0.990967..." fill="#F96F49" />
        <path d="M38.914 0.996029..." fill="#F96F49" />
        <path d="M52.9714 0.990967..." fill="#F96F49" />
        <path d="M18.0834 1.00079..." fill="#F96F49" />
        <path d="M34.7498 0.990967..." fill="#F96F49" />
        <path d="M5.89307 1.00079..." fill="#F96F49" />
        <path d="M24.861 0.996029..." fill="#F96F49" />
        <g style={{ mixBlendMode: "color-dodge", opacity: 0.8 }}>
          <path d="M7.36799 2.04066..." fill="#F73812" />
        </g>
        <g style={{ mixBlendMode: "color-dodge", opacity: 0.5 }}>
          <path d="M9.7453 2.82349..." fill="#FCC9A4" />
        </g>
      </svg>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/ChatDrawer.tsx ---
import Image from "next/image";
import { ForwardMessageIcon, MessageIcon } from "@/components/icons";
import { cn } from "@/lib/utils";
import { ChatWithUser, HydratedUser } from "@/state/types";
import { sendMessageAction } from "@/actions/chat";

// import { cookies } from "next/headers";

// Get the current user's fid from cookies
// export async function getCurrentUserFid(): Promise<number | null> {
//   const cookieStore = await cookies();
//   const fidCookie = cookieStore.get("fid")?.value;
//   if (!fidCookie || isNaN(Number(fidCookie))) return null;
//   return Number(fidCookie);
// }

// // Server data loader for chats
// async function getGameChats(gameId: number): Promise<ChatWithUser[]> {
//   return await prisma.chat.findMany({
//     where: { gameId },
//     orderBy: { createdAt: "asc" },
//     include: {
//       user: {
//         select: {
//           id: true,
//           fid: true,
//           name: true,
//           imageUrl: true,
//         },
//       },
//     },
//   });
// }

// // Form action form handler
async function handleFormSubmit(formData: FormData) {
  const gameId = Number(formData.get("gameId"));
  const message = String(formData.get("message") || "");
  const fid = Number(formData.get("fid"));

  // Optionally allow username/pfpUrl, but the server ignores them for inserts
  // Submit message via server action
  await sendMessageAction({ gameId, message, fid });
  // Tag revalidation happens in the server action itself
}

/**
 * Server Component: Renders chat messages for the current game, and a message form using server action.
 *
 * Expects:
 *   - gameId (from parent page params)
 *   - user (from parent layout, if available and can be passed as prop/context)
 */
export default function ChatDrawer({
  gameId,
  userInfo,
}: {
  gameId: number;
  userInfo: HydratedUser;
}) {
  // Fetch messages server-side
  // const messages = await getGameChats(gameId);
  // const user = await prisma.user.findUnique({
  //   where: { fid },
  //   select: {
  //     fid: true,
  //     name: true,
  //     imageUrl: true,
  //   },
  // });
  // if (!user) {
  //   return null;
  // }

  const messages: ChatWithUser[] = [];

  return (
    <div className="fixed bottom-0 left-0 right-0 w-full max-w-screen-sm mx-auto z-30 pointer-events-none">
      <div
        className="absolute inset-0 flex flex-col justify-end font-display pointer-events-auto"
        style={{ minHeight: "60dvh" }}
      >
        <div className="relative w-full mx-auto flex flex-col rounded-t-2xl app-background noise h-[85vh] max-h-[90dvh] sm:max-h-[600px] min-h-[60dvh] overflow-hidden pointer-events-auto">
          {/* Header */}
          <div className="flex flex-row items-center justify-between px-4 pt-8 pb-3 border-b border-white/5 bg-[#191919] rounded-t-2xl font-body shrink-0">
            <div className="flex flex-row items-center gap-2">
              <MessageIcon />
              <h2
                id="chat-drawer-title"
                className="text-white text-lg md:text-xl select-none"
              >
                lobby CHAT
              </h2>
            </div>
          </div>

          {/* Messages */}
          <div className="flex flex-col items-start gap-3 sm:gap-4 pb-4 pt-6 px-4 flex-1 min-h-0 overflow-y-scroll scrollbar-none w-full">
            {messages.map((msg, idx) => {
              const username = msg.user?.name ?? "anon";
              const avatar = msg.user?.imageUrl ?? null;
              const time = new Date(msg.createdAt).toLocaleTimeString([], {
                hour: "numeric",
                minute: "2-digit",
              });
              const isCurrentUser =
                userInfo &&
                (msg.user?.fid === userInfo.fid || msg.userId === userInfo.fid);

              return (
                <div
                  key={msg.id ?? idx}
                  className={cn(
                    "flex flex-col items-start gap-2 w-full",
                    isCurrentUser && "items-end"
                  )}
                  style={{ order: idx }}
                >
                  {!isCurrentUser && (
                    <div className="flex flex-row items-center gap-1.5 sm:gap-2 min-h-5 mb-0.5">
                      <div className="w-5 h-5 rounded-full bg-gray-100 overflow-hidden flex items-center justify-center shrink-0">
                        {avatar ? (
                          <Image
                            src={avatar}
                            alt={`${username}'s avatar`}
                            width={20}
                            height={20}
                            className="w-5 h-5 object-cover"
                          />
                        ) : (
                          <span className="text-gray-400 text-xs font-semibold">
                            {username?.[0]?.toUpperCase() ?? "•"}
                          </span>
                        )}
                      </div>
                      <span className="ml-1 font-display font-medium text-[0.92rem] leading-[130%] tracking-[-0.03em] text-white">
                        {username}
                      </span>
                      <span className="mx-1 w-[0.28rem] h-[0.28rem] bg-[#D9D9D9] rounded-full inline-block" />
                      <span className="font-display font-medium text-[0.72rem] leading-[130%] tracking-[-0.03em] text-[#99A0AE]">
                        {time}
                      </span>
                    </div>
                  )}

                  <div
                    className={cn(
                      "max-w-[80%] sm:max-w-[70%] border rounded-[0.75rem] px-4 py-3 flex flex-col justify-center",
                      isCurrentUser
                        ? "bg-blue-600/30 border-blue-500/20 rounded-br-none"
                        : "bg-white/[0.08] border-white/[0.05] rounded-bl-none"
                    )}
                  >
                    <p className="font-display font-medium text-base leading-[130%] tracking-[-0.03em] text-white break-words">
                      {msg.message}
                    </p>
                  </div>
                </div>
              );
            })}
            {/* Not using auto-scroll with useRef because this is now static SSR */}
          </div>

          {/* Message form - now handled with server action */}
          <form
            action={handleFormSubmit}
            method="POST"
            className="flex flex-row items-center bg-[#0E0E0E] px-4 py-5 gap-3 border-t border-white/5 shrink-0"
            style={{
              paddingBottom: "calc(env(safe-area-inset-bottom) + 1.25rem)",
            }}
          >
            <input type="hidden" name="gameId" value={gameId} />
            {userInfo && (
              <>
                <input type="hidden" name="fid" value={userInfo.fid} />
                <input
                  type="hidden"
                  name="username"
                  value={userInfo.name ?? ""}
                />
                <input
                  type="hidden"
                  name="pfpUrl"
                  value={userInfo.imageUrl ?? ""}
                />
              </>
            )}
            <div className="flex items-center bg-white/5 rounded-full flex-1 px-5 py-3">
              <input
                name="message"
                placeholder={
                  userInfo
                    ? "Type a comment..."
                    : "You must be logged in to send messages"
                }
                className="flex-1 bg-transparent outline-none text-white placeholder-white/40 text-base font-display"
                disabled={!userInfo}
                required
                maxLength={500}
                autoComplete="off"
              />
            </div>
            <button
              type="submit"
              className="ml-3 bg-[#1B8FF5] rounded-full w-10 h-10 flex items-center justify-center active:scale-95 transition-transform shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400 shrink-0"
              aria-label="Send message"
              disabled={!userInfo}
            >
              <ForwardMessageIcon />
            </button>
          </form>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/_components/Chat.tsx ---
import { useState, useRef, useEffect } from "react";
import { ChatIcon, SendIcon } from "@/components/icons";
import Backdrop from "@/components/ui/Backdrop";
import Image from "next/image";

// Single Comment component
const Comment = ({
  name,
  time,
  message,
  avatarUrl,
}: {
  name: string;
  time: string;
  message: string;
  avatarUrl: string;
}) => (
  <div className="flex w-full flex-col items-start gap-2">
    {/* User + Time */}
    <div className="flex items-center gap-1.5">
      {/* Replaced Next/Image with standard <img> tag */}
      <Image
        src={avatarUrl}
        alt={`${name} avatar`}
        width={20}
        height={20}
        className="rounded-full"
      />
      <span
        className="text-sm font-medium text-white"
        style={{ letterSpacing: "-0.03em" }}
      >
        {name}
      </span>
      <span className="h-0.5 w-0.5 rounded-full bg-gray-400"></span>
      <span
        className="text-[10px] font-medium text-gray-400"
        style={{ letterSpacing: "-0.03em" }}
      >
        {time}
      </span>
    </div>
    {/* Comment Body */}
    <div className="flex w-full flex-col justify-center rounded-r-lg rounded-bl-lg border border-white/5 bg-white/10 p-3">
      <p
        className="text-sm font-medium text-white"
        style={{ letterSpacing: "-0.03em" }}
      >
        {message}
      </p>
    </div>
  </div>
);

export const Chat = ({
  isOpen,
  onClose,
}: {
  isOpen: boolean;
  onClose: () => void;
}) => {
  const [message, setMessage] = useState("");
  const [comments, setComments] = useState([
    {
      id: 1,
      name: "rugpull847",
      time: "13:42",
      message: "game tuff man",
      avatarUrl: "/images/lobby/1.jpg",
    },
    {
      id: 2,
      name: "ianbowenthe",
      time: "13:42",
      message: "LFGGGG",
      avatarUrl: "/images/lobby/2.jpg",
    },
    {
      id: 3,
      name: "funddswen",
      time: "13:42",
      message: "Next round come onnnn",
      avatarUrl: "/images/lobby/3.jpg",
    },
    {
      id: 4,
      name: "apestonk",
      time: "13:42",
      message: "👀",
      avatarUrl: "/images/lobby/4.jpg",
    },
    {
      id: 5,
      name: "0xpotato",
      time: "13:42",
      message: "is this thing working",
      avatarUrl: "/images/lobby/5.jpg",
    },
    {
      id: 6,
      name: "bullishmaxi",
      time: "13:42",
      message: "i love this game",
      avatarUrl: "/images/lobby/6.jpg",
    },
  ]);

  const chatListRef = useRef<HTMLDivElement>(null);
  const inputRef = useRef<HTMLInputElement>(null); // Ref for the input

  // Auto-scroll to bottom when new comments are added
  useEffect(() => {
    if (chatListRef.current) {
      chatListRef.current.scrollTop = chatListRef.current.scrollHeight;
    }
  }, [comments]);

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (message.trim() === "") return;

    const newComment = {
      id: Date.now(),
      name: "You",
      time: new Date().toLocaleTimeString("en-US", {
        hour: "2-digit",
        minute: "2-digit",
        hour12: false,
      }),
      message: message.trim(),
      avatarUrl: "/images/lobby/7.jpg", // Placeholder for user's avatar
    };

    setComments([...comments, newComment]);
    setMessage("");
  };

  const hasText = message.trim().length > 0;

  return (
    <>
      <Backdrop isOpen={isOpen} onClose={onClose} />
      {/* Drawer */}
      <div
        className={`fixed bottom-0 left-0 right-0 z-50 flex h-[644px] w-full flex-col
                    rounded-t-[20px] bg-gradient-to-b from-[#1E1E0E] to-black
                    transition-transform duration-500 ease-in-out
                    ${isOpen ? "translate-y-0" : "translate-y-full"}`}
      >
        {/* Header */}
        <header
          className="relative flex h-[56px] w-full flex-shrink-0 items-center border-b border-white/10 bg-[#191919] px-6 py-3 rounded-t-[20px]"
          style={{
            minHeight: "56px",
          }}
        >
          {/* Grabber */}
          <button
            onClick={onClose}
            className="absolute top-2 left-1/2 h-3 w-14 -translate-x-1/2 rounded-full 
                       group transition-all focus:outline-none"
            aria-label="Close chat"
            tabIndex={0}
            style={{ zIndex: 10 }}
          >
            <div className="absolute top-1/2 left-1/2 h-[4px] w-10 -translate-x-1/2 -translate-y-1/2 rounded-full bg-white/40 group-hover:bg-white/60 group-active:bg-white/80 transition-all" />
          </button>
          {/* The actual content */}
          <div className="flex w-full items-center justify-between">
            <div className="flex items-center gap-2">
              <ChatIcon
                className="w-7 h-7 text-[#3795F6] -ml-2"
                style={{ minWidth: 28, minHeight: 28 }}
              />
              <span className="font-bold uppercase text-white font-body tracking-[0.04em] text-[1.40rem] select-none">
                LOBBY&nbsp;CHAT
              </span>
            </div>
            <span
              className="text-white font-bold text-[1.1rem] font-body tracking-tight select-none"
              style={{
                fontSize: "1.1rem",
                letterSpacing: "0.005em",
              }}
            >
              00:10
            </span>
          </div>
        </header>

        {/* Comment List */}
        <div
          ref={chatListRef}
          className="flex-1 space-y-3.5 overflow-y-auto p-4"
        >
          {comments.map((comment) => (
            <Comment
              key={comment.id}
              name={comment.name}
              time={comment.time}
              message={comment.message}
              avatarUrl={comment.avatarUrl}
            />
          ))}
        </div>

        {/* Footer Input */}
        <footer className="h-[98px] w-full flex-shrink-0 bg-[#0E0E0E] p-4 pt-5">
          <form
            onSubmit={handleSubmit}
            onClick={() => inputRef.current?.focus?.()} // Click wrapper to focus input
            className="flex h-[58px] w-full items-center gap-3 rounded-full bg-white/5 px-4 cursor-text" // Add cursor-text
          >
            <input
              ref={inputRef} // Assign the ref
              type="text"
              value={message}
              onChange={(e) => setMessage(e.target.value)}
              placeholder="Type a comment"
              className="flex-1 bg-transparent text-sm font-medium text-white placeholder:text-white/40
                         focus:outline-none"
              style={{ letterSpacing: "-0.03em" }}
            />
            {/* Send Button - appears when there is text */}
            <button
              type="submit"
              disabled={!hasText}
              className={`flex h-[30px] w-[50px] items-center justify-center rounded-full bg-blue-500
                         transition-all duration-200 ease-in-out
                         ${
                           hasText
                             ? "scale-100 opacity-100"
                             : "scale-50 opacity-0"
                         }
                         ${!hasText ? "pointer-events-none" : ""}
                         hover:bg-blue-400 active:bg-blue-600
                         focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-blue-500
                         focus-visible:ring-offset-2 focus-visible:ring-offset-black`}
              aria-label="Send message"
            >
              <SendIcon />
            </button>
          </form>
        </footer>
      </div>
    </>
  );
};

--- File: ./src/app/(authenticated)/game/[gameId]/gameClientImpl.tsx ---
// ====== Updated gameClientImpl.tsx ======
"use client";

import { useCallback, useEffect, useState } from "react";
import { useRouter } from "next/navigation";

import QuestionView from "./_components/QuestionView";
import WaitingView from "./_components/WaitingView";
import JoinGameView from "./_components/JoinGameView";
import LeaveGameDrawer from "./_components/LeaveGameDrawer";
import LogoIcon from "@/components/logo/LogoIcon";
import { LeaveGameIcon, WalletIcon } from "@/components/icons";

import { useMiniUser } from "@/hooks/useMiniUser";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { base } from "wagmi/chains";
import { cn } from "@/lib/utils";
import SoundManager from "@/lib/SoundManager";
import { HydratedGame, HydratedUser } from "@/state/types";

import { leaveGameAction } from "@/actions/game";
import { notify } from "@/components/ui/Toaster";
import { useUserPreferences } from "@/components/providers/userPreference";

interface GameClientImplProps {
  game: HydratedGame;
  userInfo: HydratedUser;
}

export function GameClientImpl({ game, userInfo }: GameClientImplProps) {
  const router = useRouter();
  const user = useMiniUser();
  const { prefs } = useUserPreferences();

  const [isLeaveGameDrawerOpen, setIsLeaveGameDrawerOpen] = useState(false);

  const { status, roundedBalance } = useGetTokenBalance(
    user.wallet as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      decimals: 6,
      name: "USDC",
      symbol: "USDC",
      image: "/images/tokens/usdc.png",
      chainId: base.id,
    }
  );

  // ───────────────────────── EFFECTS ─────────────────────────
  // Init sound on first interaction
  useEffect(() => {
    if (!prefs.soundEnabled) return;

    const handleInteraction = () => {
      SoundManager.init().catch(() => {
        console.error("Failed to initialize sound");
      });
    };

    window.addEventListener("pointerdown", handleInteraction, { once: true });
    window.addEventListener("keydown", handleInteraction, { once: true });

    return () => {
      window.removeEventListener("pointerdown", handleInteraction);
      window.removeEventListener("keydown", handleInteraction);
    };
  }, [prefs.soundEnabled]);

  // Ensure no leftover sounds leak when leaving game screen
  useEffect(() => {
    return () => {
      SoundManager.stopAll();
    };
  }, []);

  const leaveGame = useCallback(async () => {
    try {
      await leaveGameAction({ fid: userInfo.fid, gameId: game.id });
      setIsLeaveGameDrawerOpen(false);
      router.refresh();
    } catch {
      notify.error("Failed to leave game:");
      setIsLeaveGameDrawerOpen(false);
    }
  }, [userInfo.fid, game.id, router]);

  // ───────────────────────── VIEW LOGIC ─────────────────────────
  const view = (() => {
    // Only minimum local checks here. Main access checks are now server-side.
    if (!game || !userInfo) return null;

    const now = new Date();
    const start = new Date(game.startTime);
    const end = new Date(game.endTime);

    const isParticipant =
      userInfo.gameParticipants?.some((p) => p.gameId === game.id) ?? false;

    const isWaiting = now.getTime() < start.getTime();
    const isActive = now >= start && now <= end;

    if (isWaiting) {
      // Pass startTime to WaitingView. It will handle its own countdown.
      // The onComplete logic (router.refresh()) will be inside WaitingView.
      return (
        <WaitingView
          game={game}
          startTime={game.startTime}
          userInfo={userInfo}
        />
      );
    }

    if (!isParticipant) {
      return <JoinGameView game={game} userInfo={userInfo} friends={[]} />;
    }

    if (isActive) {
      // Pass the fully loaded data to QuestionView
      return <QuestionView game={game} userInfo={userInfo} />;
    }

    // Fallback if game is not active (e.g., time calculations are off)
    // Pass startTime to WaitingView
    return (
      <WaitingView game={game} startTime={game.startTime} userInfo={userInfo} />
    );
  })();

  // ───────────────────────── RENDER ─────────────────────────
  return (
    <div className="w-full min-h-[100dvh] flex-1 overflow-y-auto">
      <header
        className={cn(
          "sticky top-0 z-40 px-4 flex items-center justify-between border-b border-border backdrop-blur-sm"
        )}
      >
        <LogoIcon />
        <div className="flex items-center gap-2">
          {userInfo.gameParticipants.length > 0 ? (
            <button
              onClick={() => setIsLeaveGameDrawerOpen(true)}
              className="flex items-center gap-1.5 bg-white/10 rounded-full px-3 py-1.5 text-xs text-foreground hover:bg-white/20 transition-colors"
            >
              <LeaveGameIcon className="w-4 h-4" />
              <span>leave game</span>
            </button>
          ) : (
            <div className="flex items-center gap-1.5  rounded-full px-3 py-1.5 border border-white/10">
              <WalletIcon className="w-4 h-4 text-foreground" />
              <span className="text-xs text-foreground">
                {status === "pending"
                  ? "Loading..."
                  : `$${roundedBalance ?? "---"}`}
              </span>
            </div>
          )}
        </div>
      </header>

      {/* The 'view' variable will be null while the redirect effect is firing */}
      {view}

      <LeaveGameDrawer
        open={isLeaveGameDrawerOpen}
        onClose={() => setIsLeaveGameDrawerOpen(false)}
        onConfirmLeave={leaveGame}
      />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/[gameId]/loading.tsx ---
import { SplashScreen } from "@/components/ui/SplashScreen";

export default function Loading() {
  return <SplashScreen />;
}

--- File: ./src/app/(authenticated)/game/[gameId]/page.tsx ---
import { GameClientImpl } from "./gameClientImpl";
import React from "react";
import { fetchGameById, fetchUserWithGameDetailsAndReferral } from "@/lib/data";
import { getCurrentUserFid } from "@/lib/auth";
import { notFound, redirect } from "next/navigation";

export default async function GamePage(props: {
  params: Promise<{ gameId: string }>;
}) {
  const { gameId } = await props.params;

  const userFid = await getCurrentUserFid();
  if (!userFid) {
    return null;
  }
  const numericGameId = Number(gameId);
  const game = await fetchGameById(numericGameId);

  if (!game) {
    // No such game
    return notFound();
  }

  const userInfo = await fetchUserWithGameDetailsAndReferral(
    userFid,
    numericGameId
  );

  if (!userInfo) {
    // No such user game details found
    return notFound();
  }

  // Server-side "game over" check:
  const now = new Date();
  const end = new Date(game.endTime);

  const isGameOver =
    now > end ||
    (userInfo.answers?.length ?? 0) === (game.questions?.length ?? 0);

  if (isGameOver) {
    // Redirect to score page if the game is over for this user
    redirect(`/game/${game.id}/score`);
  }

  // Check for user ticket: participants are only allowed in with a ticket
  const userTicket = userInfo.tickets?.find((t) => t.gameId === game.id);
  if (!userTicket) {
    // Redirect to the lobby if user does not have a ticket for the game
    redirect("/lobby");
  }

  // If all checks pass, render the client game component
  return <GameClientImpl game={game} userInfo={userInfo} />;
}

export const dynamic = "force-dynamic";

--- File: ./src/app/(authenticated)/game/[gameId]/not-found.tsx ---
import Link from "next/link";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import LogoIcon from "@/components/logo/LogoIcon";

export default function NotFound() {
  return (
    <div className="flex flex-col items-center justify-center min-h-[80dvh] text-center px-4">
      <LogoIcon className="w-12 h-12 mb-4" />
      <h1 className="text-2xl font-bold text-foreground mb-2">
        Game Not Found
      </h1>
      <p className="text-md text-muted-foreground mb-8">
        Sorry, we couldn&apos;t find that game.
        <br />
        It may have ended, been cancelled, or does not exist.
      </p>
      <div className="flex flex-col sm:flex-row gap-4">
        <FancyBorderButton>
          <Link href="/lobby">Back to Lobby</Link>
        </FancyBorderButton>
        <FancyBorderButton>
          <Link href="/">Home</Link>
        </FancyBorderButton>
        <FancyBorderButton>
          <Link href="/waitlist">Join the Waitlist</Link>
        </FancyBorderButton>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/invite/_components/InvitePageClient.tsx ---
"use client";

import LogoIcon from "@/components/logo/LogoIcon";
import React, { useEffect, useState, useRef, useCallback } from "react";
import Image from "next/image";
import { PixelInput } from "@/components/inputs/PixelInput";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { PixelButton } from "@/components/buttons/PixelButton";
import { validateReferralAction } from "@/actions/invite";
import { UserWithInviteData } from "../page";
import { useRouter } from "next/navigation";

export default function InvitePageClient({
  userWithInviteData,
}: {
  userWithInviteData: UserWithInviteData;
}) {
  const router = useRouter();
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const [status, setStatus] = useState<
    "idle" | "validating" | "success" | "failed"
  >("idle");
  const [inputCode, setInputCode] = useState(
    userWithInviteData.referrals[0]?.code || ""
  );
  const [error, setError] = useState<string | null>(null);

  const runValidation = useCallback(
    async (codeToValidate: string) => {
      if (!userWithInviteData.fid) return;

      const formData = new FormData();
      formData.append("code", codeToValidate);
      formData.append("fid", String(userWithInviteData.fid));

      const result = await validateReferralAction(null, formData);

      if (result.valid) {
        setError(null);
        console.log("Referral validated");
      } else {
        setError(result.error);
      }
    },
    [userWithInviteData.fid]
  );

  useEffect(() => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    const trimmedCode = inputCode.trim().toUpperCase();

    if (trimmedCode.length === 0) {
      setError(null);
      return;
    }
    if (trimmedCode.length !== 6) {
      setError(null);
      return;
    }

    debounceTimerRef.current = setTimeout(() => {
      runValidation(trimmedCode);
    }, 500);

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [inputCode, runValidation]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const trimmedCode = inputCode.trim().toUpperCase();

    if (trimmedCode.length !== 6) {
      setError("Code must be 6 characters.");
      setStatus("failed");
      return;
    }
    if (!userWithInviteData.fid) {
      setError("User not identified.");
      setStatus("failed");
      return;
    }

    await runValidation(trimmedCode);

    const formData = new FormData();
    formData.append("code", trimmedCode);
    formData.append("fid", String(userWithInviteData.fid));
    const result = await validateReferralAction(null, formData);

    if (result.valid) {
      setStatus("success");
    }
  };

  return (
    // Outer background container fills all available space and is absolutely positioned
    <div className="relative min-h-screen flex flex-col w-full">
      {/* BG layer (fills parent) */}
      <div
        className="absolute inset-0 w-full h-full app-background-gradient pointer-events-none z-0"
        aria-hidden="true"
      />

      {/* Main invite contents positioned with max width and centered */}
      <div className="z-10 relative flex flex-col flex-1 w-full min-h-screen">
        <div
          className={
            "p-4 flex items-center justify-center border-y border-border bg-transparent"
          }
        >
          <LogoIcon />
        </div>

        <div className="flex flex-col items-center justify-center flex-1 py-16 px-4">
          <div className="w-full max-w-md mx-auto">
            <div className="mb-6 flex justify-center">
              <Image
                src="/images/illustrations/invite-key.png"
                alt="Invite Key"
                width={105}
                height={105}
                style={{ imageRendering: "pixelated" }}
              />
            </div>
            <h2 className="mb-8 text-center text-3xl leading-tight font-bold uppercase tracking-wider">
              <span className="block">ENTER YOUR</span>
              <span className="block">INVITE CODE</span>
            </h2>
            <form
              onSubmit={handleSubmit}
              className="w-full  flex flex-col items-center gap-6"
              autoComplete="off"
            >
              <label htmlFor="inviteCodeInput" className="sr-only">
                Invite Code
              </label>
              <PixelInput
                id="inviteCodeInput"
                type="text"
                value={inputCode}
                onChange={(e) => setInputCode(e.target.value)}
                placeholder="INVITE CODE"
                maxLength={6}
                autoFocus
                style={{ textTransform: "uppercase" }}
              />
              <FancyBorderButton
                disabled={
                  inputCode.trim().length !== 6 || status === "validating"
                }
              >
                {status === "validating" ? "CHECKING..." : "GET IN"}
              </FancyBorderButton>
              {status === "validating" && (
                <p
                  className="text-xs mt-2 text-[#a0a0a0]"
                  style={{
                    fontFamily: "'Press Start 2P', 'Geist Mono', monospace",
                    letterSpacing: "0.04em",
                  }}
                >
                  Validating...
                </p>
              )}
              {status === "failed" && error && (
                <PixelButton
                  className="flex items-center gap-2 font-body"
                  backgroundColor="#FF5252"
                  borderColor="#FF5252"
                  textColor="#FFFFFF"
                  type="button"
                >
                  <Image
                    src="/images/icons/icon-invalid.png"
                    alt="Invalid Invite Code"
                    width={20}
                    height={20}
                  />
                  <span>{error || "Invalid"}</span>
                </PixelButton>
              )}
              {status === "success" && (
                <PixelButton
                  className="flex items-center gap-2 font-body"
                  backgroundColor="#14B985"
                  borderColor="#14B985"
                  textColor="#FFFFFF"
                  onClick={() => router.push("/lobby")}
                  type="button"
                >
                  <Image
                    src="/images/icons/icon-valid.png"
                    alt="Valid Invite Code"
                    width={20}
                    height={20}
                  />
                  <span>Valid</span>
                </PixelButton>
              )}
            </form>
          </div>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/invite/page.tsx ---
import InvitePageClient from "./_components/InvitePageClient";
import { prisma } from "@/lib/db";
import { notFound } from "next/navigation";
import { Prisma } from "@prisma/client";
import { getCurrentUserFid } from "@/lib/auth";

export async function fetchUserWithInviteData(): Promise<UserWithInviteData | null> {
  const userFid = await getCurrentUserFid();

  if (!userFid) {
    return notFound();
  }

  const userWithInviteData = await prisma.user.findUnique({
    where: { fid: Number(userFid) },
    select: {
      fid: true,
      name: true,
      imageUrl: true,
      referrals: {
        take: 1,
        select: {
          code: true,
          inviter: {
            select: { fid: true, name: true, imageUrl: true },
          },
        },
      },
    },
  });
  if (!userWithInviteData) return null;

  return userWithInviteData;
}

export default async function InvitePage() {
  const userWithInviteData = await fetchUserWithInviteData();
  if (!userWithInviteData) {
    notFound();
  }

  return <InvitePageClient userWithInviteData={userWithInviteData} />;
}

export type UserWithInviteData = Prisma.UserGetPayload<{
  select: {
    fid: true;
    name: true;
    imageUrl: true;
    referrals: {
      take: 1;
      select: {
        code: true;
        inviter: {
          select: { fid: true; name: true; imageUrl: true };
        };
      };
    };
  };
}>;

--- File: ./src/app/(authenticated)/profile/_components/InviteFriendsDrawer.tsx ---
"use client";

import * as React from "react";
import { createPortal } from "react-dom";
import Image from "next/image";
import { CopyIcon, InviteFriendsIcon } from "@/components/icons";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { motion, AnimatePresence } from "framer-motion";
import { cn } from "@/lib/utils";
import { notify } from "@/components/ui/Toaster";

interface InviteFriendsDrawerProps {
  open: boolean;
  code: string;

  onClose: () => void;
}

export function InviteFriendsDrawer({
  open,
  code,
  onClose,
}: InviteFriendsDrawerProps) {
  const [mounted, setMounted] = React.useState(false);
  const drawerRef = React.useRef<HTMLDivElement | null>(null);

  const startY = React.useRef<number | null>(null);
  const [dragY, setDragY] = React.useState(0);
  const isDragging = startY.current !== null;

  React.useEffect(() => setMounted(true), []);

  React.useEffect(() => {
    if (!open) {
      document.documentElement.style.overflow = "";
      return;
    }
    document.documentElement.style.overflow = "hidden";
    return () => {
      document.documentElement.style.overflow = "";
    };
  }, [open]);

  React.useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  const onPointerDown = React.useCallback((e: React.PointerEvent) => {
    startY.current = e.clientY;
    setDragY(0);
    drawerRef.current?.setPointerCapture(e.pointerId);
  }, []);

  const onPointerMove = React.useCallback((e: React.PointerEvent) => {
    if (startY.current == null) return;
    const dy = Math.max(0, e.clientY - startY.current);
    setDragY(dy);
  }, []);

  const onPointerUp = React.useCallback(
    (e: React.PointerEvent) => {
      if (startY.current == null) return;

      drawerRef.current?.releasePointerCapture(e.pointerId);

      const dy = dragY;
      startY.current = null;
      setDragY(0);
      if (dy > 140) onClose();
    },
    [dragY, onClose]
  );

  const copyCode = React.useCallback(async () => {
    if (!navigator.clipboard) {
      notify.error("Clipboard not available.");
      return;
    }
    try {
      await navigator.clipboard.writeText(code);
      notify.success("Code copied!");
    } catch (err) {
      console.error("Failed to copy code:", err);
      notify.error("Couldn't copy code.");
    }
  }, [code]);

  const shareInvite = React.useCallback(async () => {
    const text = `Join me on Waffles — use my invite code: ${code}`;
    if (navigator.share) {
      try {
        await navigator.share({ title: "Waffle Invite", text });
      } catch (err) {
        if ((err as DOMException)?.name !== "AbortError") {
          console.error("Failed to share:", err);
          notify.error("Could not share invite.");
        }
      }
    } else {
      await copyCode();
    }
  }, [code, copyCode]);

  if (!mounted) return null;

  return createPortal(
    <AnimatePresence>
      {open && (
        <>
          <motion.div
            key="backdrop"
            aria-hidden
            className="fixed inset-0 z-[80] bg-black/60 backdrop-blur-sm"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            transition={{ duration: 0.2 }}
            onClick={onClose}
          />

          <motion.section
            key="drawer"
            ref={drawerRef}
            id="invite-friends-drawer"
            role="dialog"
            aria-modal="true"
            aria-label="Invite friends"
            onPointerDown={onPointerDown}
            onPointerMove={onPointerMove}
            onPointerUp={onPointerUp}
            className={cn(
              "fixed inset-x-0 bottom-0 z-[81] isolate",
              "mx-auto w-full max-w-screen-sm",
              "rounded-t-[1.25rem] overflow-hidden",
              "border-t border-white/5",
              "bg-gradient-to-b from-[#1E1E1E] to-black",
              "shadow-[0_-20px_60px_rgba(0,0,0,.6)]",
              "transition-[transform,opacity] duration-300 ease-[cubic-bezier(.2,.8,.2,1)]"
            )}
            style={
              isDragging
                ? {
                    transform: `translateY(${dragY}px)`,
                    opacity: Math.max(0.6, 1 - dragY / 800),
                    transition: "none",
                  }
                : undefined
            }
            initial={{ y: "100%", opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            exit={{ y: "100%", opacity: 0 }}
            transition={{ type: "spring", stiffness: 280, damping: 30 }}
            onClick={(e) => e.stopPropagation()}
          >
            <div
              className="relative border-b border-white/5 bg-[#191919] px-4 pb-3 pt-6 cursor-grab active:cursor-grabbing"
              data-drag-handle
            >
              <div
                className="absolute left-1/2 top-3 h-1 w-9 -translate-x-1/2 rounded-full bg-white/40"
                aria-hidden
              />
              <div className="mx-auto flex w-full max-w-xs items-center justify-center gap-2">
                <InviteFriendsIcon className="h-6 w-6 text-waffle-yellow" />{" "}
                <h2
                  className="font-edit-undo text-white leading-[1.15]"
                  style={{ fontSize: "clamp(1.05rem, 3.7vw, 1.25rem)" }}
                >
                  INVITE FRIENDS
                </h2>
              </div>
            </div>
            <div className="mx-auto flex w-full max-w-xs flex-col gap-3.5 px-4 py-4">
              <div className="rounded-2xl border border-white/10 bg-[linear-gradient(90deg,rgba(255,255,255,0)_0%,rgba(255,201,49,.12)_100%)] flex flex-col items-center justify-center gap-3 px-3 py-12 sm:py-14">
                <Image
                  src="/images/icons/gift.svg"
                  alt=""
                  width={96}
                  height={96}
                  className="w-24 h-24 sm:w-28 sm:h-28"
                  priority
                />
                <div className="mt-1.5 flex w-full flex-col items-center">
                  <p
                    className="font-display text-muted tracking-[-0.03em]"
                    style={{
                      fontSize: "clamp(0.95rem, 3vw, 1rem)",
                      lineHeight: "130%",
                    }}
                  >
                    Your code is
                  </p>
                  <p
                    className="font-edit-undo text-white select-all"
                    style={{
                      fontSize: "clamp(1.9rem, 6vw, 2.375rem)",
                      lineHeight: "1.3",
                    }}
                  >
                    {code || "------"}
                  </p>
                </div>
              </div>
              <FancyBorderButton
                onClick={shareInvite}
                className="border-waffle-gold"
                disabled={!code || code === "------"}
              >
                SHARE INVITE
              </FancyBorderButton>
              <button
                onClick={copyCode}
                disabled={!code || code === "------"}
                className="inline-flex w-full items-center justify-center gap-2 rounded-xl py-2.5 transition hover:bg-white/5 active:bg-white/10 disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <CopyIcon />
                <span
                  className="font-edit-undo text-[#00CFF2] tracking-[-0.02em]"
                  style={{
                    fontSize: "clamp(1rem, 3.2vw, 1.125rem)",
                    lineHeight: "1.15",
                  }}
                >
                  COPY CODE
                </span>
              </button>
            </div>
          </motion.section>
        </>
      )}
    </AnimatePresence>,
    document.body
  );
}

--- File: ./src/app/(authenticated)/profile/_components/profilePageClient.tsx ---
"use client";

import {
  ArrowRightIcon,
  InviteFriendsIcon,
  UploadIcon,
  WalletIcon,
} from "@/components/icons";

import { GameHistoryEntry } from "@/state/types";
import { GameHistory } from "./GameHistory";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { ProfileCard } from "./ProfileCard";
import { Stats } from "./Stats";
import { InviteFriendsDrawer } from "./InviteFriendsDrawer";
import { useState } from "react";
import { cn } from "@/lib/utils";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { base } from "wagmi/chains";
import { notify } from "@/components/ui/Toaster";

interface ProfileData {
  fid: number | null;
  name: string | null;
  wallet: string | null;
  imageUrl: string | null;
}
interface ProfileStatsData {
  totalGames: number;
  wins: number;
  winRate: number;
  totalWon: number;
  highestScore: number;
  avgScore: number;
  currentStreak: number;
  bestRank: number | string;
}

interface ProfilePageClientProps {
  profileData: ProfileData | null;
  stats: ProfileStatsData | null;
  gameHistory: GameHistoryEntry[] | null;
  streak: number;
  username: string | null;
  inviteCode: string | null;
  referralStatusData: number | null;
}

export default function ProfilePageClient({
  profileData,
  stats,
  gameHistory,
  streak = 0,
  username,
  inviteCode,
  referralStatusData,
}: ProfilePageClientProps) {
  const [inviteOpen, setInviteOpen] = useState(false);

  // --- Wallet Balance ---
  const userWallet = profileData?.wallet;
  const { status, roundedBalance } = useGetTokenBalance(
    userWallet as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      chainId: base.id,
      decimals: 6,
      image: "/images/tokens/usdc.png",
      name: "USDC",
      symbol: "USDC",
    }
  );

  // Defensive fallback if main data missing (should not occur in production)
  if (!profileData) {
    return (
      <div className="p-4 text-center text-muted">
        User not identified. Cannot load profile.
      </div>
    );
  }

  const showReferralButton =
    referralStatusData !== null && typeof referralStatusData === "number";
  const safeUsername = username || profileData.name || "Player";

  return (
    <div className="flex-1 overflow-y-auto ">
      <header className="sticky top-0 z-10 w-full border-b border-white/20 px-4 py-3 app-background/80 backdrop-blur-sm">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5 border border-white/10">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center tabular-nums"
                style={{ fontSize: "clamp(0.9rem, 1.8vw, .95rem)" }}
              >
                {status === "pending" ? "Loading..." : `$${roundedBalance}`}{" "}
              </span>
            </div>
          </div>
        </div>
      </header>
      <main
        className={cn(
          "mx-auto w-full max-w-screen-sm px-4",
          "pb-[calc(env(safe-area-inset-bottom)+84px)]",
          "flex flex-col gap-6 sm:gap-8 pt-4 flex-1"
        )}
      >
        <div className="flex items-center justify-between">
          <div className="h-7 w-7 shrink-0 opacity-0" aria-hidden="true">
            <UploadIcon className="h-3.5 w-3.5" />
          </div>
          <h1
            className="font-edit-undo font-normal tracking-tight text-white leading-[0.92] text-center select-none"
            style={{
              fontSize: "clamp(1.2rem, 4vw, 1.375rem)",
              letterSpacing: "-0.03em",
            }}
          >
            PROFILE
          </h1>
          <button
            onClick={() => setInviteOpen(true)}
            aria-label="Invite Friends"
            className="box-border flex h-8 w-8 shrink-0 items-center justify-center rounded-full bg-white/15 p-2 transition-opacity hover:opacity-80"
            disabled={!showReferralButton}
          >
            <InviteFriendsIcon className="h-[18px] w-[18px]" />
          </button>
        </div>

        <ProfileCard
          username={safeUsername}
          streak={streak ?? stats?.currentStreak ?? 0}
          avatarUrl={profileData.imageUrl || "/images/avatars/a.png"}
          onUpload={() => {
            notify.info("Avatar upload coming soon!");
          }}
        />

        <button
          onClick={() => setInviteOpen(true)}
          disabled={!showReferralButton}
          className={cn(
            "flex flex-row items-center justify-between w-full max-w-screen-sm min-h-[64px] h-[74px] mx-auto px-3 sm:px-4 box-border gap-3 rounded-[16px] border border-white/40 transition-transform hover:scale-[1.02]",
            "bg-[#FFC931] bg-blend-overlay",
            "[background:linear-gradient(189.66deg,rgba(0,0,0,0)_-6.71%,rgba(0,0,0,0.8)_92.73%),_#FFC931]",
            "disabled:opacity-60 disabled:cursor-not-allowed disabled:hover:scale-100"
          )}
          aria-haspopup="dialog"
          aria-controls="invite-friends-drawer"
        >
          <span
            className="font-normal text-[clamp(1.08rem,2.7vw,1.31rem)] leading-[1.3] text-foreground tracking-tight select-none px-2"
            style={{ letterSpacing: "-0.03em", fontWeight: 400 }}
          >
            INVITE FRIENDS
          </span>
          <div className="flex items-center justify-center w-[34px] h-[34px] rounded-full bg-white/15 flex-shrink-0 p-0.5 ml-2">
            <ArrowRightIcon className="w-[18px] h-[18px]" />
          </div>
        </button>

        <div className="mt-2">
          <Stats
            stats={{
              totalGames: stats?.totalGames ?? 0,
              wins: stats?.wins ?? 0,
              winRate: stats?.winRate ?? 0,
              totalWon: stats?.totalWon ?? 0,
              highestScore: stats?.highestScore ?? 0,
              avgScore: stats?.avgScore ?? 0,
              currentStreak: stats?.currentStreak ?? 0,
              bestRank: Number(stats?.bestRank ?? null),
            }}
          />
        </div>

        <div className="mt-4">
          <GameHistory gameHistory={gameHistory ?? []} />
        </div>
      </main>
      <BottomNav />
      <InviteFriendsDrawer
        open={inviteOpen}
        code={inviteCode ?? "------"}
        onClose={() => setInviteOpen(false)}
      />
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/_components/GameHistory.tsx ---
"use client";

import { WaffleIcon, ZapIcon } from "@/components/icons";

import Link from "next/link";
import React from "react";
import { cn } from "@/lib/utils";
import { GameHistoryEntry } from "@/state/types";

interface GameHistoryProps {
  gameHistory: GameHistoryEntry[];
}

interface GameHistoryItemProps {
  game: GameHistoryEntry;
}

export const GameHistoryItem = ({ game }: GameHistoryItemProps) => {
  const formattedWinnings = `$${game.winnings.toLocaleString(undefined, {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  })}`;

  return (
    <div
      className={cn(
        "flex items-center justify-between",
        "noise rounded-2xl border border-white/20",
        "p-3 sm:p-4"
      )}
    >
      <div className="flex min-w-0 items-center gap-2 sm:gap-3">
        <div className="size-10 grid shrink-0 place-items-center rounded-full bg-white/10">
          <WaffleIcon aria-hidden className="text-waffle-yellow" />
        </div>
        <div className="min-w-0 flex flex-col gap-1">
          <p
            className="truncate font-body"
            title={game.name}
            style={{
              fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)",
              lineHeight: "100%",
              letterSpacing: "-0.03em",
            }}
          >
            {game.name}
          </p>
          <div className="mt-1 flex items-center gap-1">
            <span className="text-waffle-yellow" aria-hidden>
              <ZapIcon />
            </span>
            <span
              className="font-display font-medium text-white/90 tracking-[-0.03em]"
              style={{
                fontSize: "clamp(0.75rem, 1.1vw, 0.875rem)",
                lineHeight: "1rem",
              }}
            >
              {game.score.toLocaleString()}
            </span>
          </div>
        </div>
      </div>

      <p
        className={cn(
          "ml-3 shrink-0 whitespace-nowrap font-display font-medium",
          game.winningsColor === "green" ? "text-success" : "text-muted"
        )}
        style={{
          fontSize: "clamp(1rem, 1.8vw, 1rem)",
          lineHeight: "1.2rem",
          letterSpacing: "-0.03em",
        }}
      >
        {formattedWinnings}
      </p>
    </div>
  );
};

export function GameHistory({ gameHistory }: GameHistoryProps) {
  const displayedGames = gameHistory.slice(0, 2);

  return (
    <section aria-labelledby="past-games-heading" className="w-full">
      <div className="mb-3.5 flex items-center justify-between font-semibold">
        <h2
          id="past-games-heading"
          className="font-display font-medium text-muted tracking-[-0.03em]"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          Past games
        </h2>
        <Link
          href="/profile/history"
          className="font-display font-medium text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>
      {displayedGames.length > 0 ? (
        <ul className="space-y-2">
          {displayedGames.map((game) => (
            <li key={game.id}>
              <GameHistoryItem game={game} />
            </li>
          ))}
        </ul>
      ) : (
        <div className="panel rounded-2xl p-4 text-center text-sm text-muted">
          No past games played yet.
        </div>
      )}
    </section>
  );
}

--- File: ./src/app/(authenticated)/profile/_components/ProfileCard.tsx ---
"use client"; // Required for onClick handler

import Image from "next/image"; //
import { UploadIcon } from "@/components/icons"; //
import { cn } from "@/lib/utils"; // Import cn utility

// Define the component's props
interface ProfileCardProps {
  username: string; // User's display name
  streak: number; // Current win streak
  /** URL for the user's avatar image. Also used for the blurred background. */
  avatarUrl: string; //
  /** Optional callback function triggered when the upload button is clicked. */
  onUpload?: () => void; //
}

/**
 * Renders a card displaying the user's profile information, including avatar,
 * username, and current streak, with a blurred background effect.
 * Includes an optional button to trigger an upload action.
 */
export function ProfileCard({
  //
  username, //
  streak, //
  avatarUrl, //
  onUpload, //
}: ProfileCardProps) {
  return (
    <section
      className={cn(
        // Base styles merged with cn
        "relative isolate overflow-hidden rounded-2xl border border-white/10", // Positioning, overflow, styling
        "px-3 py-3 sm:px-4 sm:py-3.5" // Responsive padding
      )}
      aria-label={`${username} profile summary`} // Accessibility label
    >
      {/* Blurred Background Image */}
      <div aria-hidden className="absolute inset-0 -z-10">
        {" "}
        {/* Decorative background */}
        <Image
          src={avatarUrl || "/images/avatars/a.png"} // Use provided URL or fallback
          alt="" // Background is decorative, alt text is empty
          fill // Cover the container
          quality={50} // Lower quality for blurred background
          className="object-cover object-center opacity-70 blur-lg scale-110" // Styling - adjusted blur/scale
          priority // Load eagerly as it's a primary visual element
          // Provide rough sizes hint for optimization
          sizes="(max-width: 640px) 100vw, 640px"
        />
        {/* Subtle Vignette Overlay */}
        <div className="absolute inset-0 bg-gradient-to-r from-black/20 via-transparent to-black/30" />{" "}
        {/* Adjusted gradient */}
      </div>

      {/* Content Row: Upload Button • Center Block • Spacer */}
      <div className="flex items-start justify-between gap-2">
        {" "}
        {/* */}
        {/* Upload Button (Left) */}
        <button
          onClick={onUpload} // Attach handler
          aria-label="Upload new avatar" // More specific label
          // Disable button visually and functionally if no handler is provided
          disabled={!onUpload}
          className={cn(
            //
            "grid size-9 shrink-0 place-items-center rounded-full bg-white/15", // Styling
            "transition-opacity hover:opacity-80 focus:outline-none focus:ring-2 focus:ring-white/30", // Interaction states
            !onUpload && "opacity-30 cursor-not-allowed pointer-events-none" // Disabled state styles
          )}
        >
          <UploadIcon className="h-[18px] w-[18px] text-white" /> {/* */}
        </button>
        {/* Center Block: Avatar, Name, Streak */}
        <div className="flex min-w-0 flex-col items-center gap-3">
          {" "}
          {/* */}
          {/* Avatar + Name */}
          <div className="flex items-center gap-2">
            {" "}
            {/* */}
            <Image
              src={avatarUrl || "/images/avatars/a.png"} // Use provided URL or fallback
              alt={`${username}'s avatar`} // Use username in alt text
              width={36} // Fixed size
              height={36} // Fixed size
              className="h-9 w-9 rounded-full bg-white/10 ring-2 ring-black/20 object-cover" // Added object-cover, adjusted bg
              priority // Load avatar eagerly
            />
            {/* Username */}
            <span
              className="font-body text-white tracking-tight" //
              style={{ fontSize: "clamp(1.05rem,2.6vw,1.25rem)" }} // Responsive font size
            >
              {username || "Player"} {/* Display username or fallback */}
            </span>{" "}
            {/* */}
          </div>
          {/* Streak Block */}
          <div className="flex flex-col items-center gap-1">
            {" "}
            {/* */}
            {/* "Streak" Label */}
            <span
              className="font-display text-white/95" //
              style={{
                fontSize: "clamp(.85rem,2vw,1rem)", // Responsive font size
                letterSpacing: "-0.03em", //
              }}
            >
              Streak {/* */}
            </span>
            {/* Flame Icon + Streak Number */}
            <div className="flex items-center gap-2">
              {" "}
              {/* */}
              <Image
                src="/images/icons/streak-flame.svg" // Flame icon
                alt="" // Decorative
                width={20} //
                height={36} //
                className="h-9 w-5 object-contain" // Sizing
              />{" "}
              {/* */}
              <span
                className="font-body text-foreground leading-none tabular-nums" // Added tabular-nums
                style={{ fontSize: "clamp(1.75rem,4.6vw,2.25rem)" }} // Responsive font size
              >
                {streak ?? 0} {/* Display streak or 0 */}
              </span>{" "}
              {/* */}
            </div>{" "}
            {/* */}
          </div>
        </div>
        {/* Right Spacer (for centering balance) */}
        <div
          className="pointer-events-none size-9 shrink-0 opacity-0"
          aria-hidden
        >
          {" "}
          {/* */}
          <UploadIcon className="h-[18px] w-[18px]" /> {/* Mimic button size */}
        </div>
      </div>
    </section>
  );
} //

--- File: ./src/app/(authenticated)/profile/_components/Stats.tsx ---
"use client";

import { GamePadIcon, WinningsIcon, WinsIcon } from "@/components/icons";
import Link from "next/link";
import React from "react";
import { cn } from "@/lib/utils";
import { ProfileStatsData } from "@/state/types";

interface StatCardProps {
  icon: React.ReactNode;
  label: string;
  value: number | string;
}

interface StatsProps {
  stats: ProfileStatsData | null;
}

export const StatCard = ({ icon, label, value }: StatCardProps) => (
  <div
    className={cn(
      // Base styles merged with cn
      "flex flex-1 flex-col justify-between", // Flex layout, takes available space
      "noise rounded-2xl border border-white/20", // Background, border, radius
      "p-3 sm:p-4 gap-4 sm:gap-5", // Responsive padding and gap - adjusted gap
      "min-h-[3.75rem] sm:min-h-[4.25rem]" // Minimum height for consistency
    )}
  >
    {/* Label */}
    <p
      className="font-display font-medium text-muted tracking-[-0.03em]" //
      style={{
        fontSize: "clamp(0.8125rem, 1.3vw, 0.875rem)", // Responsive font size
        lineHeight: "130%", //
      }}
    >
      {label} {/* */}
    </p>

    {/* Icon + Value */}
    <div className="flex items-center gap-1 sm:gap-1.5">
      {" "}
      {/* Adjusted gap */}
      {/* Icon Container */}
      <span className="shrink-0 text-waffle-yellow" aria-hidden>
        {" "}
        {/* */}
        {icon} {/* */}
      </span>
      {/* Value */}
      <p
        className="truncate font-body leading-none" // Use font-body, add truncate
        style={{
          fontSize: "clamp(1.1rem, 2.1vw, 1.2rem)", // Slightly adjusted responsive font size
          lineHeight: "100%", //
          letterSpacing: "-0.03em", //
        }}
        // Add title attribute if value might be truncated (unlikely here)
        // title={typeof value === 'number' ? value.toLocaleString() : value}
      >
        {/* Format number values with commas */}
        {typeof value === "number" ? value.toLocaleString() : value}
      </p>{" "}
      {/* */}
    </div>
  </div>
);

export function Stats({ stats }: StatsProps) {
  const formattedWinnings = `$${(stats?.totalWon ?? 0).toLocaleString(
    undefined,
    {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }
  )}`;

  return (
    <section aria-labelledby="stats-heading" className="w-full">
      <div className="mb-3.5 flex items-center justify-between font-semibold">
        <h2
          id="stats-heading"
          className="font-display font-medium text-muted tracking-[-0.03em]"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          Stats
        </h2>
        <Link
          href="/profile/stats"
          className="font-display font-medium text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>
      <div className="grid grid-cols-3 gap-2">
        <StatCard
          icon={<GamePadIcon />}
          label="Games"
          value={stats?.totalGames ?? 0}
        />{" "}
        <StatCard icon={<WinsIcon />} label="Wins" value={stats?.wins ?? 0} />{" "}
        <StatCard
          icon={<WinningsIcon />}
          label="Winnings"
          value={formattedWinnings}
        />
      </div>
    </section>
  );
}

--- File: ./src/app/(authenticated)/profile/history/page.tsx ---
"use client"; // Required for hooks (useEffect, useSWR), Link, etc.

import Link from "next/link";
import useSWR from "swr"; // Import useSWR
import { GameHistoryEntry } from "@/state/types"; // Use type import
import { BottomNav } from "@/components/BottomNav";
import LogoIcon from "@/components/logo/LogoIcon";
import { ArrowLeftIcon, WalletIcon } from "@/components/icons";
import { GameHistoryItem } from "@/app/(authenticated)/profile/_components/GameHistory"; // Import the item component
import { useMiniUser } from "@/hooks/useMiniUser";
import { cn } from "@/lib/utils"; // Import cn
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet"; // For balance
import { env } from "@/lib/env"; // For env vars
import { base } from "wagmi/chains"; // For chain ID

// Basic fetcher for SWR
const fetcher = (url: string, fid: string | null) => {
  if (!fid) throw new Error("User FID not available for fetching history."); // Prevent fetch without FID
  return fetch(url, {
    headers: { "x-farcaster-id": fid }, // Pass FID in header
    cache: "no-store", // Ensure fresh data
  }).then((res) => {
    if (!res.ok) {
      throw new Error("Failed to fetch game history");
    }
    return res.json();
  });
};

/* ---------- Top bar (shared look) ---------- */
const TopBar = () => {
  const user = useMiniUser();
  // Fetch balance within the TopBar component
  const { status, roundedBalance } = useGetTokenBalance(
    user.wallet as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      chainId: base.id,
      decimals: 6,
      image: "/images/tokens/usdc.png",
      name: "USDC",
      symbol: "USDC",
    }
  );

  return (
    <header
      className={cn(
        // Use cn
        "sticky top-0 z-10 w-full", // Sticky positioning
        "border-b border-[color:var(--surface-stroke)]", // Border
        "bg-[color:var(--brand-ink-900)]/80 backdrop-blur-sm" // Semi-transparent background with blur
      )}
    >
      <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
        {" "}
        {/* Layout */}
        <LogoIcon /> {/* */}
        <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
          {" "}
          {/* Wallet display */}
          <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />{" "}
          {/* */}
          <span
            className="text-center text-[color:var(--text-primary)] font-display tabular-nums" // Added tabular-nums
            style={{
              fontSize: "clamp(.9rem, 1.8vw, .95rem)", // Adjusted size slightly
              lineHeight: "1.1", //
            }}
          >
            {status === "pending" ? "Loading..." : `$${roundedBalance}`}{" "}
            {/* Show balance or loading */}
          </span>{" "}
          {/* */}
        </div>
      </div>
    </header>
  );
};

/* ---------- Sub-page header ---------- */
const SubPageHeader = (
  { title }: { title: string } //
) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    {" "}
    {/* */}
    {/* Back Link */}
    <Link
      href="/profile" // Link back to main profile page
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80" // Styling
      aria-label="Back to profile" // Improved label
    >
      <ArrowLeftIcon /> {/* */}
    </Link>
    {/* Title */}
    <h1
      className="flex-grow text-center text-white font-body" // Styling
      style={{
        fontWeight: 400, //
        fontSize: "clamp(1.25rem, 4.5vw, 1.375rem)", // Responsive font size
        lineHeight: ".92", //
        letterSpacing: "-0.03em", //
      }}
    >
      {title} {/* Display title prop */}
    </h1>
    {/* Spacer to balance back button */}
    <div className="h-[34px] w-[34px]" aria-hidden="true" /> {/* */}
  </div>
);

/* ---------- Page Component ---------- */
export default function GameHistoryPage() {
  const { fid } = useMiniUser(); // Get current user's FID

  // Use SWR to fetch game history
  const {
    data: gameHistory, // Fetched data will be here (or undefined)
    error, // Error object if fetch fails
    isLoading, // Loading state
  } = useSWR<GameHistoryEntry[]>(
    fid ? "/api/profile/history" : null, // SWR key - URL, or null if no FID
    (url) => fetcher(url, fid ? String(fid) : null), // Pass fetcher function and FID
    {
      revalidateOnFocus: false, // History data likely doesn't change often on focus
      // Add other SWR options if needed (e.g., error retries)
    }
  );

  return (
    //
    <div
      className={cn(
        // Base styles
        "min-h-screen flex flex-col", // Full height, flex column
        "app-background noise", // Background gradient/noise
        "text-[color:var(--text-primary)]" // Default text color
      )}
    >
      <TopBar /> {/* Render shared top bar */}
      <SubPageHeader title="GAME HISTORY" /> {/* Render sub-page header */}
      <main
        className={cn(
          // Main content area styles
          "mx-auto w-full max-w-lg", // Centered, max width
          "px-4", // Horizontal padding
          "pb-[calc(env(safe-area-inset-bottom)+84px)]", // Bottom padding with safe area + nav height
          "mt-4 flex-1" // Top margin, allow grow
        )}
      >
        {/* Conditional Rendering based on SWR state */}
        {isLoading && (
          <div className="flex justify-center items-center pt-10 text-muted">
            Loading history...
          </div>
        )}

        {error && (
          <div className="panel rounded-2xl p-4 text-center text-sm text-danger">
            Error loading game history: {error.message}
          </div>
        )}

        {!isLoading && !error && gameHistory && gameHistory.length > 0 && (
          // List of Game History Items
          <ul className="flex flex-col gap-3.5 sm:gap-4">
            {" "}
            {/* Use ul, define gap */}
            {gameHistory.map(
              (
                g // Map through fetched history
              ) => (
                <li key={g.id}>
                  {" "}
                  {/* Use game id as key */}
                  <GameHistoryItem game={g} /> {/* Render item component */}
                </li>
              )
            )}
          </ul>
        )}

        {!isLoading && !error && (!gameHistory || gameHistory.length === 0) && (
          // Empty State
          <div className="panel rounded-2xl p-6 text-center text-sm text-muted mt-6">
            You haven&apos;t played any games yet.
          </div>
        )}
      </main>
      <BottomNav /> {/* Render bottom navigation */}
    </div>
  );
} //

--- File: ./src/app/(authenticated)/profile/page.tsx ---
import { Suspense } from "react";
import { prisma } from "@/lib/db";
import ProfilePageClient from "./_components/profilePageClient";
import { SplashScreen } from "@/components/ui/SplashScreen";
import { GameHistoryEntry } from "@/state/types";
import { getCurrentUserFid } from "@/lib/auth";

// ProfileData maps to client
async function getProfileData(fid: number | null) {
  if (!fid) return null;
  const user = await prisma.user.findUnique({
    where: { fid: fid },
    select: {
      fid: true,
      name: true,
      wallet: true,
      imageUrl: true,
    },
  });
  return user;
}

async function getProfileStatsData(userId: number | null) {
  if (!userId) return null;

  // Total games played (using GameParticipant)
  const totalGames = await prisma.gameParticipant.count({
    where: { userId },
  });

  // Get scores for this user
  const scores = await prisma.score.findMany({
    where: { userId },
    select: { points: true, gameId: true },
  });

  let wins = 0;
  let highestScore = 0;
  let totalWon = 0;
  const allPlacements: number[] = [];

  // To compute placements, fetch all games user has played with scores
  const gameIds = scores.map((s) => s.gameId);
  let bestRank: number | string = "-";
  if (gameIds.length > 0) {
    // Get all scores for these games in bulk
    const allScoresForGames = await prisma.score.findMany({
      where: { gameId: { in: gameIds } },
      select: { gameId: true, userId: true, points: true },
    });

    // Map gameId -> all scores for that game
    const scoresByGame: Record<number, { userId: number; points: number }[]> =
      {};
    for (const s of allScoresForGames) {
      if (!scoresByGame[s.gameId]) scoresByGame[s.gameId] = [];
      scoresByGame[s.gameId].push({ userId: s.userId, points: s.points });
    }

    for (const entry of scores) {
      const scoresForGame = scoresByGame[entry.gameId] ?? [];
      // Find placement: sort descending by points
      const sorted = [...scoresForGame].sort((a, b) => b.points - a.points);
      const placement = sorted.findIndex((item) => item.userId === userId) + 1;
      if (placement > 0) {
        allPlacements.push(placement);
      }
    }
    // Find best (minimum) rank
    if (allPlacements.length > 0) {
      bestRank = Math.min(...allPlacements);
    }
  }

  // For "wins", define as having the highest score in a game.
  for (const entry of scores) {
    const winningScore = await prisma.score.findFirst({
      where: { gameId: entry.gameId },
      orderBy: { points: "desc" },
    });
    if (
      winningScore?.userId === userId &&
      entry.points === winningScore.points
    ) {
      wins += 1;
    }
    if (entry.points > highestScore) highestScore = entry.points;
    totalWon += entry.points > 0 ? entry.points : 0;
  }

  const avgScore =
    scores.length > 0
      ? scores.reduce((sum, score) => sum + score.points, 0) / scores.length
      : 0;
  const winRate = totalGames > 0 ? wins / totalGames : 0;

  // Simple streak: consecutive games where user scored > 0
  let currentStreak = 0;
  const playedGameIds = scores.map((s) => s.gameId);
  if (playedGameIds.length > 0) {
    const lastGames = await prisma.game.findMany({
      where: { id: { in: playedGameIds } },
      orderBy: { startTime: "desc" },
      select: { id: true, startTime: true },
    });
    for (const g of lastGames) {
      const sc = scores.find((s) => s.gameId === g.id);
      if (sc && sc.points > 0) currentStreak += 1;
      else break;
    }
  }

  return {
    totalGames,
    wins,
    winRate,
    totalWon,
    highestScore,
    avgScore,
    currentStreak,
    bestRank,
  };
}

async function getGameHistory(
  userId: number | null
): Promise<GameHistoryEntry[]> {
  if (!userId) return [];
  // Get recent games the user played in, with their score and position
  const participants = await prisma.gameParticipant.findMany({
    where: { userId },
    orderBy: { joinedAt: "desc" },
    take: 14,
    include: {
      game: {
        select: {
          id: true,
          name: true,
          startTime: true,
        },
      },
    },
  });

  // bulk get all scores for games user participated in
  const allScores = await prisma.score.findMany({
    where: {
      gameId: { in: participants.map((p) => p.gameId) },
    },
    select: { gameId: true, userId: true, points: true, id: true },
  });

  // get tickets for winnings/amountUSDC (prize) if applicable
  const allTickets = await prisma.ticket.findMany({
    where: {
      userId,
      gameId: { in: participants.map((p) => p.gameId) },
      status: "confirmed",
    },
    select: { gameId: true, amountUSDC: true },
  });

  // Build the GameHistoryEntry[]
  const history: GameHistoryEntry[] = participants.map((p) => {
    // Get score for this game
    const score = allScores.find(
      (s) => s.userId === userId && s.gameId === p.gameId
    );
    // Ranking (1-indexed placement)
    const scoresThisGame = allScores
      .filter((s) => s.gameId === p.gameId)
      .sort((a, b) => b.points - a.points);
    const placement =
      score && scoresThisGame.length > 0
        ? scoresThisGame.findIndex((s) => s.userId === userId) + 1
        : undefined;

    // Find confirmed winnings for this game (if any, from ticket, or set to 0)
    const ticket = allTickets.find((t) => t.gameId === p.gameId);
    const winnings = ticket ? ticket.amountUSDC : 0;

    return {
      id: p.game.id,
      name: p.game.name ?? "Game",
      score: score?.points ?? 0,
      winnings: winnings,
      winningsColor: winnings > 0 ? "green" : "gray",
    };
  });

  return history;
}

async function getInviteData(userId: number | null) {
  if (!userId) return { code: null, status: null };

  // Get referral code generated by user, if any
  const referral = await prisma.referral.findFirst({
    where: { inviterId: userId },
    orderBy: { createdAt: "asc" },
  });
  const inviteCode = referral?.code ?? null;

  // Referral status info (e.g., # of successful invites)
  const status = await prisma.referral.count({
    where: { inviterId: userId, acceptedAt: { not: null } },
  });

  return {
    code: inviteCode,
    status,
  };
}

export default async function ProfilePage() {
  const fid = await getCurrentUserFid();

  let profileData = await getProfileData(fid);
  let stats = null;
  let gameHistory: GameHistoryEntry[] = [];
  let inviteCode: string | null = null;
  let referralStatusData: number | null = null;
  let streak = 0;
  let username: string | null = null;

  let userId =
    profileData?.fid != null
      ? (
          await prisma.user.findUnique({
            where: { fid: profileData.fid },
            select: { id: true },
          })
        )?.id ?? null
      : null;

  if (userId) {
    stats = await getProfileStatsData(userId);
    gameHistory = await getGameHistory(userId);
    username = profileData?.name ?? null;
    streak = stats?.currentStreak ?? 0;
    const invite = await getInviteData(userId);
    inviteCode = invite.code;
    referralStatusData = invite.status;
  }

  // Fallback for demo mode: show any user profile if no user is logged in
  if (!profileData) {
    const anyUser = await prisma.user.findFirst();
    if (anyUser) {
      profileData = {
        fid: anyUser.fid,
        name: anyUser.name,
        wallet: anyUser.wallet,
        imageUrl: anyUser.imageUrl,
      };
      userId = anyUser.id;
      stats = await getProfileStatsData(userId);
      gameHistory = await getGameHistory(userId);
      username = profileData.name ?? null;
      streak = stats?.currentStreak ?? 0;
      const invite = await getInviteData(userId);
      inviteCode = invite.code;
      referralStatusData = invite.status;
    }
  }

  return (
    <ProfilePageClient
      profileData={profileData}
      stats={stats}
      gameHistory={gameHistory}
      streak={streak}
      username={username}
      inviteCode={inviteCode}
      referralStatusData={referralStatusData}
    />
  );
}

--- File: ./src/app/(authenticated)/profile/stats/page.tsx ---
"use client"; // Required for hooks (SWR, useEffect), Link, etc.

import Link from "next/link";
import Image from "next/image";
import useSWR from "swr";
import { ArrowLeftIcon, WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { useMiniUser } from "@/hooks/useMiniUser";
import { cn } from "@/lib/utils";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { base } from "wagmi/chains";
import React from "react";

const fetcherWithFid = (url: string, fid: string | null) => {
  if (!fid) return Promise.reject(new Error("FID required for fetch"));
  return fetch(url, {
    headers: { "x-farcaster-id": fid },
    cache: "no-store",
  }).then(async (res) => {
    if (!res.ok) {
      const errorBody = await res.json().catch(() => ({}));
      const error = new Error(
        `API Error (${res.status}): ${errorBody?.error || res.statusText}`
      );
      (error as Error & { status?: number }).status = res.status;
      throw error;
    }
    return res.json();
  });
};

interface ProfileStatsData {
  totalGames: number;
  wins: number;
  winRate: number;
  totalWon: number;
  highestScore: number;
  avgScore: number;
  currentStreak: number;
  bestRank: number | string;
}

const TopBar = () => {
  const user = useMiniUser();
  const { status, roundedBalance } = useGetTokenBalance(
    user.wallet as `0x${string}`,
    {
      address: env.nextPublicUsdcAddress as `0x${string}`,
      chainId: base.id,
      decimals: 6,
      image: "/images/tokens/usdc.png",
      name: "USDC",
      symbol: "USDC",
    }
  );

  return (
    <header
      className={cn(
        "sticky top-0 z-10 w-full",
        "border-b border-[color:var(--surface-stroke)]",
        "bg-[color:var(--brand-ink-900)]/80 backdrop-blur-sm"
      )}
    >
      <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
        <LogoIcon />
        <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
          <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
          <span
            className="text-center text-[color:var(--text-primary)] font-display tabular-nums"
            style={{
              fontSize: "clamp(.9rem, 1.8vw, .95rem)",
              lineHeight: "1.1",
            }}
          >
            {status === "pending" ? "Loading..." : `$${roundedBalance}`}
          </span>
        </div>
      </div>
    </header>
  );
};

const SubPageHeader = ({ title }: { title: string }) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    <Link
      href="/profile"
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80"
      aria-label="Back to profile"
    >
      <ArrowLeftIcon />
    </Link>
    <h1
      className="flex-grow text-center text-white font-body"
      style={{
        fontWeight: 400,
        fontSize: "clamp(1.25rem, 4.5vw, 1.375rem)",
        lineHeight: ".92",
        letterSpacing: "-0.03em",
      }}
    >
      {title}
    </h1>
    <div className="h-[34px] w-[34px]" aria-hidden="true" />
  </div>
);

const LargeStat = ({
  label,
  value,
}: {
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-2">
    <p
      className="text-muted font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem, 2.8vw, 1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>{" "}
    <p
      className="text-white font-body"
      style={{
        fontSize: "clamp(1.15rem, 4vw, 1.25rem)",
        lineHeight: "1",
      }}
    >
      {typeof value === "number" ? value.toLocaleString() : value}
    </p>{" "}
  </div>
);

const IconStat = ({
  icon,
  label,
  value,
}: {
  icon: string;
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-1">
    <Image
      src={icon}
      alt=""
      width={36}
      height={36}
      className="h-9 w-9"
      priority={false}
    />
    <p
      className="text-muted text-center font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem, 2.8vw, 1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>{" "}
    <p
      className="text-white leading-none font-body"
      style={{
        fontSize: "clamp(1.15rem, 4vw, 1.25rem)",
        lineHeight: "1",
      }}
    >
      {typeof value === "number" ? value.toLocaleString() : value}
    </p>{" "}
  </div>
);

export default function AllTimeStatsPage() {
  const { fid } = useMiniUser();
  const fidString = fid ? String(fid) : null;

  const {
    data: allTimeStats,
    error,
    isLoading,
  } = useSWR<ProfileStatsData>(
    fidString ? "/api/profile/stats" : null,
    (url: string) => fetcherWithFid(url, fidString),
    { revalidateOnFocus: false }
  );

  const formattedStats = React.useMemo(() => {
    if (!allTimeStats) return null;

    return {
      totalGames: allTimeStats.totalGames,
      wins: allTimeStats.wins,
      winRate: `${Math.round(allTimeStats.winRate * 10) / 10}%`,
      totalWon: `$${allTimeStats.totalWon.toLocaleString(undefined, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2,
      })}`,
      highestScore: allTimeStats.highestScore,
      averageScore: Math.round(allTimeStats.avgScore * 100) / 100,
      currentStreak: allTimeStats.currentStreak,
      bestRank:
        allTimeStats.bestRank === Infinity ? "-" : allTimeStats.bestRank,
    };
  }, [allTimeStats]);

  return (
    <div className={cn("min-h-screen flex flex-col", "app-background noise")}>
      <TopBar />
      <SubPageHeader title="ALL-TIME STATS" />
      <main
        className={cn(
          "mx-auto w-full max-w-lg flex-1",
          "px-4",
          "pb-[calc(env(safe-area-inset-bottom)+84px)]",
          "flex flex-col gap-5 sm:gap-6",
          "mt-4"
        )}
      >
        {isLoading && (
          <div className="flex justify-center items-center pt-10 text-muted">
            Loading stats...
          </div>
        )}

        {error && (
          <div className="panel rounded-2xl p-4 text-center text-sm text-danger">
            Error loading stats: {error.message}
          </div>
        )}

        {!isLoading && !error && formattedStats && (
          <>
            <section
              className={cn("rounded-2xl border border-white/20 p-4 sm:p-5")}
              aria-labelledby="total-stats-heading"
            >
              <h2 id="total-stats-heading" className="sr-only">
                Total Statistics
              </h2>
              <div
                className={cn(
                  "grid grid-cols-2 gap-x-4 gap-y-4 sm:gap-y-6 justify-items-center"
                )}
              >
                <LargeStat
                  label="Total games"
                  value={formattedStats.totalGames}
                />{" "}
                <LargeStat label="Wins" value={formattedStats.wins} />
                <LargeStat
                  label="Win rate"
                  value={formattedStats.winRate}
                />{" "}
                <LargeStat label="Total won" value={formattedStats.totalWon} />{" "}
              </div>
            </section>{" "}
            <section
              className={cn("rounded-2xl border border-white/20 p-4 sm:p-5")}
              aria-labelledby="detailed-stats-heading"
            >
              <h2 id="detailed-stats-heading" className="sr-only">
                Detailed Statistics
              </h2>
              <div
                className={cn(
                  "grid grid-cols-2 gap-x-6 gap-y-6 sm:gap-y-8 justify-items-center"
                )}
              >
                <IconStat
                  icon="/images/icons/trophy.svg"
                  label="Highest score"
                  value={formattedStats.highestScore}
                />
                <IconStat
                  icon="/images/icons/average.svg"
                  label="Average score"
                  value={formattedStats.averageScore}
                />
                <IconStat
                  icon="/images/icons/streak-flame.svg"
                  label="Current streak"
                  value={formattedStats.currentStreak}
                />
                <IconStat
                  icon="/images/icons/rank.svg"
                  label="Best rank"
                  value={formattedStats.bestRank}
                />
              </div>
            </section>{" "}
          </>
        )}

        {!isLoading && !error && !formattedStats && (
          <div className="panel rounded-2xl p-6 text-center text-sm text-muted mt-6">
            No stats available yet.
          </div>
        )}
      </main>
      <BottomNav />
    </div>
  );
}

--- File: ./src/app/layout.tsx ---
import "./globals.css";
import { fontBody, fontDisplay, fontInput } from "@/lib/fonts";
import { Metadata } from "next";

import { cn } from "@/lib/utils";

import { Providers } from "@/components/providers/";
import { minikitConfig } from "../../minikit.config";

export async function generateMetadata(): Promise<Metadata> {
  return {
    title: minikitConfig.miniapp.name,
    description: minikitConfig.miniapp.description,
    other: {
      "fc:frame": JSON.stringify({
        version: minikitConfig.miniapp.version,
        imageUrl: minikitConfig.miniapp.heroImageUrl,
        button: {
          title: `Launch ${minikitConfig.miniapp.name}`,
          action: {
            name: `Launch ${minikitConfig.miniapp.name}`,
            type: "launch_frame",
            url: minikitConfig.miniapp.homeUrl,
            splashImageUrl: minikitConfig.miniapp.splashImageUrl,
            splashBackgroundColor: minikitConfig.miniapp.splashBackgroundColor,
          },
        },
      }),
    },
  };
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html
      lang="en"
      className={cn(
        fontBody.variable,
        fontDisplay.variable,
        fontInput.variable,
        "suppress-hydration-warning"
      )}
      suppressHydrationWarning
    >
      <body
        className={cn(
          "text-foreground app-background relative h-full overflow-hidden"
        )}
      >
        <Providers>
          <div className="h-[100dvh] flex flex-col overflow-hidden">
            {children}
          </div>
        </Providers>
      </body>
    </html>
  );
}

--- File: ./src/app/error.tsx ---
"use client";

import React, { useEffect } from "react";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

interface ErrorPageProps {
  error: Error & { digest?: string };
  reset: () => void;
}

export default function GameErrorPage({ error, reset }: ErrorPageProps) {
  useEffect(() => {
    console.error("Game Segment Error:", error);
  }, [error]);

  return (
    <div
      className="
        flex flex-col items-center justify-center
        min-h-[80dvh]
        w-full px-4 sm:px-8 py-8
        text-center
        text-foreground
       
      "
      style={{
        minHeight: "80dvh",
      }}
    >
      <h1
        className="
          text-[clamp(1.5rem,5vw,2.25rem)]
          font-body font-bold text-red-500 mb-2 sm:mb-3
          leading-tight
        "
      >
        Oops! Waffle Down!
      </h1>
      <p
        className="
          mb-5 sm:mb-6 text-[clamp(1rem,3vw,1.15rem)]
          text-muted-foreground font-display
          max-w-[92vw] sm:max-w-md 
          mx-auto
          leading-snug
        "
      >
        Sorry, there was a problem loading or running the game. Please try
        again.
      </p>
      {process.env.NODE_ENV === "development" && error?.message && (
        <pre
          className="
            mb-5 sm:mb-6
            text-xs sm:text-sm
            text-red-300
            bg-red-900/20
            p-2 sm:p-3
            rounded
            max-w-full
            w-full sm:w-auto
            overflow-x-auto
            font-mono
            text-left
            break-words
          "
          style={{
            whiteSpace: "pre-wrap",
            wordBreak: "break-all",
          }}
        >
          {error.message}
          {error.digest && `\nDigest: ${error.digest}`}
          {error.stack &&
            `\n\nStack Trace:\n${error.stack.substring(0, 500)}...`}
        </pre>
      )}
      <div className="w-full flex justify-center">
        <FancyBorderButton
          onClick={reset}
          className="
            w-full max-w-xs sm:max-w-sm
            py-3 px-3 sm:px-5
            text-base sm:text-lg
          "
        >
          Try Again
        </FancyBorderButton>
      </div>
    </div>
  );
}

--- File: ./src/app/api/waitlist/status/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

// Define a schema for the query parameters
const querySchema = z.object({
  fid: z.string().regex(/^\d+$/, "FID must be a numeric string."),
});

/**
 * GET handler to check a user's waitlist status, rank, and invite count.
 * Expects 'fid' as a query parameter.
 */
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const fidParam = searchParams.get("fid");

    const validationResult = querySchema.safeParse({ fid: fidParam });

    if (!validationResult.success) {
      const firstError =
        validationResult.error.message || "Invalid FID parameter";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }

    const { fid } = validationResult.data;

    const user = await prisma.user.findUnique({ where: { fid: Number(fid) } });
    if (!user) {
      return NextResponse.json({ onList: false });
    }

    const entry = await prisma.waitlist.findUnique({
      where: { userId: user.id },
    });
    if (!entry) {
      return NextResponse.json({ onList: false });
    }

    // Calculate rank using a raw SQL query
    // The query orders users by their signup time, adjusted earlier by invite count.
    // ROW_NUMBER() assigns rank based on this order.
    // NOTE: Performance might degrade with very large waitlists. Consider indexing createdAt.
    const rankResult = await prisma.$queryRaw<{ rank: bigint }[]>`
      SELECT rank FROM (
        SELECT
          id,
          ROW_NUMBER() OVER (ORDER BY "createdAt" ASC, id ASC) as rank
          -- Original rank calculation (adjusting time based on invites):
          -- ROW_NUMBER() OVER (ORDER BY ("createdAt" - (invites * INTERVAL '2 minutes')) ASC, id ASC) as rank
        FROM "Waitlist"
      ) t
      WHERE t.id = ${entry.id}
    `;

    const rank = rankResult[0]?.rank ? Number(rankResult[0].rank) : null;

    return NextResponse.json({
      onList: true,
      rank: rank,
      invites: entry.invites,
    });
  } catch (error) {
    console.error("Error fetching waitlist status:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure this route is always dynamically evaluated, preventing stale cached responses.
export const dynamic = "force-dynamic";

--- File: ./src/app/api/tickets/verify/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

const querySchema = z.object({
  gameId: z.string().regex(/^\d+$/, "Invalid gameId format").transform(Number),
});

export async function GET(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId) {
      return NextResponse.json(
        { valid: false, message: "Unauthorized: Missing Farcaster ID header" },
        { status: 401 }
      );
    }
    if (!/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { valid: false, message: "Unauthorized: Invalid Farcaster ID format" },
        { status: 401 }
      );
    }

    const { searchParams } = new URL(request.url);
    const gameIdParam = searchParams.get("gameId");

    const validationResult = querySchema.safeParse({ gameId: gameIdParam });

    if (!validationResult.success) {
      const firstError =
        validationResult.error.message || "Invalid or missing gameId";
      return NextResponse.json(
        { valid: false, message: firstError },
        { status: 400 }
      );
    }
    const { gameId } = validationResult.data;

    const user = await prisma.user.findUnique({
      where: { fid: Number(farcasterId) },
    });
    if (!user) {
      return NextResponse.json(
        { valid: false, message: "User not found" },
        { status: 404 }
      );
    }

    const ticket = await prisma.ticket.findFirst({
      where: {
        userId: user.id,
        gameId,
        status: "confirmed",
      },
    });

    if (!ticket) {
      return NextResponse.json({
        valid: false,
        message: "Ticket not found for this game",
      });
    }

    return NextResponse.json({ valid: true, ticketId: ticket.id });
  } catch (error) {
    console.error("Error verifying ticket:", error);
    return NextResponse.json(
      { valid: false, message: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for fresh ticket verification data
export const dynamic = "force-dynamic";

--- File: ./src/app/api/tickets/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { randomBytes } from "crypto";
import { prisma } from "@/lib/db";

export async function GET(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId || !/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { error: "Unauthorized: Invalid or missing Farcaster ID header" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { fid: Number(farcasterId) },
      select: { id: true },
    });
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const { searchParams } = new URL(request.url);
    const gameIdParam = searchParams.get("gameId");
    const gameId = gameIdParam ? parseInt(gameIdParam, 10) : null;

    const tickets = await prisma.ticket.findMany({
      where: {
        userId: user.id,
        ...(gameId && !isNaN(gameId) && { gameId: gameId }),
      },
      include: {
        game: { select: { name: true } },
      },
      orderBy: { purchasedAt: "desc" },
    });

    const result = tickets.map((ticket) => ({
      id: ticket.id,
      gameId: ticket.gameId,
      gameTitle: ticket.game.name,
      code: ticket.code,
      amountUSDC: ticket.amountUSDC,
      status: ticket.status,
      txHash: ticket.txHash,
      purchasedAt: ticket.purchasedAt,
      usedAt: ticket.usedAt,
    }));
    return NextResponse.json(result);
  } catch (error) {
    // Catch unexpected errors
    console.error("GET /api/tickets Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

const postBodySchema = z.object({
  gameId: z.number().int().positive("Game ID must be a positive integer."),
});

export async function POST(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId || !/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { error: "Unauthorized: Invalid or missing Farcaster ID header" },
        { status: 401 }
      );
    }

    let body;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
    }
    const parseResult = postBodySchema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json(
        {
          error: "Invalid input",
          issues: parseResult.error.flatten().fieldErrors,
        },
        { status: 400 }
      );
    }
    const { gameId } = parseResult.data;

    const user = await prisma.user.findUnique({
      where: { fid: Number(farcasterId) },
    });
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const referral = await prisma.referral.findFirst({
      where: { inviteeId: user.id },
    });
    if (!referral) {
      return NextResponse.json(
        { error: "A valid invite is required to reserve a ticket." },
        { status: 403 }
      );
    }

    const game = await prisma.game.findUnique({
      where: { id: gameId },
      include: { config: true },
    });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }
    if (!game.config) {
      return NextResponse.json(
        { error: "Game configuration missing" },
        { status: 500 }
      );
    }
    const now = new Date();
    if (game.startTime && now >= game.startTime) {
      return NextResponse.json(
        { error: "Cannot reserve ticket: Game has already started" },
        { status: 400 }
      );
    }

    const existingTicket = await prisma.ticket.findUnique({
      where: {
        gameId_userId: { userId: user.id, gameId: game.id },
      },
      include: { game: { select: { name: true } } },
    });
    if (existingTicket) {
      const result = {
        id: existingTicket.id,
        gameId: existingTicket.gameId,
        gameTitle: existingTicket.game.name,
        code: existingTicket.code,
        amountUSDC: existingTicket.amountUSDC,
        status: existingTicket.status,
        txHash: existingTicket.txHash,
        purchasedAt: existingTicket.purchasedAt,
        usedAt: existingTicket.usedAt,
      };
      return NextResponse.json(result, { status: 200 });
    }

    // 7. Generate Unique Code
    let code: string;
    for (let attempt = 0; attempt < 10; attempt++) {
      code = randomBytes(6).toString("hex").toUpperCase();
      if (!(await prisma.ticket.findUnique({ where: { code } }))) {
        break;
      }
      if (attempt === 9) {
        throw new Error("Could not generate unique ticket code");
      }
    }

    const ticket = await prisma.ticket.create({
      data: {
        userId: user.id,
        gameId: game.id,
        amountUSDC: game.config.ticketPrice,
        code: code!,
        txHash: null,
        status: "pending",
      },
      include: { game: { select: { name: true } } },
    });

    const result = {
      id: ticket.id,
      gameId: ticket.gameId,
      gameTitle: ticket.game.name,
      code: ticket.code,
      amountUSDC: ticket.amountUSDC,
      status: ticket.status,
      txHash: ticket.txHash,
      purchasedAt: ticket.purchasedAt,
      usedAt: ticket.usedAt,
    };
    return NextResponse.json(result, { status: 201 });
  } catch (error) {
    console.error("POST /api/tickets Error:", error);

    if (
      typeof error === "object" &&
      error !== null &&
      "code" in error &&
      error.code === "P2002"
    ) {
      return NextResponse.json(
        { error: "Ticket already exists (race condition)." },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for GET requests
export const dynamic = "force-dynamic";

--- File: ./src/app/api/referral/status/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

const querySchema = z.object({
  fid: z.string().regex(/^\d+$/, "FID must be a numeric string."),
});

/**
 * GET handler to check if a user (identified by FID query param) has a
 * referral record indicating they were invited.
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const fidParam = searchParams.get("fid");

    const validationResult = querySchema.safeParse({ fid: fidParam });
    if (!validationResult.success) {
      const firstError =
        validationResult.error.message || "Invalid or missing FID";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const { fid } = validationResult.data;

    const user = await prisma.user.findUnique({
      where: { fid: Number(fid) },
      select: { id: true },
    });

    if (!user) {
      return NextResponse.json({
        hasInvite: false,
        message: "User not found.",
      });
    }

    const referral = await prisma.referral.findFirst({
      where: { inviteeId: user.id },
      select: {
        code: true,
        acceptedAt: true,
      },
    });

    if (!referral) {
      return NextResponse.json({ hasInvite: false });
    }

    return NextResponse.json({
      hasInvite: true,
      referral: {
        code: referral.code,
        acceptedAt: referral.acceptedAt,
      },
    });
  } catch (error) {
    console.error("Failed to fetch referral status:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for fresh referral status data
export const dynamic = "force-dynamic";

--- File: ./src/app/api/chat/route.ts ---
import { z } from "zod";
import { prisma } from "@/lib/db";
import { ChatWithUser as ChatWithUserType } from "@/state/types";
import { NextRequest, NextResponse } from "next/server";

// Schema for query parameter validation
const querySchema = z.object({
  gameId: z.number().int().positive("Invalid gameId format"), // Validate and transform to number
});

// ====================================================================
// GET /api/chat - Fetch chat messages for a specific game
// ====================================================================
export async function GET(request: NextRequest) {
  // Use NextRequest
  try {
    const { searchParams } = new URL(request.url);
    const gameIdParam = searchParams.get("gameId");

    const validationResult = querySchema.safeParse({ gameId: gameIdParam });
    if (!validationResult.success) {
      const firstError =
        validationResult.error.message || "Invalid or missing gameId";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const { gameId } = validationResult.data;

    // Optional: Add pagination or limit? For now, fetch all.
    // const limit = 50; // Example limit
    // const cursor = searchParams.get("cursor"); // Example cursor

    // 2. Fetch Messages
    const messages = await prisma.chat.findMany({
      where: { gameId },
      include: {
        user: {
          select: { name: true, imageUrl: true, id: true, fid: true },
        },
      },
      orderBy: { createdAt: "asc" },
    });

    const formattedMessages: ChatWithUserType[] = messages.map((msg) => ({
      id: msg.id,
      gameId: msg.gameId,
      userId: msg.userId,
      user: {
        id: msg.user?.id ?? 0,
        fid: msg.user?.fid ?? null,
        name: msg.user?.name ?? "anon",
        imageUrl: msg.user?.imageUrl ?? null,
      },
      message: msg.message,
      createdAt: msg.createdAt,
    }));

    return NextResponse.json(formattedMessages);
  } catch (error) {
    // Catch unexpected errors
    console.error("GET /api/chat Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for fresh chat messages
export const dynamic = "force-dynamic";

--- File: ./src/app/api/auth/route.ts ---
import { Errors, createClient } from "@farcaster/quick-auth";
import { NextRequest, NextResponse } from "next/server";

const client = createClient();

// Helper function to determine the correct domain for JWT verification
function getUrlHost(request: NextRequest): string {
  // First try to get the origin from the Origin header (most reliable for CORS requests)
  const origin = request.headers.get("origin");
  if (origin) {
    try {
      const url = new URL(origin);
      return url.host;
    } catch (error) {
      console.warn("Invalid origin header:", origin, error);
    }
  }

  // Fallback to Host header
  const host = request.headers.get("host");
  if (host) {
    return host;
  }

  // Final fallback to environment variables (your original logic)
  let urlValue: string;
  if (process.env.VERCEL_ENV === "production") {
    urlValue = process.env.NEXT_PUBLIC_URL!;
  } else if (process.env.VERCEL_URL) {
    urlValue = `https://${process.env.VERCEL_URL}`;
  } else {
    urlValue = "http://localhost:3000";
  }

  const url = new URL(urlValue);
  return url.host;
}

export async function GET(request: NextRequest) {
  // Because we're fetching this endpoint via `sdk.quickAuth.fetch`,
  // if we're in a mini app, the request will include the necessary `Authorization` header.
  const authorization = request.headers.get("Authorization");

  // Here we ensure that we have a valid token.
  if (!authorization || !authorization.startsWith("Bearer ")) {
    return NextResponse.json({ message: "Missing token" }, { status: 401 });
  }

  try {
    // Now we verify the token. `domain` must match the domain of the request.
    // In our case, we're using the `getUrlHost` function to get the domain of the request
    // based on the Vercel environment. This will vary depending on your hosting provider.
    const payload = await client.verifyJwt({
      token: authorization.split(" ")[1] as string,
      domain: getUrlHost(request),
    });

    console.log("payload", payload);

    // If the token was valid, `payload.sub` will be the user's Farcaster ID.
    const userFid = payload.sub;

    // Return user information for your waitlist application
    return NextResponse.json({
      success: true,
      user: {
        fid: userFid,
        issuedAt: payload.iat,
        expiresAt: payload.exp,
      },
    });
  } catch (e) {
    if (e instanceof Errors.InvalidTokenError) {
      return NextResponse.json({ message: "Invalid token" }, { status: 401 });
    }
    if (e instanceof Error) {
      return NextResponse.json({ message: e.message }, { status: 500 });
    }
    throw e;
  }
}

--- File: ./src/app/api/user/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

// Schema to validate the 'farcasterId' query parameter
const querySchema = z.object({
  fid: z.number().int().positive("Invalid FID format."),
});

/**
 * GET handler to fetch basic user profile information based on Farcaster ID.
 */
export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const fidParam = searchParams.get("fid");

    const validationResult = querySchema.safeParse({
      fid: Number(fidParam),
    });
    if (!validationResult.success) {
      const firstError =
        validationResult.error.message || "Invalid FID format.";
      return NextResponse.json(
        { success: false, error: firstError },
        { status: 400 }
      );
    }
    const { fid } = validationResult.data;

    const user = await prisma.user.findUnique({
      where: { fid: Number(fid) },
      select: {
        id: true,
        fid: true,
        name: true,
        wallet: true,
        imageUrl: true,
      },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, user });
  } catch (err) {
    console.error("GET /api/user Error:", err);
    return NextResponse.json(
      { success: false, error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for potentially updated user profiles
export const dynamic = "force-dynamic";

--- File: ./src/app/api/leaderboard/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { env } from "@/lib/env";
import { z } from "zod";

export interface LeaderboardUserData {
  id: string;
  rank: number;
  name: string | null;
  imageUrl: string | null;
  points: number;
}

interface LeaderboardApiResponse {
  users: LeaderboardUserData[];
  hasMore: boolean;
  me: LeaderboardUserData | null;
  totalPlayers: number;
  totalPoints: number;
}

const querySchema = z.object({
  tab: z.enum(["current", "allTime"]).default("allTime"),
  page: z
    .string()
    .regex(/^\d+$/, "Page must be a non-negative integer.")
    .default("0")
    .transform(Number),
  gameId: z
    .string()
    .regex(/^\d+$/, "Game ID must be a numeric string.")
    .optional()
    .transform((val) => (val ? Number(val) : undefined)),
  userId: z
    .string()
    .regex(/^\d+$/, "User ID must be a numeric string.")
    .optional()
    .transform((val) => (val ? Number(val) : undefined)),
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    const queryValidation = querySchema.safeParse({
      tab: searchParams.get("tab"),
      page: searchParams.get("page"),
      gameId: searchParams.get("gameId"),
      userId: searchParams.get("userId"),
    });

    if (!queryValidation.success) {
      const firstError =
        queryValidation.error.message || "Invalid query parameters";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const {
      tab,
      page,
      gameId: requestedGameId,
      userId: requestedUserId,
    } = queryValidation.data;

    let allUsersSorted: LeaderboardUserData[] = [];
    let totalPointsInScope = 0;

    if (tab === "current") {
      let gameIdToQuery: number | undefined = requestedGameId;

      if (!gameIdToQuery) {
        const now = new Date();
        const activeGame = await prisma.game.findFirst({
          where: { startTime: { lte: now }, endTime: { gt: now } },
          orderBy: { startTime: "desc" },
          select: { id: true },
        });
        if (activeGame) {
          gameIdToQuery = activeGame.id;
        } else {
          const lastEndedGame = await prisma.game.findFirst({
            where: { endTime: { lte: now } },
            orderBy: { endTime: "desc" },
            select: { id: true },
          });
          gameIdToQuery = lastEndedGame?.id;
        }
      }

      if (gameIdToQuery) {
        // Fetch scores for the determined game, including user details
        const scores = await prisma.score.findMany({
          where: { gameId: gameIdToQuery },
          include: {
            user: {
              select: { id: true, name: true, imageUrl: true },
            },
          },
          orderBy: { points: "desc" },
        });

        allUsersSorted = scores.map((s, i) => {
          totalPointsInScope += s.points;
          return {
            id: s.userId.toString(),
            rank: i + 1,
            name: s.user?.name ?? null,
            imageUrl: s.user?.imageUrl ?? null,
            points: s.points,
          };
        });
      }
    } else {
      const groupedScores = await prisma.score.groupBy({
        by: ["userId"],
        _sum: { points: true },
        orderBy: { _sum: { points: "desc" } },
      });

      const userIds = groupedScores.map((g) => g.userId);
      if (userIds.length > 0) {
        const usersData = await prisma.user.findMany({
          where: { id: { in: userIds } },
          select: { id: true, name: true, imageUrl: true },
        });
        const usersDataMap = new Map(usersData.map((u) => [u.id, u]));

        allUsersSorted = groupedScores.map((g, i) => {
          const user = usersDataMap.get(g.userId);
          const points = g._sum.points ?? 0;
          totalPointsInScope += points;
          return {
            id: g.userId.toString(),
            rank: i + 1,
            name: user?.name ?? null,
            imageUrl: user?.imageUrl ?? null,
            points: points,
          };
        });
      }
    }

    const totalPlayers = allUsersSorted.length;
    const pageSize = env.nextPublicLeaderboardPageSize;
    const start = page * pageSize;
    const end = start + pageSize;
    const pageUsers = allUsersSorted.slice(start, end);
    const hasMore = end < totalPlayers;

    let me: LeaderboardUserData | null = null;
    if (requestedUserId) {
      const found = allUsersSorted.find(
        (u) => Number(u.id) === requestedUserId
      );
      if (found) me = found;
    }

    const responseData: LeaderboardApiResponse = {
      users: pageUsers,
      hasMore,
      me,
      totalPlayers,
      totalPoints: totalPointsInScope,
    };
    return NextResponse.json(responseData);
  } catch (error) {
    console.error("GET /api/leaderboard Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for fresh leaderboard data
export const dynamic = "force-dynamic";

--- File: ./src/app/api/game/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

const getQuerySchema = z.object({
  limit: z
    .string()
    .regex(/^\d+$/, "Limit must be integer")
    .default("50")
    .transform(Number)
    .optional(),
});

// ====================================================================
// GET /api/game - Fetch a list of games (e.g., for admin or overview)
// ====================================================================
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    const queryValidation = getQuerySchema.safeParse({
      limit: searchParams.get("limit"),
    });

    if (!queryValidation.success) {
      const firstError =
        queryValidation.error.message || "Invalid query parameters";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const { limit } = queryValidation.data;

    const games = await prisma.game.findMany({
      orderBy: { startTime: "asc" },
      take: limit,
      select: {
        id: true,
        name: true,
        description: true,
        startTime: true,
        endTime: true,
        createdAt: true,
      },
    });

    return NextResponse.json(games);
  } catch (error) {
    console.error("GET /api/game Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

export const dynamic = "force-dynamic";

--- File: ./src/app/api/game/[id]/route.ts ---
import { prisma } from "@/lib/db";
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";

const paramsSchema = z.object({
  id: z
    .string()
    .regex(/^\d+$/, "Game ID must be a numeric string.")
    .transform(Number),
});

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const id = searchParams.get("id");

  try {
    const paramsValidation = paramsSchema.safeParse({ id: Number(id) });
    if (!paramsValidation.success) {
      const firstError = paramsValidation.error.message || "Invalid Game ID";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const { id: gameId } = paramsValidation.data;

    const game = await prisma.game.findUnique({
      where: { id: gameId },
      include: {
        questions: {
          orderBy: { id: "asc" },
          select: {
            id: true,
            text: true,
            imageUrl: true,
            options: true,
          },
        },
        config: {
          select: {
            ticketPrice: true,
            roundTimeLimit: true,
            questionsPerGame: true,
            maxPlayers: true,
            soundEnabled: true,
          },
        },
      },
    });

    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const responseData = {
      id: game.id,
      name: game.name,
      description: game.description,
      startTime: game.startTime,
      endTime: game.endTime,
      questions: game.questions.map((q) => ({
        id: q.id,
        text: q.text,
        imageUrl: q.imageUrl,
        options: q.options,
      })),
      config: game.config
        ? {
            ticketPrice: game.config.ticketPrice,
            roundTimeLimit: game.config.roundTimeLimit,
            questionsPerGame: game.config.questionsPerGame,
            maxPlayers: game.config.maxPlayers,
            soundEnabled: game.config.soundEnabled,
          }
        : null,
    };

    return NextResponse.json(responseData);
  } catch (error) {
    console.error(`GET /api/game/${id} Error:`, error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for potentially updated game details
export const dynamic = "force-dynamic";

--- File: ./src/app/api/game/[id]/questions/route.ts ---
import { prisma } from "@/lib/db";
import { NextRequest, NextResponse } from "next/server";

export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const resolved = await context.params;
    const gameId = Number(resolved.id);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid game id" }, { status: 400 });
    }

    const game = await prisma.game.findUnique({ where: { id: gameId } });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const questions = await prisma.question.findMany({
      where: { gameId },
      orderBy: { id: "asc" },
      select: {
        id: true,
        text: true,
        imageUrl: true,
        options: true,
        correctAnswer: true,
      },
    });

    return NextResponse.json({ gameId, questions });
  } catch (e) {
    console.error("questions GET error", e);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/social/friends/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { neynar } from "@/lib/neynarClient";
import { z } from "zod";

type FriendSummary = {
  fid: number;
  username: string;
  displayName: string | null;
  pfpUrl: string | null;
  relationship: {
    isFollower: boolean;
    isFollowing: boolean;
  };
  hasTicket: boolean;
  ticketId?: number;
  ticketGameId?: number;
};

interface FriendsApiResponse {
  friends: FriendSummary[];
  gameId: number | null;
}

const DEFAULT_NEYNAR_LIMIT = 50;
const MAX_NEYNAR_LIMIT = 150;

const querySchema = z.object({
  fid: z
    .string()
    .regex(/^\d+$/, "FID must be a numeric string.")
    .transform(Number),
  limit: z
    .string()
    .regex(/^\d+$/, "Limit must be an integer.")
    .default(String(DEFAULT_NEYNAR_LIMIT))
    .transform(Number)
    .refine(
      (val) => val > 0 && val <= MAX_NEYNAR_LIMIT,
      `Limit must be between 1 and ${MAX_NEYNAR_LIMIT}.`
    ),
  gameId: z
    .string()
    .regex(/^\d+$/, "Game ID must be a numeric string.")
    .optional()
    .transform((val) => (val ? Number(val) : undefined)),
});

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);

    const queryValidation = querySchema.safeParse({
      fid: searchParams.get("fid"),
      limit: searchParams.get("limit"),
      gameId: searchParams.get("gameId"),
    });

    if (!queryValidation.success) {
      const firstError =
        queryValidation.error.message || "Invalid query parameters";
      return NextResponse.json({ error: firstError }, { status: 400 });
    }
    const { fid, limit, gameId: requestedGameId } = queryValidation.data;

    let targetGameId: number | null = requestedGameId ?? null;
    if (!targetGameId) {
      const activeGame = await fetchActiveGame();
      targetGameId = activeGame?.id ?? null;
    }

    let followersRes, followingRes;
    try {
      [followersRes, followingRes] = await Promise.all([
        neynar.fetchUserFollowers({ fid, limit }),
        neynar.fetchUserFollowing({ fid, limit }),
      ]);
    } catch (neynarError) {
      console.error(
        "Neynar API Error fetching followers/following:",
        neynarError
      );
      return NextResponse.json(
        { error: "Failed to fetch social graph from Farcaster." },
        { status: 503 }
      );
    }

    type FriendAccumulator = {
      username: string;
      displayName: string | null;
      pfpUrl: string | null;
      isFollower: boolean;
      isFollowing: boolean;
    };
    const friendsMap = new Map<number, FriendAccumulator>();

    const ingestNeynarUsers = (
      list: typeof followersRes.users,
      relationshipType: "isFollower" | "isFollowing"
    ) => {
      if (!Array.isArray(list)) return;
      for (const entry of list) {
        const user = entry?.user;
        if (!user?.fid) continue;

        const existing = friendsMap.get(user.fid);
        if (existing) {
          existing[relationshipType] = true;
        } else {
          friendsMap.set(user.fid, {
            username: user.username,
            displayName: user.display_name ?? null,
            pfpUrl: user.pfp_url ?? null,
            isFollower: relationshipType === "isFollower",
            isFollowing: relationshipType === "isFollowing",
          });
        }
      }
    };

    ingestNeynarUsers(followersRes?.users ?? [], "isFollower");
    ingestNeynarUsers(followingRes?.users ?? [], "isFollowing");

    if (friendsMap.size === 0) {
      return NextResponse.json({ friends: [], gameId: targetGameId });
    }

    const friendFids = Array.from(friendsMap.keys());

    const friendUsersWithTickets = await prisma.user.findMany({
      where: { fid: { in: friendFids } },
      select: {
        fid: true,
        tickets: targetGameId
          ? {
              where: { gameId: targetGameId, status: "confirmed" },
              select: { id: true, gameId: true },
              orderBy: { purchasedAt: "desc" },
              take: 1,
            }
          : false,
      },
    });

    const ticketLookup = new Map<
      number,
      { ticketId: number; gameId: number }
    >();
    for (const user of friendUsersWithTickets) {
      const firstTicket = user.tickets?.[0];
      if (firstTicket) {
        ticketLookup.set(user.fid, {
          ticketId: firstTicket.id,
          gameId: firstTicket.gameId,
        });
      }
    }

    const result: FriendSummary[] = friendFids.map((friendFid) => {
      const baseInfo = friendsMap.get(friendFid)!;
      const ticketInfo = ticketLookup.get(friendFid);

      return {
        fid: friendFid,
        username: baseInfo.username,
        displayName: baseInfo.displayName,
        pfpUrl: baseInfo.pfpUrl,
        relationship: {
          isFollower: baseInfo.isFollower,
          isFollowing: baseInfo.isFollowing,
        },
        hasTicket: Boolean(
          ticketInfo && (!targetGameId || ticketInfo.gameId === targetGameId)
        ),
        ticketId: ticketInfo?.ticketId,
        ticketGameId: ticketInfo?.gameId,
      };
    });

    result.sort((a, b) => {
      if (a.hasTicket !== b.hasTicket) {
        return a.hasTicket ? -1 : 1;
      }
      return a.username.localeCompare(b.username);
    });

    const responseData: FriendsApiResponse = {
      friends: result,
      gameId: targetGameId,
    };
    return NextResponse.json(responseData);
  } catch (error) {
    console.error("GET /api/social/friends Error:", error);
    const errorMessage =
      error instanceof Error && error.message.includes("Neynar")
        ? "Failed to fetch social graph data."
        : "Internal Server Error";
    const status =
      error instanceof Error && error.message.includes("Neynar") ? 503 : 500;

    return NextResponse.json({ error: errorMessage }, { status });
  }
}

export const dynamic = "force-dynamic";

async function fetchActiveGame(): Promise<{ id: number } | null> {
  try {
    const now = new Date();
    const game = await prisma.game.findFirst({
      where: {
        startTime: { lte: now },
        endTime: { gt: now },
      },
      select: { id: true },
      orderBy: { startTime: "asc" },
    });
    return game ? { id: game.id } : null;
  } catch (err) {
    console.error("Error fetching active game:", err);
    return null;
  }
}

--- File: ./src/app/api/profile/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";

/**
 * GET handler to fetch essential profile information for the authenticated user.
 */
export async function GET(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId || !/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { error: "Unauthorized: Invalid or missing Farcaster ID header" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { fid: Number(farcasterId) },
      select: {
        id: true,
        name: true,
        wallet: true,
        imageUrl: true,
        fid: true,
      },
    });

    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    return NextResponse.json(user);
  } catch (error) {
    console.error("GET /api/profile Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for potentially updated profiles
export const dynamic = "force-dynamic";

--- File: ./src/app/api/profile/history/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";
import { GameHistoryEntry } from "@/state/types";

export async function GET(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId || !/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { error: "Unauthorized: Invalid or missing Farcaster ID header" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { id: Number(farcasterId) },
      select: { id: true },
    });
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const scores = await prisma.score.findMany({
      where: { userId: user.id },
      include: {
        game: {
          select: { id: true, name: true },
        },
      },
      orderBy: { game: { endTime: "desc" } }, // Order by game end time, latest first [cite: 1007]
      // Optional: Add pagination here if history can become very large
      // take: 50,
      // skip: page * 50,
    });

    // 4. Format Response Data
    // Map Prisma result to the GameHistory type expected by the client
    const history: GameHistoryEntry[] = scores.map((s) => ({
      //
      id: s.game.id, // Use game ID as the history item ID
      name: s.game.name ?? "Unnamed Game", // Use game name, provide fallback
      score: s.points, // Score points
      // TODO: Determine actual winnings - is it just points or calculated differently?
      // Assuming winnings are based on points for now, needs clarification.
      winnings: s.points, // Use points as winnings placeholder
      winningsColor: s.points > 0 ? "green" : "gray", // Determine color based on points
    }));

    return NextResponse.json(history); // Return the formatted history array [cite: 1009]
  } catch (error) {
    // Catch unexpected errors
    console.error("GET /api/profile/history Error:", error); // Log server-side
    return NextResponse.json(
      //
      { error: "Internal Server Error" }, // Generic error
      { status: 500 } //
    );
  }
}

// Ensure dynamic execution for fetching potentially updated history
export const dynamic = "force-dynamic"; //

--- File: ./src/app/api/profile/stats/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { prisma } from "@/lib/db";

interface ProfileStatsResponse {
  totalGames: number;
  wins: number;
  winRate: number;
  totalWon: number;
  highestScore: number;
  avgScore: number;
  currentStreak: number;
  bestRank: number | null;
}

const defaultStats: ProfileStatsResponse = {
  totalGames: 0,
  wins: 0,
  winRate: 0,
  totalWon: 0,
  highestScore: 0,
  avgScore: 0,
  currentStreak: 0,
  bestRank: null,
};
export async function GET(request: NextRequest) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId || !/^\d+$/.test(farcasterId)) {
      return NextResponse.json(
        { error: "Unauthorized: Invalid or missing Farcaster ID header" },
        { status: 401 }
      );
    }

    const user = await prisma.user.findUnique({
      where: { fid: Number(farcasterId) },
      select: { id: true },
    });
    if (!user) {
      return NextResponse.json(defaultStats);
    }

    const scores = await prisma.score.findMany({
      where: { userId: user.id },
      include: {
        game: { select: { endTime: true, id: true } },
      },
    });

    // 4. Handle No Games Played
    const totalGames = scores.length;
    if (totalGames === 0) {
      return NextResponse.json(defaultStats);
    }

    let wins = 0;
    let totalWon = 0;
    let highestScore = 0;
    let bestRank: number | null = null;

    const gameIds = [...new Set(scores.map((s) => s.gameId))];
    const allGameScores = await prisma.score.findMany({
      where: { gameId: { in: gameIds } },
      select: { gameId: true, userId: true, points: true },
      orderBy: { points: "desc" },
    });

    const scoresByGame = allGameScores.reduce((acc, score) => {
      if (!acc[score.gameId]) {
        acc[score.gameId] = [];
      }
      acc[score.gameId].push(score);
      return acc;
    }, {} as Record<number, { userId: number; points: number }[]>);

    for (const s of scores) {
      totalWon += s.points;
      highestScore = Math.max(highestScore, s.points);

      const gameScores = scoresByGame[s.gameId] || [];
      const rank = gameScores.findIndex((gs) => gs.userId === user.id) + 1;

      if (rank > 0) {
        if (rank === 1) {
          wins++;
        }
        bestRank = Math.min(bestRank ?? Infinity, rank);
      } else {
        console.warn(
          `User ${user.id} score not found within game ${s.gameId} scores during rank calculation.`
        );
      }
    }

    const sortedScores = [...scores].sort((a, b) => {
      const aTime = a.game.endTime?.getTime() ?? 0;
      const bTime = b.game.endTime?.getTime() ?? 0;
      return bTime - aTime;
    });

    let currentStreak = 0;
    if (sortedScores.length > 0) {
      const latestScore = sortedScores[0];
      const latestGameScores = scoresByGame[latestScore.gameId] || [];
      const latestRank =
        latestGameScores.findIndex((gs) => gs.userId === user.id) + 1;
      if (latestRank === 1) {
        currentStreak = 1;
        for (let i = 1; i < sortedScores.length; i++) {
          const current = sortedScores[i];
          const prevGameScores = scoresByGame[current.gameId] || [];
          const prevRank =
            prevGameScores.findIndex((gs) => gs.userId === user.id) + 1;
          if (prevRank === 1) {
            currentStreak++;
          } else {
            break;
          }
        }
      }
    }

    const avgScore = totalGames > 0 ? totalWon / totalGames : 0;
    const winRate = totalGames > 0 ? (wins / totalGames) * 100 : 0;

    const responseData: ProfileStatsResponse = {
      totalGames,
      wins,
      winRate: Math.round(winRate * 10) / 10,
      totalWon,
      highestScore,
      avgScore: Math.round(avgScore * 100) / 100,
      currentStreak,
      bestRank: bestRank === Infinity ? null : bestRank,
    };
    return NextResponse.json(responseData);
  } catch (error) {
    console.error("GET /api/profile/stats Error:", error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// Ensure dynamic execution for potentially updated stats
export const dynamic = "force-dynamic";

--- File: ./src/app/loading.tsx ---
import { SplashScreen } from "@/components/ui/SplashScreen";

/**
 * Loading UI specific to the '/game' route segment.
 * Displays while the Server Component (`page.tsx`) for this route is fetching data.
 * Leverages the existing SplashScreen component.
 */
export default function Loading() {
  return <SplashScreen />;
}

--- File: ./src/app/page.tsx ---
import { redirect } from "next/navigation";

/**
 * Root page component for the application.
 * Immediately redirects users to the main lobby view ('/lobby').
 * This is handled server-side for efficiency.
 */
export default function Home() {
  redirect("/lobby");
}

--- File: ./src/app/globals.css ---
@layer base, components, utilities;

@import "tailwindcss";
@import "tw-animate-css";

/* Hide scrollbar for Chrome, Safari, and Opera */
::-webkit-scrollbar {
  display: none;
}

/* Hide scrollbar for IE, Edge, and Firefox */
html {
  -ms-overflow-style: none; /* IE and Edge */
  scrollbar-width: none; /* Firefox */
}

/* ------------------------------------------------------------
   GLOBAL BRAND + THEME TOKENS
   ------------------------------------------------------------ */
@custom-variant dark (&:is(.dark *));

:root {
  /* ── Brand Colors ───────────────────────────── */
  --brand-gold: oklch(0.83 0.17 95); /* #FFC931 */
  --brand-cyan: oklch(0.78 0.19 210); /* #00CFF2 */
  --brand-black: #1e1e1e;
  --brand-pink: oklch(0.73 0.22 342); /* #FB72FF */

  --brand-ink-950: oklch(0.12 0 0); /* Black */
  --brand-ink-900: oklch(0.19 0 0); /* Dark Gray */
  --brand-ink-800: oklch(0.24 0 0); /* Medium Gray */
  --brand-white: oklch(1 0 0); /* White */

  /* ── Alpha Utilities ────────────────────────── */
  --white-a07: #ffffff12;
  --white-a08: #ffffff14;
  --white-a10: #ffffff1a;
  --white-a13: #ffffff21;
  --white-a38: #ffffff61;

  /* ── Base Semantic Colors (light mode) ───────── */
  --surface-page: linear-gradient(180deg, var(--brand-ink-800) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-800) 90%, #000 10%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-800) 92%, #000 8%);
  --surface-tint: var(--white-a10);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.74 0 0); /* #99A0AE */

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a13);
  --accent-ring: var(--brand-gold);

  --success: #14b985;
  --danger: oklch(0.65 0.22 25);

  /* ── Sidebar Colors ─────────────────────────── */
  --sidebar-bg: var(--brand-white);
  --sidebar-fg: var(--brand-ink-900);
  --sidebar-primary: var(--brand-ink-800);
  --sidebar-primary-fg: var(--brand-white);
  --sidebar-accent: var(--white-a10);
  --sidebar-accent-fg: var(--brand-ink-900);
  --sidebar-border: #eaeaea;
  --sidebar-ring: #b5b5b5;

  /* ── Radii & Decorative BGs ─────────────────── */
  --radius-xs: 8px;
  --radius-sm: 12px;
  --radius-md: 16px;

  --gold-overlay: linear-gradient(
    189.66deg,
    rgba(0, 0, 0, 0) -6.71%,
    rgba(0, 0, 0, 0.8) 92.73%
  );
  --card-glint: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    color-mix(in oklch, var(--brand-gold) 25%, transparent) 100%
  );

  /* ── Dark Theme Defaults (fallbacks for base) ─ */
  --background: oklch(0.08 0 0);
  --foreground: oklch(0.98 0 0);
  --card: oklch(0.12 0 0);
  --card-foreground: oklch(0.98 0 0);
  --popover: oklch(0.1 0 0);
  --popover-foreground: oklch(0.98 0 0);
}

/* ------------------------------------------------------------
   DARK THEME OVERRIDES
   ------------------------------------------------------------ */
.dark {
  --surface-page: linear-gradient(180deg, var(--brand-ink-900) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-900) 95%, #000 5%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-900) 93%, #000 7%);
  --surface-tint: var(--white-a07);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.72 0 0);

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a10);
  --accent-ring: var(--brand-gold);
}

/* ------------------------------------------------------------
   TAILWIND THEME BRIDGE
   ------------------------------------------------------------ */
@theme inline {
  /* fonts */
  --font-display: var(--font-display);
  --font-body: var(--font-body);

  /* semantic colors */
  --color-background: var(--brand-black);
  --color-card: var(--surface-card);
  --color-popover: var(--surface-popover);
  --color-foreground: var(--text-primary);
  --color-muted: var(--text-muted);
  --color-primary: var(--accent-solid);
  --color-secondary: var(--brand-cyan);

  --color-border: var(--surface-stroke);
  --color-input: var(--surface-tint);
  --color-ring: var(--accent-ring);

  /* brand aliases */
  --color-waffle-gold: var(--brand-gold);
  --color-neon-cyan: var(--brand-cyan);
  --color-neon-pink: var(--brand-pink);
  --color-success: var(--success);
  --color-danger: var(--danger);

  /* radii */
  --radius-sm: var(--radius-xs);
  --radius-md: var(--radius-sm);
  --radius-lg: var(--radius-md);
}

/* ------------------------------------------------------------
   BASE LAYER
   ------------------------------------------------------------ */
@layer base {
  html,
  body {
    height: 100%;
  }
  body {
    @apply bg-background text-foreground antialiased;
    font-family: var(--font-body);
  }
}

/* ------------------------------------------------------------
   UTILITIES
   ------------------------------------------------------------ */

/* Page gradient background */
@utility app-background {
  background-color: var(--brand-black);
  background-attachment: fixed;
  background-repeat: no-repeat;
  background-size: cover;
}

/* Gold overlay card */
@utility bg-gold-overlay {
  background: var(--gold-overlay), var(--brand-gold);
  background-blend-mode: overlay, normal;
}

/* Card glint */
@utility bg-card-glint {
  background-image: var(--card-glint);
}

/* Subtle panel style */
@utility panel {
  background: var(--white-a10);
  border: 1px solid var(--surface-stroke);
  border-radius: var(--radius-md);
}

/* Neon glow */
@utility neon {
  text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
}

/* Global transition curve */
@media (prefers-reduced-motion: no-preference) {
  * {
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }
}

/* ------------------------------------------------------------
   ANIMATIONS
   ------------------------------------------------------------ */
@keyframes glow-pulse {
  0%,
  100% {
    opacity: 1;
    filter: brightness(1);
  }
  50% {
    opacity: 0.85;
    filter: brightness(1.15);
  }
}

@keyframes slide-up {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes slide-in-x {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@utility animate-glow {
  animation: glow-pulse 2s ease-in-out infinite;
}
@utility animate-up {
  animation: slide-up 0.28s ease-out both;
}
@utility animate-in-right {
  animation: slide-in-x 0.28s ease-out both;
}

@utility pixel-corners {
  /* The precise polygon shape for the pixelated corners */
  clip-path: polygon(
    0px 12px,
    6px 12px,
    6px 6px,
    12px 6px,
    12px 0px,
    calc(100% - 12px) 0px,
    calc(100% - 12px) 6px,
    calc(100% - 6px) 6px,
    calc(100% - 6px) 12px,
    100% 12px,
    100% calc(100% - 12px),
    calc(100% - 6px) calc(100% - 12px),
    calc(100% - 6px) calc(100% - 6px),
    calc(100% - 12px) calc(100% - 6px),
    calc(100% - 12px) 100%,
    12px 100%,
    12px calc(100% - 6px),
    6px calc(100% - 6px),
    6px calc(100% - 12px),
    0% calc(100% - 12px)
  );
}

/* ───────────────────────── Base Interaction Animations ───────────────────────── */

/* Fade-in */
.fade-in {
  animation: fadeIn 0.6s ease forwards;
}
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Slide-up */
.slide-up {
  animation: slideUp 0.5s ease forwards;
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Subtle scale pop for tap feedback */
.tap-pop {
  transition: transform 0.12s ease;
}
.tap-pop:active {
  transform: scale(0.96);
}

/*
================================================================================
Final Production CSS for Gradient + Noise Background (Revised for Robustness)
================================================================================
This implementation uses a pseudo-element for the noise overlay, which is a
more robust and common pattern for layering effects.
*/

.app-background {
  --gradient-color-start: #1e1e1e;
  --gradient-color-end: #000000;

  position: relative;
  background-color: var(--gradient-color-start);
  background-image: linear-gradient(
    to bottom,
    var(--gradient-color-start),
    var(--gradient-color-end)
  );
  min-height: 100vh;
  width: 100%;
  isolation: isolate;
}

.app-background::after {
  --noise-svg: url("data:image/svg+xml,%3Csvg viewBox='0 0 250 250' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='1' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
  --noise-opacity: 0.055;

  content: "";
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;

  background-image: var(--noise-svg);
  opacity: var(--noise-opacity);

  pointer-events: none;

  z-index: -1;
}

--- File: ./src/state/types.ts ---
import type { Prisma } from "@prisma/client";

export type GameStateType =
  | "WAITING"
  | "JOIN_GAME"
  | "FINAL_COUNTDOWN"
  | "GAME_LIVE"
  | "GAME_LIVE_ANSWER_SELECTED"
  | "GAME_LIVE_ANSWER_SUBMITTED"
  | "GAME_LIVE_NEXT_QUESTION_COUNTDOWN"
  | "GAME_LIVE_ROUND_COUNTDOWN"
  | "CHAT"
  | "GAME_OVER";

export type ChatWithUser = Prisma.ChatGetPayload<{
  include: {
    user: {
      select: {
        fid: true;
        id: true;
        name: true;
        imageUrl: true;
      };
    };
  };
}>;

export type HydratedGame = Prisma.GameGetPayload<{
  include: {
    config: true;
    questions: true;
    _count: {
      select: {
        tickets: true;
      };
    };
  };
}>;

export type HydratedUser = Prisma.UserGetPayload<{
  include: {
    tickets: true;
    scores: true;
    answers: true;
    gameParticipants: true;
  };
}>;

export type GameThemes = "FOOTBALL" | "MOVIES_ANIME" | "POLITICS" | "CRYPTO";

export interface PlayerInfo {
  username: string | null;
  wallet: string | null;
  pfpUrl: string | null;
}

export interface Ticket {
  id: number;
  gameId: number;
  gameTitle?: string;
  userId?: number;
  txHash: string | null;
  code: string;
  amountUSDC: number;
  status: "pending" | "confirmed" | "used" | "invalid";
  purchasedAt: Date | string;
  usedAt?: Date | string | null;
}

export interface ReferralCode {
  code: string;
  inviterFid?: number | null;
  inviteeId?: number | null;
}

export interface InvitedBy {
  code: string;
  inviterFid: number | null;
  acceptedAt?: Date | string | null;
}

export interface GameHistoryEntry {
  id: number | string;
  name: string;
  score: number;
  winnings: number;
  winningsColor?: "green" | "gray";
}

export interface AllTimeStats {
  totalGames: number;
  wins: number;
  winRate: string;
  totalWon: string;
  highestScore: number;
  averageScore: number;
  currentStreak: number;
  bestRank: number | string | null;
}

export interface ProfileStatsData {
  totalGames: number;
  wins: number;
  winRate: number;
  totalWon: number;
  highestScore: number;
  avgScore: number;
  currentStreak: number;
  bestRank: number | null;
}

export interface LeaderboardEntry {
  id: string | number;
  rank: number;
  username: string | null;
  points: number;
  pfpUrl: string | null;
}

export type FriendSummary = {
  fid: number;
  username: string;
  displayName?: string | null;
  pfpUrl?: string | null;
  relationship: {
    isFollower: boolean;
    isFollowing: boolean;
  };
  hasTicket: boolean;
  ticketId?: number;
  ticketGameId?: number;
};

--- File: ./src/components/ui/SplashScreen.tsx ---
"use client";

import Image from "next/image";
import { cn } from "@/lib/utils";

const crewImages = [
  "/images/splash/crew-1.png",
  "/images/splash/crew-2.png",
  "/images/splash/crew-3.png",
  "/images/splash/crew-4.png",
  "/images/splash/crew-5.png",
  "/images/splash/crew-6.png",
  "/images/splash/crew-7.png",
  "/images/splash/crew-8.png",
  "/images/splash/crew-9.png",
  "/images/splash/crew-10.png",
];

export function SplashScreen() {
  return (
    <div
      className={cn(
        "fixed inset-0 z-80 flex items-center justify-center text-white"
      )}
    >
      <div className="relative flex h-full w-full max-w-sm flex-col items-center justify-center px-6">
        <div className="flex flex-col items-center gap-3 text-center mb-20">
          <div className="relative h-24 w-40 drop-shadow-[0_20px_40px_rgba(0,0,0,0.45)] flex items-center justify-center">
            <Image
              src="/logo.png"
              alt="Waffles Logo"
              width={160}
              height={96}
              className="object-contain w-40 h-24"
              priority
            />
          </div>
          <p className="font-body text-4xl tracking-tight">WAFFLES</p>
        </div>
        <div className="pointer-events-none absolute inset-x-0 bottom-0 flex h-32 items-end justify-center gap-2 px-3 pb-4">
          {crewImages.map((src, index) => (
            <Image
              key={src}
              src={src}
              alt=""
              width={90}
              height={90}
              className={cn(
                "h-[clamp(70px,10vw,90px)] w-auto opacity-95 drop-shadow-[0_12px_25px_rgba(0,0,0,0.45)]",
                index % 2 === 0 ? "-rotate-2" : "rotate-2"
              )}
              priority
            />
          ))}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/components/ui/Toaster.tsx ---
"use client";

import { Toaster as SonnerToaster, toast } from "sonner";

export const notify = {
  success: (msg: string, opts?: object) => toast.success(msg, opts),
  error: (msg: string, opts?: object) => toast.error(msg, opts),
  info: (msg: string, opts?: object) => toast.info(msg, opts),
};

export default function GlobalToaster() {
  return (
    <SonnerToaster
      position="bottom-center"
      theme="dark"
      toastOptions={{
        classNames: {
          toast:
            "bg-[color:var(--surface-card)] border border-[color:var(--surface-stroke)] text-[color:var(--text-primary)] font-display shadow-lg",
          success:
            "!bg-[color:var(--success)] !border-[color:var(--success)] !text-white",
          error:
            "!bg-[color:var(--danger)] !border-[color:var(--danger)] !text-white",
          info: "!bg-[color:var(--color-card)] !border-[color:var(--surface-stroke)] !text-[color:var(--text-primary)]",
        },
      }}
      richColors
      duration={3000}
    />
  );
}

--- File: ./src/components/ui/Backdrop.tsx ---
export default function Backdrop({
  isOpen,
  onClose,
}: {
  isOpen: boolean;
  onClose: () => void;
}) {
  return (
    <div
      onClick={onClose}
      className={`fixed inset-0 z-40 bg-black/50 transition-all duration-500 ease-in-out
        ${isOpen ? "opacity-100" : "opacity-0 pointer-events-none"}
      `}
    />
  );
}

--- File: ./src/components/buttons/FancyBorderButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

interface FancyBorderButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode; // Button content
  fullWidth?: boolean; // Option to make button full width (default: true)
  // Allow ref forwarding
  // ref?: React.RefObject<HTMLButtonElement>; // Ref forwarding handled by React.forwardRef
}

/**
 * A custom button component with a distinctive "fancy" border effect,
 * appearing thicker on the bottom and right. Uses theme colors.
 */
export const FancyBorderButton = React.forwardRef<
  HTMLButtonElement,
  FancyBorderButtonProps
>(
  (
    { children, fullWidth = true, className, type = "button", ...props },
    ref
  ) => {
    return (
      <button
        ref={ref}
        type={type} // Set button type
        className={cn(
          "relative flex items-center justify-center h-[54px] px-6",
          "bg-white text-[#191919]",
          "font-body uppercase tracking-wider text-sm",
          "max-w-sm mx-auto",
          "rounded-[12px]",
          "border-[5px] border-t-0 border-l-0 border-[color:var(--brand-cyan)]",
          fullWidth && "w-full",
          "transition-transform active:translate-y-[2px] active:border-b-[3px] active:border-r-[3px]",
          "disabled:cursor-not-allowed disabled:opacity-60 disabled:active:translate-y-0 disabled:active:border-b-[5px] disabled:active:border-r-[5px]",
          className
        )}
        {...props}
      >
        {children}
      </button>
    );
  }
);

// Assign display name for DevTools
FancyBorderButton.displayName = "FancyBorderButton";

--- File: ./src/components/buttons/PixelButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils"; // Assuming a utility like tailwind-merge

interface PixelButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  asChild?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
  borderWidth?: number; // Border width in pixels
}

const PixelButton = React.forwardRef<HTMLButtonElement, PixelButtonProps>(
  (
    {
      className,
      children,
      backgroundColor = "#000000",
      borderColor = "#FFC931",
      textColor = "#FFD972",
      borderWidth = 4, // Default to a 4px border
      ...props
    },
    ref
  ) => {
    const containerStyle = {
      backgroundColor: borderColor,
      padding: `${borderWidth}px`,
    };

    const buttonStyle = {
      backgroundColor: backgroundColor,
      color: textColor,
    };

    return (
      <div
        style={containerStyle}
        className={cn(
          // This is now a full-width block by default to fill its container
          "pixel-corners w-full transition-transform duration-100 ease-in-out",
          // Apply hover/active states to the container to move the whole unit
          "hover:-translate-y-0.5 active:translate-y-0"
        )}
      >
        <button
          style={buttonStyle}
          className={cn(
            "pixel-corners flex h-full w-full items-center justify-center px-6 py-3 font-display text-sm uppercase tracking-wider",
            "disabled:cursor-not-allowed disabled:opacity-60",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </button>
      </div>
    );
  }
);

PixelButton.displayName = "PixelButton";

export { PixelButton };

--- File: ./src/components/BottomNav.tsx ---
"use client";

import { usePathname, useRouter } from "next/navigation";
import { cn } from "@/lib/utils";
import { HomeIcon, LeaderboardIcon, ProfileIcon } from "./icons";

const navItems = [
  { icon: HomeIcon, label: "Lobby", href: "/lobby" },
  { icon: LeaderboardIcon, label: "Leaderboard", href: "/leaderboard" },
  { icon: ProfileIcon, label: "Profile", href: "/profile" },
];

export function BottomNav() {
  const pathname = usePathname();
  const router = useRouter();

  return (
    <nav
      className={cn(
        "fixed bottom-0 left-0 right-0 z-50",
        "border-t-2 border-border",
        "bg-[#191919]",
        "shrink-0"
      )}
    >
      <div className="mx-auto flex max-w-2xl items-stretch justify-around">
        {navItems.map((item) => {
          const Icon = item.icon;
          const isActive =
            pathname === item.href || pathname.startsWith(item.href + "/");

          return (
            <button
              key={item.href}
              onClick={() => router.push(item.href)}
              className={cn(
                "flex flex-1 flex-col items-center justify-center gap-1 px-4 py-3",
                "transition-colors duration-150 ease-in-out",
                isActive
                  ? "text-primary"
                  : "text-muted-foreground hover:text-foreground"
              )}
              role="tab"
              aria-selected={isActive}
              aria-label={item.label}
            >
              <Icon
                className={cn("h-5 w-5", isActive && "animate-glow")}
                aria-hidden="true"
              />
              <span className="text-xs font-medium font-display">
                {item.label}
              </span>
            </button>
          );
        })}
      </div>
    </nav>
  );
}

--- File: ./src/components/providers/index.tsx ---
"use client";

import { MinikitProvider } from "./MinikitProvider";
import GlobalToaster from "../ui/Toaster";
import { OnboardingGate } from "../onboarding/onboarding-gate";

import { SWRConfig } from "swr";
import { UserPreferencesProvider } from "./userPreference";

const fetcher = (url: string) =>
  fetch(url, { cache: "no-store" }).then((res) => {
    if (!res.ok) {
      throw new Error(`Fetch error: ${res.statusText || res.status}`);
    }
    return res.json();
  });

function CoreAppLogic({ children }: { children: React.ReactNode }) {
  return <>{children}</>;
}

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <MinikitProvider>
      <SWRConfig value={{ fetcher }}>
        <OnboardingGate>
          <CoreAppLogic>
            <UserPreferencesProvider>{children}</UserPreferencesProvider>
            <GlobalToaster />
          </CoreAppLogic>
        </OnboardingGate>
      </SWRConfig>
    </MinikitProvider>
  );
}

--- File: ./src/components/providers/userPreference.tsx ---
"use client";

import {
  createContext,
  useContext,
  ReactNode,
  useCallback,
  useMemo,
} from "react";
import { useLocalStorage } from "@/hooks/useLocalStorage";

// --- Types and Constants (from your original file) ---

export interface UserPreferences {
  soundEnabled: boolean;
  hapticsEnabled: boolean;
  animationsEnabled: boolean;
}

const DEFAULT_PREFERENCES: UserPreferences = {
  soundEnabled: true,
  hapticsEnabled: true,
  animationsEnabled: true,
};

const STORAGE_KEY = "waffles:preferences";

// --- Define the shape of the Context ---

type SetPrefs = (
  value: UserPreferences | ((val: UserPreferences) => UserPreferences)
) => void;

interface PrefsContextType {
  prefs: UserPreferences;
  setPrefs: SetPrefs;
  removePrefs: () => void;
  setSoundEnabled: (enabled: boolean) => void;
  toggleSound: () => void;
  setHapticsEnabled: (enabled: boolean) => void;
  toggleHaptics: () => void;
  setAnimationsEnabled: (enabled: boolean) => void;
  toggleAnimations: () => void;
}

// --- Create the Context ---

const UserPreferencesContext = createContext<PrefsContextType | undefined>(
  undefined
);

// --- Create the Provider Component ---

export function UserPreferencesProvider({ children }: { children: ReactNode }) {
  // Call useLocalStorage *once* here in the provider
  const [prefs, setPrefs, removePrefs] = useLocalStorage<UserPreferences>(
    STORAGE_KEY,
    DEFAULT_PREFERENCES
  );

  // --- Mutators (from your original file, now defined here) ---
  const setSoundEnabled = useCallback(
    (enabled: boolean) =>
      setPrefs((prev) => ({ ...prev, soundEnabled: enabled })),
    [setPrefs]
  );

  const toggleSound = useCallback(
    () => setPrefs((prev) => ({ ...prev, soundEnabled: !prev.soundEnabled })),
    [setPrefs]
  );

  const setHapticsEnabled = useCallback(
    (enabled: boolean) =>
      setPrefs((prev) => ({ ...prev, hapticsEnabled: enabled })),
    [setPrefs]
  );

  const toggleHaptics = useCallback(
    () =>
      setPrefs((prev) => ({ ...prev, hapticsEnabled: !prev.hapticsEnabled })),
    [setPrefs]
  );

  const setAnimationsEnabled = useCallback(
    (enabled: boolean) =>
      setPrefs((prev) => ({ ...prev, animationsEnabled: enabled })),
    [setPrefs]
  );

  const toggleAnimations = useCallback(
    () =>
      setPrefs((prev) => ({
        ...prev,
        animationsEnabled: !prev.animationsEnabled,
      })),
    [setPrefs]
  );

  // Memoize the context value to provide to children
  const value = useMemo(
    () => ({
      prefs,
      setPrefs,
      removePrefs,
      setSoundEnabled,
      toggleSound,
      setHapticsEnabled,
      toggleHaptics,
      setAnimationsEnabled,
      toggleAnimations,
    }),
    [
      prefs,
      setPrefs,
      removePrefs,
      setSoundEnabled,
      toggleSound,
      setHapticsEnabled,
      toggleHaptics,
      setAnimationsEnabled,
      toggleAnimations,
    ]
  );

  return (
    <UserPreferencesContext.Provider value={value}>
      {children}
    </UserPreferencesContext.Provider>
  );
}

// --- Create the Consumer Hook (this is what your components use) ---

/**
 * Hook to access and manage user preferences.
 * Must be used within a <UserPreferencesProvider>.
 */
export function useUserPreferences() {
  const context = useContext(UserPreferencesContext);
  if (context === undefined) {
    throw new Error(
      "useUserPreferences must be used within a UserPreferencesProvider"
    );
  }
  return context;
}

--- File: ./src/components/providers/MinikitProvider.tsx ---
"use client";

import { OnchainKitProvider } from "@coinbase/onchainkit";
import { base } from "wagmi/chains";
import { env } from "@/lib/env";
import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useEffect } from "react";

interface Props {
  children: React.ReactNode;
}

export function MinikitProvider({ children }: Props) {
  return (
    <OnchainKitProvider
      apiKey={env.nextPublicOnchainkitApiKey}
      chain={base}
      config={{
        appearance: {
          mode: "dark",
        },
        wallet: {
          display: "modal",
          preference: "all",
        },
      }}
      miniKit={{
        enabled: true,
        autoConnect: true,
        notificationProxyUrl: undefined,
      }}
    >
      <IsMiniAppReady>{children}</IsMiniAppReady>
    </OnchainKitProvider>
  );
}

export function IsMiniAppReady({ children }: { children: React.ReactNode }) {
  const { isFrameReady, setFrameReady } = useMiniKit();
  useEffect(() => {
    if (!isFrameReady) {
      setFrameReady();
    }
  }, [setFrameReady, isFrameReady]);
  return <>{children}</>;
}

--- File: ./src/components/logo/Logo.tsx ---
import React from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";

/**
 * Renders the primary Waffles logo image.
 * Acts as a simple wrapper around the next/image component.
 * Accepts standard div props like className for flexible styling.
 */
export default function Logo({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("relative w-[40px] h-[40px]", className)} {...props}>
      <Image
        src="/logo.png"
        alt="Waffles Logo"
        fill
        sizes="40px"
        priority
        className="object-contain"
      />
    </div>
  );
}

--- File: ./src/components/logo/LogoIcon.tsx ---
import React from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";

/**
 * Renders the Waffles icon logo (text version).
 * Acts as a simple wrapper around the next/image component.
 * Accepts standard div props like className for flexible styling.
 */
export default function LogoIcon({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div className={cn("relative w-[148px] h-[60px]", className)} {...props}>
      <Image
        src="/logo-onboarding.png"
        alt="Waffles logo icon"
        fill
        sizes="(max-width: 640px) 148px, 148px"
        priority
        className="object-contain"
      />
    </div>
  );
}

--- File: ./src/components/icons.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";
import * as React from "react";

export function HomeIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.58 2H10.58V4H8.58002V6H6.58002V8H4.58002V10H2.58002V12H4.58002V22H11.58V16H13.58V22H20.58V12H22.58V10H20.58V8H18.58V6H16.58V4H14.58V2ZM14.58 4V6H16.58V8H18.58V10H20.58V12H18.58V20H15.58V14H9.58002V20H6.58002V12H4.58002V10H6.58002V8H8.58002V6H10.58V4H14.58Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function LeaderboardIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M12.5 1H14.5V9H22.5V13H20.5V11H12.5V5H10.5V3H12.5V1ZM8.5 7V5H10.5V7H8.5ZM6.5 9V7H8.5V9H6.5ZM4.5 11V9H6.5V11H4.5ZM14.5 19V21H12.5V23H10.5V15H2.5V11H4.5V13H12.5V19H14.5ZM16.5 17V19H14.5V17H16.5ZM18.5 15V17H16.5V15H18.5ZM18.5 15H20.5V13H18.5V15Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function ProfileIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.41998 3H21.42V21H3.41998V3ZM19.42 19V5H5.41998V19H19.42ZM14.42 7H10.42V11H14.42V7ZM15.42 13H9.41998V15H7.41998V17H9.41998V15H15.42V17H17.42V15H15.42V13Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function WalletIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M2 6.19998H13.4C13.5591 6.19998 13.7117 6.26319 13.8243 6.37571C13.9368 6.48823 14 6.64085 14 6.79998V12.8C14 12.9591 13.9368 13.1117 13.8243 13.2242C13.7117 13.3368 13.5591 13.4 13.4 13.4H2.6C2.44087 13.4 2.28826 13.3368 2.17574 13.2242C2.06321 13.1117 2 12.9591 2 12.8V6.19998ZM2.6 2.59998H11.6V4.99998H2V3.19998C2 3.04085 2.06321 2.88823 2.17574 2.77571C2.28826 2.66319 2.44087 2.59998 2.6 2.59998ZM9.8 9.19998V10.4H11.6V9.19998H9.8Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function InviteIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={21}
      height={21}
      viewBox="0 0 21 21"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M15.5 2.16663H10.5V3.83329H8.83331V8.83329H10.5V3.83329H15.5V2.16663ZM15.5 8.83329H10.5V10.5H15.5V8.83329ZM15.5 3.83329H17.1666V8.83329H15.5V3.83329ZM6.33331 13.8333H7.99998V12.1666H18V13.8333H7.99998V17.1666H18V13.8333H19.6666V18.8333H6.33331V13.8333ZM2.99998 7.16663H4.66665V8.83329H6.33331V10.5H4.66665V12.1666H2.99998V10.5H1.33331V8.83329H2.99998V7.16663Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function InviteFriendsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M13.5 1.5H9V3H7.5V7.5H9V3H13.5V1.5ZM13.5 7.5H9V9H13.5V7.5ZM13.5 3H15V7.5H13.5V3ZM5.25 12H6.75V10.5H15.75V12H6.75V15H15.75V12H17.25V16.5H5.25V12ZM2.25 6H3.75V7.5H5.25V9H3.75V10.5H2.25V9H0.75V7.5H2.25V6Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function UploadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.25 3.75V2.25H9.75V3.75H11.25V5.25H12.75V6.75H11.25V5.25H9.75V12.75H8.25V5.25H6.75V6.75H5.25V5.25H6.75V3.75H8.25ZM2.25 11.25V15.75H15.75V11.25H14.25V14.25H3.75V11.25H2.25Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function ArrowRightIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3 8.25V9.75H12V11.25H13.5V9.75H15V8.25H13.5V6.75H12V8.25H3ZM10.5 5.25H12V6.75H10.5V5.25ZM10.5 5.25H9V3.75H10.5V5.25ZM10.5 12.75H12V11.25H10.5V12.75ZM10.5 12.75H9V14.25H10.5V12.75Z"
        fill="currentColor"
      />
    </svg>
  );
}

export const ArrowLeftIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="18"
    height="18"
    viewBox="0 0 18 18"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      d="M15 8.25V9.75H6V11.25H4.5V9.75H3V8.25H4.5V6.75H6V8.25H15ZM7.5 5.25H6V6.75H7.5V5.25ZM7.5 5.25H9V3.75H7.5V5.25ZM7.5 12.75H6V11.25H7.5V12.75ZM7.5 12.75H9V14.25H7.5V12.75Z"
      fill="white"
    />
  </svg>
);

export function GamePadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.33334 3.3335H14.6667V12.6668H1.33334V3.3335ZM13.3333 11.3335V4.66683H2.66668V11.3335H13.3333ZM5.33334 6.00016H6.66668V7.3335H8.00001V8.66683H6.66668V10.0002H5.33334V8.66683H4.00001V7.3335H5.33334V6.00016ZM9.33334 6.00016H10.6667V7.3335H9.33334V6.00016ZM12 8.66683H10.6667V10.0002H12V8.66683Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M4.00001 1.3335H10.6667V2.66683H4.00001V1.3335ZM2.66668 4.00016V2.66683H4.00001V4.00016H2.66668ZM2.66668 12.0002H1.33334V4.00016H2.66668V12.0002ZM4.00001 13.3335H2.66668V12.0002H4.00001V13.3335ZM12 13.3335H4.00001V14.6668H12V13.3335ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 12.0002H14.6667V5.3335H13.3333V12.0002ZM8.00001 4.00016H5.33334V5.3335H4.00001V10.6668H5.33334V12.0002H10.6667V10.6668H12V8.00016H10.6667V10.6668H5.33334V5.3335H8.00001V4.00016ZM9.33334 9.3335V6.66683H10.6667V5.3335H12V4.00016H14.6667V2.66683H13.3333V1.3335H12V4.00016H10.6667V5.3335H9.33334V6.66683H6.66668V9.3335H9.33334Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinningsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.99999 1.3335H12V2.66683H3.99999V1.3335ZM2.66666 4.00016V2.66683H3.99999V4.00016H2.66666ZM2.66666 12.0002V4.00016H1.33333V12.0002H2.66666ZM3.99999 13.3335V12.0002H2.66666V13.3335H3.99999ZM12 13.3335V14.6668H3.99999V13.3335H12ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 4.00016H14.6667V12.0002H13.3333V4.00016ZM13.3333 4.00016V2.66683H12V4.00016H13.3333ZM7.33333 3.3335H8.66666V4.66683H10.6667V6.00016H6.66666V7.3335H10.6667V11.3335H8.66666V12.6668H7.33333V11.3335H5.33333V10.0002H9.33333V8.66683H5.33333V4.66683H7.33333V3.3335Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function ZapIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.00001 0.666504H9.33334V5.99984H14.6667V8.6665H13.3333V7.33317H8.00001V3.33317H6.66668V1.99984H8.00001V0.666504ZM5.33334 4.6665V3.33317H6.66668V4.6665H5.33334ZM4.00001 5.99984V4.6665H5.33334V5.99984H4.00001ZM2.66668 7.33317V5.99984H4.00001V7.33317H2.66668ZM9.33334 12.6665V13.9998H8.00001V15.3332H6.66668V9.99984H1.33334V7.33317H2.66668V8.6665H8.00001V12.6665H9.33334ZM10.6667 11.3332V12.6665H9.33334V11.3332H10.6667ZM12 9.99984V11.3332H10.6667V9.99984H12ZM12 9.99984H13.3333V8.6665H12V9.99984Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WaffleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="13"
      viewBox="0 0 16 13"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.04242 2.73877H3.72203V11.3731H1.04242V2.73877Z"
        fill="#FFC931"
      />
      <path
        d="M13.1901 0.0595703H15.8697L15.8548 8.64922L13.1901 8.69388V0.0595703Z"
        fill="#FFC931"
      />
      <path
        d="M1.04242 11.3735V8.69385H6.40164V11.3735H1.04242Z"
        fill="#FFC931"
      />
      <path
        d="M10.5104 11.3735V8.69385H13.19V11.3735H10.5104Z"
        fill="#FFC931"
      />
      <path
        d="M3.72208 2.73918V0.0595703H15.8696V2.73918H3.72208Z"
        fill="#FFC931"
      />
      <path
        d="M9.66196 9.51262L10.4807 8.69385H12.2522V9.55728L9.66196 9.51262Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 9.5275L3.72208 8.69385L6.32726 8.72362L5.56804 9.5275H2.88843Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 3.72168H3.69231V8.69385L2.88843 9.49773V3.72168Z"
        fill="#00CFF2"
      />
      <path
        d="M15.8995 2.76894H15.8948L15.8846 8.64926V8.67847L15.8555 8.67898L13.2199 8.72313V11.4032H10.4808V9.5564L9.66138 9.54241L9.59133 9.54121L10.4685 8.66409H13.1604V2.76894H3.75195V8.66409H6.43156V11.4032H1.01279V2.7094H3.6924V0.0297852H15.8995V2.76894Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M0.149292 3.63184H2.8289V12.2661H0.149292V3.63184Z"
        fill="#FFC931"
      />
      <path
        d="M12.2969 0.952637H14.9765V9.58694H12.2969V0.952637Z"
        fill="#FFC931"
      />
      <path
        d="M0.149292 12.2665V9.58691H5.50852V12.2665H0.149292Z"
        fill="#FFC931"
      />
      <path
        d="M9.61728 12.2665V9.58691H12.2969V12.2665H9.61728Z"
        fill="#FFC931"
      />
      <path
        d="M2.82895 3.63225V3.58759V2.73904V0.952637H14.9765V3.63225H2.82895Z"
        fill="#FFC931"
      />
      <path
        d="M5.57784 7.97606V7.09321H4.61276V6.34748H5.57784V5.35498H6.27972V6.34748H7.25027V7.09321H6.27972V7.97606H5.57784Z"
        fill="#FB72FF"
      />
      <path
        d="M11.2249 6.6694C11.2249 7.40936 10.625 8.0092 9.88509 8.0092C9.14513 8.0092 8.54529 7.40936 8.54529 6.6694C8.54529 5.92944 9.14513 5.32959 9.88509 5.32959C10.625 5.32959 11.2249 5.92944 11.2249 6.6694Z"
        fill="#00CFF2"
      />
      <path
        d="M14.9764 0.952536V3.63215V9.58684L15.8547 8.67875V0.0742188L14.9764 0.952536Z"
        fill="#00CFF2"
      />
      <path
        d="M12.2969 0.952774H14.9765L15.8548 0.074457L3.67749 0.0595703L2.82895 0.952774H12.2969Z"
        fill="#FB72FF"
      />
      <path
        d="M2.8289 2.73877H1.0425L0.149292 3.58731H2.8289V2.73877Z"
        fill="#FB72FF"
      />
      <path
        d="M13.1901 11.3589L12.4085 12.2522C12.3904 12.2727 12.3564 12.2599 12.3564 12.2325V9.64697H13.1901V11.3589Z"
        fill="#00CFF2"
      />
      <path
        d="M9.88512 5.29972C10.6417 5.29972 11.2547 5.9129 11.2547 6.6693C11.2547 7.42569 10.6417 8.03888 9.88512 8.03888C9.12873 8.03888 8.51554 7.42569 8.51554 6.6693C8.51554 5.9129 9.12873 5.29972 9.88512 5.29972ZM6.30936 5.32544V6.31794H7.27994V7.12322H6.30936V8.00607H5.54796V7.12322H4.58288V6.31794H5.54796V5.32544H6.30936ZM15.8845 8.69103L15.8761 8.6997L14.9978 9.60794L14.9889 9.61687H13.2197V11.3699L13.2123 11.3783L12.4308 12.2715C12.3947 12.3129 12.3265 12.2873 12.3265 12.2322V12.2965H9.58739V9.55732H12.267V3.66218H2.85858V9.55732H5.5382V12.2965H0.119425V3.61752H0.0746155L0.128714 3.56616L1.02192 2.71761L1.03052 2.70943H2.79904V0.940913L2.80723 0.932308L3.65577 0.0391039L3.66458 0.0297852L3.67738 0.0298142L15.8547 0.044701L15.8845 0.04473V8.69103Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M6.36393 8.70556C6.38463 8.68931 6.41666 8.70369 6.41666 8.73156V11.37L6.40943 11.3783L5.61406 12.2992C5.57779 12.3415 5.50884 12.3153 5.50943 12.2599L5.53834 9.60201L5.53846 9.5904L5.54635 9.58206L6.35997 8.70923L6.36393 8.70556Z"
        fill="#00CFF2"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
    </svg>
  );
}

export function LeaveGameIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.5228 15.9831V14.531H13.0686V15.9831H14.5228Z"
        fill="#331A39"
      />
      <path
        d="M13.0685 15.9999V14.5479H11.6165V15.9999H13.0685Z"
        fill="#331A39"
      />
      <path
        d="M11.6166 15.9662V14.5142H10.1646V15.9662H11.6166Z"
        fill="#331A39"
      />
      <path
        d="M10.1645 15.9662V14.5142H8.7124V15.9662H10.1645Z"
        fill="#331A39"
      />
      <path
        d="M8.71232 15.9662V14.5142H7.26025V15.9662H8.71232Z"
        fill="#331A39"
      />
      <path
        d="M7.26031 15.9662V14.5142L5.81665 14.531V15.983L7.26031 15.9662Z"
        fill="#331A39"
      />
      <path
        d="M5.79142 15.9662V14.5142H4.33936V15.9662H5.79142Z"
        fill="#331A39"
      />
      <path
        d="M4.33927 15.9662V14.5142H2.88721V15.9662H4.33927Z"
        fill="#331A39"
      />
      <path d="M14.506 15.9662V14.5142H1.4353V15.9662H14.506Z" fill="#331A39" />
      <path
        d="M14.5396 14.5142H15.9916V13.0601H14.5396V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 14.5311H14.5311V13.0769H13.0769V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 14.5079H13.0771V13.0537H11.625V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 14.5079H11.6249V13.0537H10.1729V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 14.5079H10.1728V13.0537H8.7207V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 14.5079H8.72086V13.0537H7.2688V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 14.5079H7.26871V13.0537H5.81665V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 14.5079H5.81657V13.0537H4.3645V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9126 14.5311H4.36466V13.0769H2.9126V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 14.5311H2.91471V13.0769H1.46265V14.5311Z"
        fill="#EA7EBD"
      />
      <path d="M0 14.5311H1.45206V13.0769H0V14.5311Z" fill="#331A39" />
      <path d="M14.5396 13.06H15.9916V11.6079H14.5396V13.06Z" fill="#331A39" />
      <path
        d="M13.0769 13.0768H14.5311V11.6248H13.0769V13.0768Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 13.0539H11.6249V11.6018H10.1729V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 13.0539H10.1728V11.6018H8.7207V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 13.0539H8.72086V11.6018H7.2688V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 13.0539H7.26871V11.6018H5.81665V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 13.0539H5.81657V11.6018H4.3645V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 13.0768H2.91471V11.6248H1.46265V13.0768Z"
        fill="#EA7EBD"
      />
      <path d="M0 13.0768H1.45206V11.6248H0V13.0768Z" fill="#331A39" />
      <path
        d="M14.5396 11.608H15.9916V10.1538H14.5396V11.608Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 11.6248H14.5311V10.1707H13.0769V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 11.6016H13.0771V10.1475H11.625V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 11.6016H10.1728V10.1475H8.7207V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 11.6016H8.72086V10.1475H7.2688V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 11.6016H7.26871V10.1475H5.81665V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 11.6248H4.36661V10.1707H2.91455V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 11.6248H2.91471V10.1707H1.46265V11.6248Z"
        fill="#EA7EBD"
      />
      <path d="M0 11.6248H1.45206V10.1707H0V11.6248Z" fill="#331A39" />
      <path
        d="M14.5396 10.1537H15.9916V8.70166H14.5396V10.1537Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 10.1706H14.5311V8.71851H13.0769V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 10.1475H13.0771V8.69336H11.625V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 10.1475H11.6249V8.69336H10.1729V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 10.1475H8.72086V8.69336H7.2688V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 10.1706H5.81657V8.71851H4.3645V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 10.1706H4.36661V8.71851H2.91455V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 10.1706H2.91471V8.71851H1.46265V10.1706Z"
        fill="#EA7EBD"
      />
      <path d="M0 10.1706H1.45206V8.71851H0V10.1706Z" fill="#331A39" />
      <path
        d="M14.5059 8.70172H15.9579V7.24756H14.5059V8.70172Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 8.71857H14.5311V7.2644H13.0769V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 8.69327H13.0771V7.24121H11.625V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 8.69327H11.6249V7.24121H10.1729V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 8.69327H10.1728V7.24121H8.7207V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 8.71857H7.26871V7.2644H5.81665V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 8.71857H5.81657V7.2644H4.3645V8.71857Z" fill="#EA7EBD" />
      <path
        d="M2.91455 8.71857H4.36661V7.2644H2.91455V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 8.71857H2.91471V7.2644H1.46265V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M0 8.71857H1.45206V7.2644H0V8.71857Z" fill="#331A39" />
      <path
        d="M14.5059 7.24772H15.9579V5.79565H14.5059V7.24772Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 7.26432H14.5311V5.81226H13.0769V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 7.24127H13.0771V5.78711H11.625V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 7.24127H11.6249V5.78711H10.1729V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 7.24127H8.72086V5.78711H7.2688V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 7.26432H5.81657V5.81226H4.3645V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9147 7.26432H4.36676L4.36466 5.81226H2.9126L2.9147 7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 7.26432H2.91471V5.81226H1.46265V7.26432Z"
        fill="#EA7EBD"
      />
      <path d="M0 7.26432H1.45206V5.81226H0V7.26432Z" fill="#331A39" />
      <path
        d="M14.5059 5.79547H15.9579V4.34131H14.5059V5.79547Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 5.81232H14.5311V4.35815H13.0769V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 5.78702H13.0771V4.33496H11.625V5.78702Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 5.81232H10.1728V4.35815H8.7207V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 5.81232H8.72086V4.35815H7.2688V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.83984 5.81232H7.29191V4.35815H5.83984V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 5.81232H4.36661V4.35815H2.91455V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 5.81232H2.91471V4.35815H1.46265V5.81232Z"
        fill="#EA7EBD"
      />
      <path d="M0 5.81232H1.45206V4.35815H0V5.81232Z" fill="#331A39" />
      <path
        d="M14.5059 4.34147H15.9579V2.8894H14.5059V4.34147Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 4.35831H14.5311V2.90625H13.0769V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 4.35831H11.6249V2.90625H10.1729V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 4.35831H10.1728V2.90625H8.7207V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 4.35831H8.72086V2.90625H7.2688V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 4.35831H7.26871V2.90625H5.81665V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 4.35831H5.81657V2.90625H4.3645V4.35831Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 13.0768H13.0771V11.6248H11.625V13.0768Z" fill="white" />
      <path d="M2.9126 13.0768H4.36466V11.6248H2.9126V13.0768Z" fill="white" />
      <path
        d="M10.1729 11.6248H11.6249V10.1707H10.1729V11.6248Z"
        fill="white"
      />
      <path
        d="M4.36475 11.6248H5.81681V10.1707H4.36475V11.6248Z"
        fill="white"
      />
      <path d="M8.72095 10.1706H10.173V8.71851H8.72095V10.1706Z" fill="white" />
      <path
        d="M5.81665 10.1706H7.26871V8.71851H5.81665V10.1706Z"
        fill="white"
      />
      <path d="M7.2688 8.71857H8.72086V7.2644H7.2688V8.71857Z" fill="white" />
      <path d="M8.72095 7.26456H10.173V5.8125H8.72095V7.26456Z" fill="white" />
      <path d="M5.81665 7.26456H7.26871V5.8125H5.81665V7.26456Z" fill="white" />
      <path
        d="M10.1729 5.81232H11.6249V4.35815H10.1729V5.81232Z"
        fill="white"
      />
      <path
        d="M4.36475 5.81232H5.81681V4.35815H4.36475V5.81232Z"
        fill="white"
      />
      <path d="M11.625 4.35831H13.0771V2.90625H11.625V4.35831Z" fill="white" />
      <path d="M2.9126 4.35831H4.36466V2.90625H2.9126V4.35831Z" fill="white" />
      <path
        d="M1.46265 4.35831H2.91471V2.90625H1.46265V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 4.35831H1.46036V2.90625H0.00830078V4.35831Z"
        fill="#331A39"
      />
      <path
        d="M14.5312 14.5142H15.9833V1.4519H14.5312V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 2.90607H14.5311V1.4519H13.0769V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 2.90607H13.0771V1.4519H11.625V2.90607Z" fill="#E97BBB" />
      <path
        d="M10.1729 2.90607H11.6249V1.4519H10.1729V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M8.7207 2.90607H10.1728V1.4519H8.7207V2.90607Z" fill="#EA7EBD" />
      <path d="M7.2688 2.90607H8.72086V1.4519H7.2688V2.90607Z" fill="#EA7EBD" />
      <path
        d="M5.81665 2.90607H7.26871V1.4519H5.81665V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 2.90607H5.81657V1.4519H4.3645V2.90607Z" fill="#EA7EBD" />
      <path d="M2.9126 2.90607H4.36466V1.4519H2.9126V2.90607Z" fill="#EA7EBD" />
      <path
        d="M1.46265 2.90607H2.91471V1.4519H1.46265V2.90607Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 2.90607H1.46036V1.4519H0.00830078V2.90607Z"
        fill="#331A39"
      />
      <path d="M13.0769 0V1.45206H14.5311V0H13.0769Z" fill="#331A39" />
      <path d="M11.625 0V1.45206H13.0771V0H11.625Z" fill="#331A39" />
      <path d="M10.1729 0V1.45206H11.6249V0H10.1729Z" fill="#331A39" />
      <path d="M8.7207 0V1.45206H10.1728V0H8.7207Z" fill="#331A39" />
      <path
        d="M7.26245 0.00634766V1.45841H8.71451V0.00634766H7.26245Z"
        fill="#331A39"
      />
      <path
        d="M5.81665 0V1.45206L7.26241 1.45837V0.00630392L5.81665 0Z"
        fill="#331A39"
      />
      <path
        d="M4.3645 0V1.45206L5.81026 1.45837V0.00630392L4.3645 0Z"
        fill="#331A39"
      />
      <path d="M2.9126 0V1.45206H4.36466V0H2.9126Z" fill="#331A39" />
      <path d="M1.46265 0V1.45206H14.5396V0H1.46265Z" fill="#331A39" />
    </svg>
  );
}

export function Clock({
  className = "",
  style,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) {
  return (
    <span className={cn("w-20 h-20", className)} style={style} {...props}>
      <Image
        src="/images/icons/clock.svg"
        alt="Clock"
        fill
        style={{ objectFit: "contain" }}
        className="!relative w-full h-full"
        draggable={false}
        priority={false}
      />
    </span>
  );
}

export function ForwardMessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M14 5H12V9H6V11H4V17H6V15H12V19H14V17H16V15H18V13H20V11H18V9H16V7H14V5Z"
        fill="white"
      />
    </svg>
  );
}

export function MessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M22 2H2V16H4V4H20V16H12V18H10V20H8V16H2V18H6V22H10V20H12V18H22V2Z"
        fill="#1B8FF5"
      />
    </svg>
  );
}

export function CopyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M17.5 14.9998H5.83333V1.6665H12.5V3.33317H14.1667V4.99984H12.5V6.6665H14.1667V4.99984H15.8333V6.6665H17.5V14.9998ZM7.5 3.33317V13.3332H15.8333V8.33317H10.8333V3.33317H7.5ZM2.5 4.99984H4.16667V16.6665H14.1667V18.3332H2.5V4.99984Z"
        fill="#00CFF2"
      />
    </svg>
  );
}

export function TrophyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M10.75 13.7035V15.25H14.5V16.75H5.5V15.25H9.25V13.7035C7.80002 13.5207 6.46661 12.8149 5.5 11.7188C4.53339 10.6227 4.00002 9.21146 4 7.75V3.25H16V7.75C16 9.21146 15.4666 10.6227 14.5 11.7188C13.5334 12.8149 12.2 13.5207 10.75 13.7035ZM1.75 4.75H3.25V7.75H1.75V4.75ZM16.75 4.75H18.25V7.75H16.75V4.75Z"
        fill={props.color || "#34C759"}
      />
    </svg>
  );
}

export function UsdcIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="16"
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <g clipPath="url(#clip0_268_39833)">
        <path
          d="M7.87865 15.5198C12.0512 15.5198 15.4081 12.1629 15.4081 7.99035C15.4081 3.81778 12.0512 0.460938 7.87865 0.460938C3.70608 0.460938 0.349243 3.81778 0.349243 7.99035C0.349243 12.1629 3.70608 15.5198 7.87865 15.5198Z"
          fill="#2775CA"
        />
        <path
          d="M9.94932 9.1832C9.94932 8.08518 9.29051 7.70871 7.97288 7.55187C7.03172 7.42635 6.84348 7.1754 6.84348 6.73613C6.84348 6.29686 7.15723 6.01458 7.78465 6.01458C8.34934 6.01458 8.66309 6.20282 8.81993 6.67341C8.85132 6.76753 8.94544 6.83025 9.03956 6.83025H9.54146C9.66697 6.83025 9.76109 6.73613 9.76109 6.61069V6.57929C9.63558 5.88907 9.07088 5.35576 8.34934 5.29304V4.54009C8.34934 4.41458 8.25523 4.32046 8.09839 4.28906H7.62781C7.5023 4.28906 7.40818 4.38318 7.37678 4.54009V5.26164C6.43562 5.38716 5.8396 6.01458 5.8396 6.79893C5.8396 7.83422 6.46702 8.24202 7.78465 8.39893C8.66309 8.55577 8.94544 8.74401 8.94544 9.246C8.94544 9.74798 8.50618 10.0931 7.91016 10.0931C7.09443 10.0931 6.81209 9.74791 6.71797 9.27732C6.68665 9.15188 6.59253 9.08908 6.49841 9.08908H5.96504C5.8396 9.08908 5.74548 9.1832 5.74548 9.30872V9.34011C5.87092 10.1244 6.3729 10.6891 7.40818 10.846V11.5989C7.40818 11.7244 7.5023 11.8185 7.65913 11.8499H8.12971C8.25523 11.8499 8.34934 11.7558 8.38074 11.5989V10.846C9.32191 10.6891 9.94932 10.0303 9.94932 9.1832Z"
          fill="white"
        />
        <path
          d="M6.27942 12.4778C3.83236 11.5994 2.57743 8.86997 3.48729 6.45423C3.95787 5.13658 4.99317 4.13269 6.27942 3.6621C6.40493 3.59938 6.46765 3.50526 6.46765 3.34835V2.90916C6.46765 2.78364 6.40493 2.68953 6.27942 2.6582C6.24802 2.6582 6.1853 2.6582 6.1539 2.68953C3.17354 3.6307 1.54214 6.79938 2.48331 9.77975C3.04802 11.5366 4.39706 12.8856 6.1539 13.4503C6.27942 13.5131 6.40493 13.4503 6.43626 13.3248C6.46765 13.2935 6.46765 13.2621 6.46765 13.1994V12.7601C6.46765 12.666 6.37354 12.5406 6.27942 12.4778ZM9.60493 2.68953C9.47942 2.62681 9.3539 2.68953 9.32258 2.81504C9.29118 2.84644 9.29118 2.87776 9.29118 2.94056V3.37975C9.29118 3.50526 9.3853 3.6307 9.47942 3.6935C11.9265 4.57188 13.1814 7.30129 12.2715 9.71703C11.801 11.0347 10.7657 12.0386 9.47942 12.5092C9.3539 12.5719 9.29118 12.666 9.29118 12.8229V13.2621C9.29118 13.3876 9.3539 13.4817 9.47942 13.5131C9.51082 13.5131 9.57354 13.5131 9.60493 13.4817C12.5853 12.5406 14.2167 9.37188 13.2755 6.39151C12.7108 4.60328 11.3304 3.25423 9.60493 2.68953Z"
          fill="white"
        />
      </g>
      <defs>
        <clipPath id="clip0_268_39833">
          <rect width="16" height="16" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
}

export function SoundOnIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="18"
      height="18"
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M8.25 1.5H6.75V3H5.25V4.5H3.75V6H0.75V12H3.75V13.5H5.25V15H6.75V16.5H8.25V1.5ZM5.25 13.5V12H3.75V10.5H2.25V7.5H3.75V6H5.25V4.5H6.75V13.5H5.25ZM9.75 7.5H11.25V10.5H9.75V7.5ZM15.75 3H14.25V1.5H9.75V3H14.25V4.5H15.75V13.5H14.25V15H9.75V16.5H14.25V15H15.75V13.5H17.25V4.5H15.75V3ZM14.25 6H12.75V4.5H9.75V6H12.75V12H9.75V13.5H12.75V12H14.25V6Z"
        fill="white"
      />
    </svg>
  );
}

export function SoundOffIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="18"
      height="18"
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M9.75 1.5H8.25V3H6.75V4.5H5.25V6H2.25V12H5.25V13.5H6.75V15H8.25V16.5H9.75V1.5ZM6.75 13.5V12H5.25V10.5H3.75V7.5H5.25V6H6.75V4.5H8.25V13.5H6.75ZM14.25 8.41725H12.75V6.91725H11.25V8.41725H12.75V9.91725H11.25V11.4172H12.75V9.91725H14.25V11.4172H15.75V9.91725H14.25V8.41725ZM14.25 8.41725H15.75V6.91725H14.25V8.41725Z"
        fill="white"
      />
    </svg>
  );
}

export function TrendIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M4 2H2V4H4V6H2V8H4V6H6V8H8V6H6V4H8V2H6V4H4V2ZM16 4V20H22V4H16ZM18 6H20V18H18V6ZM9 10V20H15V10H9ZM11 18V12H13V18H11ZM8 14V20H2V14H8ZM6 18V16H4V18H6Z"
        fill="#14B985"
      />
    </svg>
  );
}

export function FlashIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={24}
      height={24}
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M12 1H14V9H22V13H20V11H12V5H10V3H12V1ZM8 7V5H10V7H8ZM6 9V7H8V9H6ZM4 11V9H6V11H4ZM14 19V21H12V23H10V15H2V11H4V13H12V19H14ZM16 17V19H14V17H16ZM18 15V17H16V15H18ZM18 15H20V13H18V15Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function SendIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14 5H12V9H6V11H4V17H6V15H12V19H14V17H16V15H18V13H20V11H18V9H16V7H14V5Z"
        fill="white"
      />
    </svg>
  );
}

export function ChatIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M22 2H2V16H4V4H20V16H12V18H10V20H8V16H2V18H6V22H10V20H12V18H22V2Z"
        fill="#1B8FF5"
      />
    </svg>
  );
}

--- File: ./src/components/CardStack.tsx ---
"use client";

import { useMemo, useRef, type PointerEventHandler } from "react";
import Image from "next/image";
import { motion, useMotionValue, useTransform } from "framer-motion";
import { cn } from "@/lib/utils";

interface CardImage {
  src: string;
  alt?: string;
}

interface CardStackProps {
  images: CardImage[];
  size?: number | string;
  borderColor?: string;
  rotations?: number[];
  interactive?: boolean;
  maxCards?: number;
  ariaLabel?: string;
  className?: string;
}

const DEFAULT_ROTATIONS = [-9, 6, -4, 7];

export function CardStack({
  images,
  size = "clamp(32px, 6vw, 48px)",
  borderColor = "#FFFFFF",
  rotations = DEFAULT_ROTATIONS,
  interactive = false,
  maxCards = 4,
  ariaLabel = "Image card stack",
  className,
}: CardStackProps) {
  const x = useMotionValue(0);
  const tilt = useTransform(x, [-100, 100], [-4, 4]);
  const containerRef = useRef<HTMLDivElement>(null);

  const handleMove: PointerEventHandler<HTMLDivElement> = (e) => {
    if (!interactive || !containerRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    x.set(e.clientX - (rect.left + rect.width / 2));
  };

  const handleLeave = () => {
    if (interactive) {
      x.set(0);
    }
  };
  const cardsToDisplay = useMemo(
    () => images.slice(0, maxCards),
    [images, maxCards]
  );

  const styleVariables = {
    "--card-size": typeof size === "number" ? `${size}px` : size,
    "--card-border": `calc(var(--card-size) * 0.07)`,
    "--card-radius": `calc(var(--card-size) * 0.14)`,
    "--card-overlap": `calc(var(--card-size) * 0.52)`,
  } as React.CSSProperties;

  return (
    <motion.div
      ref={containerRef}
      onPointerMove={handleMove}
      onPointerLeave={handleLeave}
      aria-label={ariaLabel}
      className={cn("relative flex items-center justify-center", className)}
      style={styleVariables}
    >
      {cardsToDisplay.map((img, i) => {
        const staticRotation = rotations[i % rotations.length] ?? 0;

        return (
          <motion.div
            key={img.src + i}
            style={{
              width: "var(--card-size)",
              height: "var(--card-size)",
              marginLeft: i === 0 ? 0 : `calc(-1 * var(--card-overlap))`,
              borderColor: borderColor,
              borderWidth: "var(--card-border)",
              borderRadius: "var(--card-radius)",
              rotate: interactive ? 0 : `${staticRotation}deg`,
              zIndex: 10 + i,
            }}
            className="shrink-0 border bg-muted overflow-hidden relative"
            whileHover={interactive ? { y: -3, scale: 1.02 } : undefined}
            transition={{ type: "spring", stiffness: 320, damping: 22 }}
          >
            <motion.div
              style={{
                width: "100%",
                height: "100%",
                rotate: interactive ? tilt : 0,
              }}
              className="w-full h-full"
            >
              <Image
                src={img.src}
                alt={img.alt ?? `Card ${i + 1}`}
                fill
                sizes="var(--card-size)"
                className="object-cover"
                priority={i < 2}
              />
            </motion.div>
          </motion.div>
        );
      })}
    </motion.div>
  );
}

--- File: ./src/components/onboarding/onboarding-carousel.tsx ---
"use client";

import { useState } from "react";
import { AnimatePresence, motion, Variants } from "framer-motion";
import { OnboardingSlide } from "./onboarding-slide";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { cn } from "@/lib/utils";

interface Slide {
  icon: string;
  title: string;
  description: string;
}

const slides: Slide[] = [
  {
    icon: "/images/illustrations/waffle-ticket.png",
    title: "Buy a Waffle",
    description:
      "Buy your ticket, play the game, and share in the prize pool with other winners",
  },
  {
    icon: "/images/illustrations/money-bag.png",
    title: "Win Big",
    description: "The faster you connect the dots, the bigger your share",
  },
  {
    icon: "/images/illustrations/crown.png",
    title: "Take Your Crown",
    description: "Recognize the images, climb the leaderboard. EZ",
  },
];

interface OnboardingCarouselProps {
  onComplete: () => void;
}

// Animation variants for Framer Motion
const slideVariants: Variants = {
  initial: (direction: number) => ({
    x: direction > 0 ? "100%" : "-100%",
    opacity: 0,
  }),
  animate: {
    x: 0,
    opacity: 1,
    transition: { type: "spring", stiffness: 150, damping: 25 },
  },
  exit: (direction: number) => ({
    x: direction < 0 ? "100%" : "-100%",
    opacity: 0,
    transition: { ease: "easeInOut", duration: 0.3 },
  }),
};

/**
 * Renders a simple carousel for onboarding steps.
 * Manages the current slide index and transitions between slides.
 */
export function OnboardingCarousel({ onComplete }: OnboardingCarouselProps) {
  const [currentSlideIndex, setCurrentSlideIndex] = useState(0);
  const [direction, setDirection] = useState(1);

  // Handler for the next/complete button
  const handleNext = () => {
    setDirection(1);
    if (currentSlideIndex < slides.length - 1) {
      setCurrentSlideIndex(currentSlideIndex + 1);
    } else {
      onComplete();
    }
  };

  const currentSlide = slides[currentSlideIndex];

  return (
    <div className="flex flex-col h-full overflow-hidden">
      <div className="flex-1 flex items-center justify-center relative">
        <AnimatePresence initial={false} custom={direction} mode="wait">
          <motion.div
            key={currentSlideIndex}
            custom={direction}
            variants={slideVariants}
            initial="initial"
            animate="animate"
            exit="exit"
            className="absolute inset-0 flex items-center justify-center"
          >
            <OnboardingSlide
              icon={currentSlide.icon}
              title={currentSlide.title}
              description={currentSlide.description}
            />
          </motion.div>
        </AnimatePresence>
      </div>
      {/* Controls Area (Dots and Button) */}
      <div className="p-6 space-y-4 mb-10 shrink-0">
        <div className="flex justify-center gap-2 mb-4">
          {slides.map((_, index) => (
            <button
              key={index}
              onClick={() => {}}
              className={cn(
                "h-2 w-2 rounded-full transition-colors duration-200",
                index === currentSlideIndex
                  ? "bg-white"
                  : "bg-white/30 hover:bg-white/50"
              )}
              aria-label={`Go to slide ${index + 1}`}
              disabled={true}
            />
          ))}
        </div>
        <FancyBorderButton onClick={handleNext} className="w-full">
          {currentSlideIndex < slides.length - 1 ? "Next" : "Let's Go"}
        </FancyBorderButton>
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/onboarding-overlay.tsx ---
"use client";

import Image from "next/image";
import { OnboardingCarousel } from "./onboarding-carousel";
import { cn } from "@/lib/utils";

interface OnboardingOverlayProps {
  onComplete: () => void;
}

export function OnboardingOverlay({ onComplete }: OnboardingOverlayProps) {
  return (
    <div
      className={cn("fixed inset-0 z-81 flex flex-col pt-2", "bg-[#191919]")}
      role="dialog"
      aria-modal="true"
      aria-labelledby="onboarding-title"
    >
      <div className="flex shrink-0 items-center justify-center p-2">
        <h1 id="onboarding-title" className="sr-only">
          Onboarding
        </h1>
        <div className="relative w-56 h-20 ">
          <Image
            src="/logo-onboarding.png"
            alt="Waffles Logo"
            fill
            sizes="(max-width: 640px) 224px, (max-width: 768px) 288px, 384px"
            priority
            className="object-contain"
          />
        </div>
      </div>
      <div className="flex-1 overflow-hidden">
        <OnboardingCarousel onComplete={onComplete} />
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/onboarding-gate.tsx ---
"use client";

import { useOnboarding } from "@/hooks/useOnboarding";
import { OnboardingOverlay } from "./onboarding-overlay";
import { SplashScreen } from "@/components/ui/SplashScreen";
import type { ReactNode } from "react";

interface OnboardingGateProps {
  children: ReactNode;
}

/**
 * A client-side component that acts as a gate for the onboarding process.
 * It uses the `useOnboarding` hook to determine if the onboarding overlay
 * should be displayed based on localStorage status. It renders a loading state
 * until the status is checked, then either shows the overlay or the main app content.
 */
export function OnboardingGate({ children }: OnboardingGateProps) {
  const { isReady, shouldShowOnboarding, completeOnboarding } = useOnboarding();

  if (!isReady) {
    return <SplashScreen />;
  }

  return (
    <>
      {children}
      {shouldShowOnboarding && (
        <OnboardingOverlay onComplete={completeOnboarding} />
      )}
    </>
  );
}

--- File: ./src/components/onboarding/onboarding-slide.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";

interface OnboardingSlideProps {
  icon: string;
  title: string;
  description: string;
  className?: string;
}

export function OnboardingSlide({
  icon,
  title,
  description,
  className,
}: OnboardingSlideProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-between text-center px-8 py-8",
        className
      )}
    >
      <div className="mb-8 animate-in-right relative w-48 h-48">
        <Image src={icon} alt={title} fill className="object-contain" />
      </div>
      <h2 className="text-3xl font-bold mb-4 text-balance animate-in-right uppercase tracking-wider">
        {title}
      </h2>
      <p className="text-lg text-center font-display text-muted max-w-md text-pretty animate-in-right">
        {description}
      </p>
    </div>
  );
}

--- File: ./src/components/inputs/PixelInput.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

export type PixelInputProps = React.InputHTMLAttributes<HTMLInputElement>;

/**
 * A styled input component with a "pixelated" or retro aesthetic,
 * using theme colors and fonts.
 */
const PixelInput = React.forwardRef<HTMLInputElement, PixelInputProps>(
  ({ className, type = "text", ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "h-14 w-full rounded-lg border-none px-4 py-2",
          "text-center text-xl tracking-wider",
          "bg-[color:var(--surface-tint)]",
          "text-[color:var(--text-primary)] caret-primary",
          "placeholder:text-[color:var(--text-muted)]",
          "font-input",
          "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2",
          "focus-visible:ring-[color:var(--accent-secondary)]",
          "focus-visible:ring-offset-[color:var(--background)]",
          "disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);

// Assign display name for DevTools
PixelInput.displayName = "PixelInput";

export { PixelInput };

--- File: ./src/hooks/useMiniUser.ts ---
"use client";

import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useAccount } from "wagmi";

export interface MiniUser {
  fid: number | null;
  username: string | null;
  pfpUrl: string | null;
  wallet: `0x${string}` | null;
  isConnected: boolean;
  isMiniAppReady: boolean;
}

const mockUser: MiniUser = {
  fid: 755074,
  username: "chukwukauba",
  pfpUrl:
    "https://imagedelivery.net/BXluQx4ige9GuW0Ia56BHw/3d4b3ff7-3ed7-4522-125a-9419a85ada00/original",
  wallet: "0xMockAddress1234567890abcdef1234567890abcd",
  isConnected: true,
  isMiniAppReady: true,
};

export function useMiniUser(): MiniUser {
  const { context: miniKitContext, isMiniAppReady } = useMiniKit();
  const { address, isConnected } = useAccount();

  const fid = miniKitContext?.user?.fid ?? null;
  const username = miniKitContext?.user?.username ?? null;
  const pfpUrl = miniKitContext?.user?.pfpUrl ?? null;
  const wallet = address ?? null;

  const realUser: MiniUser = {
    fid,
    username,
    pfpUrl,
    wallet,
    isConnected,
    isMiniAppReady,
  };

  if (process.env.NODE_ENV === "production" && !realUser.fid) {
    // Clear, visible warning in production if no FID

    console.warn(
      "[useMiniUser] WARNING: User FID is required in production but was not found. MiniApp context:",
      miniKitContext
    );
  }

  const useMock = process.env.NODE_ENV !== "production" && !realUser.fid;

  return useMock ? mockUser : realUser;
}

--- File: ./src/hooks/useVibration.ts ---
"use client";

import { useCallback } from "react";

export function useVibration() {
  const vibrate = useCallback((pattern: number | number[] = 80) => {
    if (typeof window !== "undefined" && "vibrate" in navigator) {
      try {
        navigator.vibrate(pattern);
      } catch (error) {
        console.warn("Vibration failed:", error);
      }
    }
  }, []);

  return { vibrate };
}

--- File: ./src/hooks/useOnboarding.ts ---
"use client";

import { useCallback, useEffect, useState } from "react";
import { useMiniUser } from "@/hooks/useMiniUser";
import { syncUserAction } from "@/actions/onboarding";

const ONBOARDING_STORAGE_KEY = "waffles:onboarded:v6.5";

export function useOnboarding() {
  const [isOnboarded, setIsOnboarded] = useState<boolean>(true);
  const [isReady, setIsReady] = useState<boolean>(false);
  const { fid, username, pfpUrl, wallet } = useMiniUser();

  useEffect(() => {
    let status = true;
    try {
      if (typeof window !== "undefined") {
        const stored = window.localStorage.getItem(ONBOARDING_STORAGE_KEY);
        status = stored === "true";
      }
    } catch (err) {
      console.warn("Could not access localStorage for onboarding status:", err);
      status = false;
    } finally {
      setIsOnboarded(status);
      setIsReady(true);
    }
  }, []);

  const completeOnboarding = useCallback(async () => {
    try {
      if (typeof window !== "undefined") {
        window.localStorage.setItem(ONBOARDING_STORAGE_KEY, "true");
      }
    } catch (err) {
      console.warn("Failed to save onboarding status to localStorage:", err);
    }

    if (fid) {
      console.log("Syncing user profile after onboarding:", {
        fid,
        username,
        pfpUrl,
        wallet,
      });
      try {
        const result = await syncUserAction({
          fid: fid,
          username: username,
          pfpUrl: pfpUrl,
          wallet: wallet,
        });

        if (!result.success) {
          console.error("User sync failed during onboarding:", result.error);
        } else {
          console.log(
            "User sync successful:",
            result.user,
            "Referral:",
            result.referral.code
          );
        }
      } catch (err) {
        console.error("Unexpected error during user sync:", err);
        throw err;
      }
    } else {
      console.warn("Cannot sync user profile: Missing FID.");
    }

    setIsOnboarded(true);
  }, [fid, username, pfpUrl, wallet]);

  return {
    isReady,
    isOnboarded,
    shouldShowOnboarding: isReady && !isOnboarded,
    completeOnboarding,
  };
}

--- File: ./src/hooks/useLocalStorage.ts ---
"use client";

import { useState, useEffect, useCallback } from "react";

type SetValue<T> = (value: T | ((val: T) => T)) => void;

// Custom event to broadcast storage changes within the same tab
const IN_APP_STORAGE_EVENT = "onLocalStorageChange";

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, SetValue<T>, () => void] {
  // A function to read the value from localStorage
  const readValue = useCallback((): T => {
    // Prevent SSR errors
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? (JSON.parse(item) as T) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  }, [key, initialValue]);

  // Use useState, initializing with the value from localStorage
  const [storedValue, setStoredValue] = useState<T>(readValue);

  // This is the setter function that components will use
  const setValue: SetValue<T> = useCallback(
    (value) => {
      // Prevent SSR errors
      if (typeof window === "undefined") {
        console.warn("Tried to set localStorage on the server");
        return;
      }

      try {
        // Allow value to be a function, just like a useState setter
        const newValue = value instanceof Function ? value(storedValue) : value;

        // Save to localStorage
        window.localStorage.setItem(key, JSON.stringify(newValue));
        // Save to state
        setStoredValue(newValue);

        // Dispatch a custom event to notify other hooks *in the same tab*
        window.dispatchEvent(
          new CustomEvent(IN_APP_STORAGE_EVENT, { detail: { key, newValue } })
        );
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  // This is the remove function
  const remove = useCallback(() => {
    if (typeof window === "undefined") return;

    try {
      window.localStorage.removeItem(key);
      setStoredValue(initialValue);
      window.dispatchEvent(
        new CustomEvent(IN_APP_STORAGE_EVENT, {
          detail: { key, newValue: initialValue },
        })
      );
    } catch (error) {
      console.warn(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Effect to listen for changes
  useEffect(() => {
    // Handler for the 'storage' event (other tabs)
    const handleStorageChange = (event: StorageEvent) => {
      if (event.key === key) {
        setStoredValue(readValue());
      }
    };

    // Handler for the custom event (same tab)
    const handleInAppChange = (event: Event) => {
      const { key: changedKey } = (event as CustomEvent).detail;
      if (changedKey === key) {
        setStoredValue(readValue());
      }
    };

    // Add listeners
    window.addEventListener("storage", handleStorageChange);
    window.addEventListener(IN_APP_STORAGE_EVENT, handleInAppChange);

    // Remove listeners on cleanup
    return () => {
      window.removeEventListener("storage", handleStorageChange);
      window.removeEventListener(IN_APP_STORAGE_EVENT, handleInAppChange);
    };
  }, [key, readValue]);

  return [storedValue, setValue, remove];
}

--- File: ./src/hooks/useCountdown.ts ---
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";

interface UseCountdownOptions {
  durationSeconds?: number;
  target?: Date | number;
  autoStart?: boolean;
  intervalMs?: number;
  onTick?: (millisecondsLeft: number) => void;
  onComplete?: () => void;
}

interface UseCountdownResult {
  millisecondsLeft: number;
  secondsLeft: number;
  isRunning: boolean;
  start: () => void;
  pause: () => void;
  reset: (opts?: { durationSeconds?: number; target?: Date | number }) => void;
  setTarget: (target: Date | number) => void;
}

/**
 * A high-accuracy countdown hook that avoids drift by calculating remaining time
 * based on a fixed end timestamp (`endAt`). Supports relative durations or absolute targets.
 */
export function useCountdown(
  options: UseCountdownOptions = {} //
): UseCountdownResult {
  const {
    durationSeconds,
    target,
    autoStart = true,
    intervalMs = 1000,
    onTick,
    onComplete,
  } = options;

  const [endAt, setEndAt] = useState<number>(() => {
    if (typeof target !== "undefined") {
      return target instanceof Date ? target.getTime() : target;
    }
    if (typeof durationSeconds === "number") {
      return Date.now() + Math.max(0, durationSeconds) * 1000;
    }
    return 0;
  });

  const [isRunning, setIsRunning] = useState<boolean>(
    Boolean(autoStart && (durationSeconds != null || target != null))
  );

  const intervalRef = useRef<ReturnType<typeof setInterval> | null>(null);

  const [now, setNow] = useState<number>(() => Date.now());

  const millisecondsLeft = useMemo(
    () => Math.max(0, endAt - now),
    [endAt, now]
  );
  const secondsLeft = useMemo(
    () => Math.ceil(millisecondsLeft / 1000),
    [millisecondsLeft]
  );

  const clearTimer = useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  const tick = useCallback(() => {
    const currentTime = Date.now();
    const msRemaining = Math.max(0, endAt - currentTime);

    setNow(currentTime);
    onTick?.(msRemaining);

    if (msRemaining <= 0) {
      clearTimer();
      setIsRunning(false);
      onComplete?.();
    }
  }, [endAt, onTick, onComplete, clearTimer]);

  const start = useCallback(() => {
    if (isRunning || !endAt || endAt <= Date.now()) return;

    setIsRunning(true);
    tick();
    intervalRef.current = setInterval(tick, Math.max(16, intervalMs));
  }, [isRunning, endAt, intervalMs, tick]);

  const pause = useCallback(() => {
    if (!isRunning) return;

    clearTimer();
    setIsRunning(false);
    const remainingMs = Math.max(0, endAt - Date.now());
    setEndAt(Date.now() + remainingMs);
  }, [isRunning, clearTimer, endAt]);

  const reset = useCallback(
    (opts?: { durationSeconds?: number; target?: Date | number }) => {
      clearTimer();

      const nextTargetOpt = opts?.target ?? target;
      const nextDurationOpt = opts?.durationSeconds ?? durationSeconds;

      let nextEndAt = 0;
      if (typeof nextTargetOpt !== "undefined") {
        nextEndAt =
          nextTargetOpt instanceof Date
            ? nextTargetOpt.getTime()
            : nextTargetOpt;
      } else if (typeof nextDurationOpt === "number") {
        nextEndAt = Date.now() + Math.max(0, nextDurationOpt) * 1000;
      }

      setEndAt(nextEndAt);
      const shouldAutoStart = Boolean(autoStart && nextEndAt > 0);
      setIsRunning(shouldAutoStart);
      setNow(Date.now());

      if (shouldAutoStart) {
        tick();
        intervalRef.current = setInterval(tick, Math.max(16, intervalMs));
      }
    },
    [autoStart, clearTimer, durationSeconds, intervalMs, target, tick]
  );

  const setTarget = useCallback(
    (newTarget: Date | number) => {
      //
      clearTimer();
      const nextEndAt =
        newTarget instanceof Date ? newTarget.getTime() : newTarget;
      setEndAt(nextEndAt);
      const shouldAutoStart = Boolean(autoStart && nextEndAt > 0);
      setIsRunning(shouldAutoStart);
      setNow(Date.now());

      if (shouldAutoStart) {
        tick();
        intervalRef.current = setInterval(tick, Math.max(16, intervalMs));
      }
    },
    [autoStart, clearTimer, intervalMs, tick]
  );

  useEffect(() => {
    if (autoStart && (durationSeconds != null || target != null)) {
      start();
    }
    return clearTimer;
  }, [autoStart, durationSeconds, target, start, clearTimer]);

  // --- Return Hook API ---
  return {
    millisecondsLeft,
    secondsLeft,
    isRunning,
    start,
    pause,
    reset,
    setTarget,
  };
}

--- File: ./src/hooks/useTimer.ts ---
"use client";

import { useCallback, useEffect, useRef, useState } from "react";

interface UseTimerOptions {
  duration: number;
  autoStart?: boolean;
  onComplete?: () => void;
}

export interface UseTimerResult {
  isRunning: boolean;
  elapsed: number;
  remaining: number;
  duration: number;
  percent: number;
  formatted: string;
  start: () => void;
  pause: () => void;
  resume: () => void;
  reset: () => void;
}

export function useTimer({
  duration,
  autoStart = false,
  onComplete,
}: UseTimerOptions): UseTimerResult {
  const [isRunning, setIsRunning] = useState(autoStart);
  const [elapsed, setElapsed] = useState(0);

  const startRef = useRef<number | null>(null);
  const rafRef = useRef<number | null>(null);
  const completedRef = useRef(false);

  const tick = useCallback(() => {
    if (!isRunning) return;

    const now = performance.now();
    if (startRef.current === null) {
      startRef.current = now;
    }

    const currentElapsed = elapsed + (now - startRef.current);
    const clampedElapsed = Math.min(currentElapsed, duration);

    setElapsed(clampedElapsed);
    startRef.current = now;

    if (clampedElapsed >= duration && !completedRef.current) {
      completedRef.current = true;
      setIsRunning(false);
      onComplete?.();
      return;
    }

    rafRef.current = requestAnimationFrame(tick);
  }, [elapsed, duration, isRunning, onComplete]);

  const start = useCallback(() => {
    if (isRunning && !completedRef.current) return;
    completedRef.current = false;
    startRef.current = null;
    setElapsed(0);
    setIsRunning(true);
  }, [isRunning]);

  const pause = useCallback(() => {
    if (!isRunning) return;
    setIsRunning(false);
  }, [isRunning]);

  const resume = useCallback(() => {
    if (isRunning || elapsed >= duration) return;
    setIsRunning(true);
    startRef.current = null;
  }, [isRunning, elapsed, duration]);

  const reset = useCallback(() => {
    setIsRunning(false);
    setElapsed(0);
    startRef.current = null;
    completedRef.current = false;
  }, []);

  useEffect(() => {
    if (!isRunning) {
      if (rafRef.current !== null) {
        cancelAnimationFrame(rafRef.current);
        rafRef.current = null;
      }
      return;
    }

    startRef.current = null;
    completedRef.current = false;
    rafRef.current = requestAnimationFrame(tick);

    return () => {
      if (rafRef.current !== null) {
        cancelAnimationFrame(rafRef.current);
        rafRef.current = null;
      }
    };
  }, [isRunning, tick]);

  useEffect(() => {
    if (autoStart) {
      start();
    }
  }, [autoStart, start]);

  const remaining = Math.max(duration - elapsed, 0);
  const percent = duration > 0 ? Math.min(elapsed / duration, 1) : 0;
  const totalSeconds = Math.ceil(remaining / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  const formatted = `${String(minutes).padStart(2, "0")}:${String(
    seconds
  ).padStart(2, "0")}`;

  return {
    isRunning,
    elapsed,
    remaining,
    duration,
    percent,
    formatted,
    start,
    pause,
    resume,
    reset,
  };
}

--- File: ./src/actions/admin.ts ---
"use server";

import { prisma } from "@/lib/db";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import type { Game } from "@prisma/client";

const createGameSchema = z
  .object({
    name: z.string().trim().min(1, "Game name cannot be empty."),
    description: z.string().trim().optional().nullable(),
    startTime: z.coerce.date({ message: "Invalid start date/time format." }),
    endTime: z.coerce.date({ message: "Invalid end date/time format." }),
  })
  .refine((data) => data.endTime > data.startTime, {
    message: "End time must be after start time.",
    path: ["endTime"],
  });

export type CreateGameResult =
  | { success: true; game: Game }
  | { success: false; error: string };

export async function createGameAction(
  input: z.input<typeof createGameSchema>
): Promise<CreateGameResult> {
  const validation = createGameSchema.safeParse(input);
  if (!validation.success) {
    console.warn(
      "createGameAction validation failed:",
      validation.error.message
    );
    return { success: false, error: validation.error.message };
  }
  const { name, description, startTime, endTime } = validation.data;

  try {
    const newGame = await prisma.game.create({
      data: {
        name,
        description,
        startTime,
        endTime,
      },
    });

    revalidatePath("/admin/games");
    revalidatePath("/api/game");

    return { success: true, game: newGame };
  } catch (error) {
    console.error("createGameAction Error:", error);
    return {
      success: false,
      error: "Failed to create game due to a server error.",
    };
  }
}

--- File: ./src/actions/chat.ts ---
"use server";

import { prisma } from "@/lib/db";
import { z } from "zod";
import { revalidateTag } from "next/cache";

// Utility function: Remove or redact URLs from a string.
function sanitizeMessage(input: string): string {
  // This will remove any http(s):// or www. links and any URL-looking words
  // Replace URLs with "[link removed]"
  return input.replace(
    // Basic regex that covers most normal URL forms
    /((https?:\/\/|www\.)[^\s]+)/gi,
    "[link removed]"
  );
}

const sendMessageSchema = z.object({
  gameId: z.number().int().positive("Invalid Game ID."),
  message: z
    .string()
    .trim()
    .min(1, "Message cannot be empty.")
    .max(500, "Message exceeds 500 characters."),
  fid: z.number().int().positive("Invalid FID format."),
});

export type SendMessageResult =
  | { success: true; messageId: number }
  | { success: false; error: string };

export async function sendMessageAction(
  input: z.input<typeof sendMessageSchema>
): Promise<SendMessageResult> {
  const validation = sendMessageSchema.safeParse(input);
  if (!validation.success) {
    const firstError = validation.error.issues[0]?.message || "Invalid input.";
    console.warn(
      "sendMessageAction validation failed:",
      validation.error.issues
    );
    return { success: false, error: firstError };
  }

  const { gameId, message, fid } = validation.data;

  try {
    const user = await prisma.user.findUnique({
      where: { fid },
      select: { id: true },
    });
    if (!user) {
      return { success: false, error: "User not found." };
    }

    const gameExists = await prisma.game.findUnique({
      where: { id: gameId },
      select: { id: true },
    });
    if (!gameExists) {
      return { success: false, error: "Game not found." };
    }

    // Sanitize message to remove links
    const sanitizedMessage = sanitizeMessage(message);

    const chat = await prisma.chat.create({
      data: {
        userId: user.id,
        gameId,
        message: sanitizedMessage,
      },
      select: { id: true },
    });

    // Add revalidation for chat updates related to this game
    revalidateTag(`game-chat-${gameId}`);

    return { success: true, messageId: chat.id };
  } catch (error) {
    console.error("sendMessageAction Error:", error);
    return {
      success: false,
      error: "Failed to send message due to a server error.",
    };
  }
}

--- File: ./src/actions/invite.ts ---
"use server";

import { prisma } from "@/lib/db";
import { z } from "zod";

interface ValidationSuccess {
  valid: true;
  message?: string;
  inviterId: number;
  inviteeId: number;
  code: string;
}

interface ValidationError {
  valid: false;
  error: string;
}

export type ValidateReferralResult = ValidationSuccess | ValidationError;

const actionSchema = z.object({
  code: z.string().length(6, "Code must be 6 characters."),
  fid: z.number().int().positive("Invalid FID format."),
});

export async function validateReferralAction(
  prevState: ValidateReferralResult | null,
  formData: FormData
): Promise<ValidateReferralResult> {
  const rawCode = formData.get("code");
  const rawFid = formData.get("fid");

  const validation = actionSchema.safeParse({
    code: rawCode,
    fid: rawFid,
  });

  if (!validation.success) {
    const firstError = validation.error.issues[0]?.message ?? "Invalid input.";
    return { valid: false, error: firstError };
  }

  const { code, fid } = validation.data;

  try {
    const invitee = await prisma.user.findUnique({
      where: { fid },
    });
    if (!invitee) {
      return {
        valid: false,
        error: "User not found. Complete onboarding first.",
      };
    }

    const referral = await prisma.referral.findUnique({
      where: { code },
    });
    if (!referral) {
      return { valid: false, error: "Invalid code." };
    }

    if (referral.inviterId === invitee.id) {
      return { valid: false, error: "Cannot use your own code." };
    }

    const duplicate = await prisma.referral.findFirst({
      where: {
        inviterId: referral.inviterId,
        inviteeId: invitee.id,
      },
    });
    if (duplicate) {
      if (duplicate.code === code) {
        return {
          valid: true,
          message: "Code already validated.",
          inviterId: referral.inviterId,
          inviteeId: invitee.id,
          code: duplicate.code,
        };
      } else {
        return {
          valid: false,
          error: "Referral already established with this inviter.",
        };
      }
    }

    if (referral.inviteeId && referral.inviteeId !== invitee.id) {
      return { valid: false, error: "Code already redeemed by another user." };
    }

    let finalReferral = referral;
    if (!referral.inviteeId) {
      finalReferral = await prisma.referral.update({
        where: { code },
        data: { inviteeId: invitee.id, acceptedAt: new Date() },
      });
    }

    return {
      valid: true,
      inviterId: finalReferral.inviterId,
      inviteeId: finalReferral.inviteeId!,
      code: finalReferral.code,
    };
  } catch (err) {
    console.error("[VALIDATE_REFERRAL_ACTION_ERROR]", err);
    return { valid: false, error: "Validation failed due to a server error." };
  }
}

const REFERRAL_CODE_LENGTH = 6;
const MAX_CODE_GENERATION_RETRIES = 10;

function generateCode(length = REFERRAL_CODE_LENGTH): string {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const bytes = new Uint8Array(length);
  crypto.getRandomValues(bytes);
  let code = "";
  for (let i = 0; i < length; i++) {
    code += alphabet[bytes[i] % alphabet.length];
  }
  return code;
}

const inputSchema = z.object({
  fid: z.number().int().positive("Invalid FID format."),
});

export type ReferralCodeResult =
  | {
      success: true;
      code: string;
      inviterId: number;
      inviteeId?: number | null;
    }
  | { success: false; error: string };

export async function getOrCreateReferralCodeAction(
  fid: number | null | undefined
): Promise<ReferralCodeResult> {
  const validation = inputSchema.safeParse({ fid });
  if (!validation.success) {
    const firstError =
      validation.error.message || "Invalid Farcaster ID provided.";
    return { success: false, error: firstError };
  }
  const validatedFid = validation.data.fid;

  try {
    const inviter = await prisma.user.findUnique({
      where: { fid: validatedFid },
      select: { id: true },
    });

    if (!inviter) {
      return { success: false, error: "Inviter user not found." };
    }
    const inviterId = inviter.id;

    const existingReferral = await prisma.referral.findFirst({
      where: { inviterId },
      orderBy: { createdAt: "asc" },
    });

    if (existingReferral) {
      return {
        success: true,
        code: existingReferral.code,
        inviterId: existingReferral.inviterId,
        inviteeId: existingReferral.inviteeId,
      };
    }

    let newCode: string | null = null;
    for (let tries = 0; tries < MAX_CODE_GENERATION_RETRIES; tries++) {
      const potentialCode = generateCode();
      const collision = await prisma.referral.findUnique({
        where: { code: potentialCode },
      });
      if (!collision) {
        newCode = potentialCode;
        break;
      }
    } //

    if (!newCode) {
      console.error(
        `Failed to generate unique referral code for inviterId ${inviterId} after ${MAX_CODE_GENERATION_RETRIES} tries.`
      );
      return {
        success: false,
        error: "Failed to generate a unique referral code. Please try again.",
      };
    }

    const newReferral = await prisma.referral.create({
      data: {
        code: newCode,
        inviterId,
      },
    });

    return {
      success: true,
      code: newReferral.code,
      inviterId: newReferral.inviterId,
      inviteeId: newReferral.inviteeId,
    };
  } catch (err) {
    console.error("Error in getOrCreateReferralCodeAction:", err);
    return {
      success: false,
      error: "An unexpected error occurred while processing the referral code.",
    };
  }
}

--- File: ./src/actions/profile.ts ---
"use server";

import { prisma } from "@/lib/db";
import { z } from "zod";
import { revalidatePath, revalidateTag } from "next/cache";
import type { User } from "@prisma/client";

const updateProfileSchema = z
  .object({
    fid: z.number().int().positive("Invalid FID format."),
    name: z
      .string()
      .trim()
      .min(1, "Name cannot be empty.")
      .optional()
      .nullable(),
    wallet: z.string().trim().optional().nullable(),
    imageUrl: z.string().url("Invalid image URL.").optional().nullable(),
  })
  .refine(
    (data) =>
      data.name !== undefined ||
      data.wallet !== undefined ||
      data.imageUrl !== undefined,
    {
      message:
        "At least one field (name, wallet, or imageUrl) must be provided for update.",
    }
  );

type UpdatedUserProfile = Pick<
  User,
  "id" | "name" | "wallet" | "imageUrl" | "fid"
>;

// Result type for the action
export type UpdateProfileResult =
  | { success: true; user: UpdatedUserProfile }
  | { success: false; error: string | z.ZodIssue[] };

/**
 * Server Action to update a user's profile information (name, wallet, imageUrl).
 */
export async function updateProfileAction(
  input: z.input<typeof updateProfileSchema>
): Promise<UpdateProfileResult> {
  const validation = updateProfileSchema.safeParse(input);
  if (!validation.success) {
    console.warn(
      "updateProfileAction validation failed:",
      validation.error.flatten()
    );
    return { success: false, error: validation.error.issues };
  }
  const { fid, ...updateData } = validation.data;

  if (Object.keys(updateData).length === 0) {
    return { success: false, error: "No update data provided." };
  }
  const filteredUpdateData = Object.entries(updateData).reduce(
    (acc, [key, value]) => {
      if (value !== undefined) {
        acc[key as keyof typeof updateData] = value;
      }
      return acc;
    },
    {} as Partial<typeof updateData>
  );

  try {
    const user = await prisma.user.findUnique({
      where: { fid },
      select: { id: true },
    });

    if (!user) {
      return { success: false, error: "User not found." };
    }

    const updatedUser = await prisma.user.update({
      where: { id: user.id },
      data: filteredUpdateData,
      select: {
        id: true,
        name: true,
        wallet: true,
        imageUrl: true,
        fid: true,
      },
    });

    revalidateTag(`profile_${fid}`);
    revalidatePath("/profile");

    return { success: true, user: updatedUser };
  } catch (error) {
    console.error("updateProfileAction Error:", error);
    return {
      success: false,
      error: "Failed to update profile due to a server error.",
    };
  }
}

--- File: ./src/actions/onboarding.ts ---
"use server";

import { prisma } from "@/lib/db";
import { z } from "zod";
import { cookies } from "next/headers";
import { revalidatePath } from "next/cache"; // Use revalidatePath if revalidateTag is not sufficient

const REFERRAL_CODE_LENGTH = 6;
const MAX_CODE_GENERATION_RETRIES = 10;

function generateReferralCode(): string {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const bytes = new Uint8Array(REFERRAL_CODE_LENGTH);
  crypto.getRandomValues(bytes);
  let code = "";
  for (let i = 0; i < REFERRAL_CODE_LENGTH; i++) {
    code += alphabet[bytes[i] % alphabet.length];
  }
  return code;
}

async function ensureReferral(
  inviterId: number
): Promise<{ code: string; existed: boolean; id: number }> {
  const existing = await prisma.referral.findFirst({
    where: { inviterId },
    orderBy: { createdAt: "asc" },
    select: { code: true, id: true },
  });
  if (existing) return { ...existing, existed: true };

  for (let attempt = 0; attempt < MAX_CODE_GENERATION_RETRIES; attempt++) {
    const code = generateReferralCode();
    try {
      const newReferral = await prisma.referral.create({
        data: {
          code,
          inviterId,
        },
        select: { code: true, id: true },
      });
      // After creating a new referral, revalidate the lobby/upcoming games path
      revalidatePath("/"); // Invalidate the home/lobby page
      return { ...newReferral, existed: false };
    } catch (err) {
      if (
        typeof err === "object" &&
        err !== null &&
        "code" in err &&
        err.code === "P2002"
      ) {
        console.warn(
          `Referral code collision on attempt ${attempt + 1}, retrying...`
        );
        continue;
      }
      throw err;
    }
  }
  throw new Error(
    `Failed to generate unique referral code for inviterId ${inviterId} after ${MAX_CODE_GENERATION_RETRIES} attempts.`
  );
}

const syncUserSchema = z.object({
  fid: z.number().int().positive("FID must be a positive integer."),
  username: z
    .string()
    .trim()
    .min(1, "Username cannot be empty.")
    .optional()
    .nullable(),
  pfpUrl: z.string().url("Invalid PFP URL.").optional().nullable(),
  wallet: z.string().trim().optional().nullable(),
});

type SyncedUser = {
  id: number;
  fid: number;
  name: string | null;
  imageUrl: string | null;
  wallet: string | null;
};
type SyncedReferral = {
  id: number;
  code: string;
};

export type SyncUserResult =
  | { success: true; user: SyncedUser; referral: SyncedReferral }
  | { success: false; error: string };

export async function syncUserAction(
  input: z.input<typeof syncUserSchema>
): Promise<SyncUserResult> {
  const validation = syncUserSchema.safeParse(input);
  if (!validation.success) {
    const firstError = validation.error.message || "Invalid input.";
    console.warn("syncUserAction validation failed:", validation.error.message);
    return { success: false, error: firstError };
  }
  const data = validation.data;

  try {
    const user = await prisma.user.upsert({
      where: { fid: data.fid },
      update: {
        name: data.username,
        imageUrl: data.pfpUrl,
        wallet: data.wallet,
      },
      create: {
        fid: data.fid,
        name: data.username,
        imageUrl: data.pfpUrl,
        wallet: data.wallet,
      },
      select: {
        id: true,
        fid: true,
        name: true,
        imageUrl: true,
        wallet: true,
      },
    });

    // Revalidate main lobby and user profile/game details on onboarding/sync
    revalidatePath("/"); // Home/lobby path
    // Optionally: user dashboard/profile (if you have a path, e.g., `/user/${user.fid}`)
    // If there's a page like `/user/[fid]`, you could: revalidatePath(`/user/${user.fid}`);

    // Set the user's fid in a cookie
    try {
      const cookieStore = await cookies();
      cookieStore.set("fid", String(user.fid), {
        path: "/",
        sameSite: "lax",
        maxAge: 60 * 60 * 24 * 30, // 30 days in seconds
        secure: process.env.NODE_ENV === "production",
      });
    } catch (cookieErr) {
      console.warn(`Failed to set fid cookie:`, cookieErr);
      throw new Error(`Failed to set fid cookie: ${cookieErr}`);
    }

    const referral = await ensureReferral(user.id);

    return {
      success: true,
      user: {
        id: user.id,
        fid: user.fid,
        name: user.name,
        imageUrl: user.imageUrl,
        wallet: user.wallet,
      },
      referral: { id: referral.id, code: referral.code },
    };
  } catch (err) {
    console.error("syncUserAction Error:", err);
    return {
      success: false,
      error:
        err instanceof Error
          ? err.message
          : "User sync failed due to a server error.",
    };
  }
}

--- File: ./src/actions/game.ts ---
"use server";

import { prisma } from "@/lib/db";
import { calculateScore } from "@/lib/scoring";
import { z } from "zod";
import { revalidatePath } from "next/cache";
import { fetchGameById } from "@/lib/data";
import { Prisma } from "@prisma/client";

// Paths used for revalidation
const gamePath = (gameId: number) => `/game/${gameId}`;
const lobbyPath = "/lobby";
const leaderboardCurrentPath = (gameId: number) =>
  `/leaderboard/current/${gameId}`;
const leaderboardAllTimePath = "/leaderboard/allTime";
const userProfileGamePath = (fid: number, gameId: number) =>
  `/profile/${fid}/game/${gameId}`;

const submitAnswerSchema = z.object({
  fid: z.number().int().positive("Invalid FID format."),
  gameId: z.number().int().positive("Invalid Game ID."),
  questionId: z.number().int().positive("Invalid Question ID."),
  selected: z.string().nullable(),
  timeTaken: z.number().nonnegative("Time taken cannot be negative."),
});

export type SubmitAnswerResult =
  | { success: true; correct: boolean; points: number }
  | { success: false; error: string };

export async function submitAnswerAction(
  input: z.input<typeof submitAnswerSchema>
): Promise<SubmitAnswerResult> {
  const validation = submitAnswerSchema.safeParse(input);
  if (!validation.success) {
    const firstError = validation.error.message || "Invalid input.";
    console.warn(
      "submitAnswerAction validation failed:",
      validation.error.message
    );
    return { success: false, error: firstError };
  }
  const { fid, gameId, questionId, selected, timeTaken } = validation.data;

  try {
    const user = await prisma.user.findUnique({
      where: { fid },
      select: { id: true },
    });
    if (!user) {
      return { success: false, error: "User not found." };
    }

    const [question, game] = await Promise.all([
      prisma.question.findUnique({
        where: { id: questionId },
        select: { correctAnswer: true },
      }),
      prisma.game.findUnique({
        where: { id: gameId },
        include: { config: true },
      }),
    ]);

    if (!question) {
      return { success: false, error: "Question not found." };
    }
    if (!game) {
      return { success: false, error: "Game not found." };
    }
    if (!game.config) {
      return { success: false, error: "Game configuration missing." };
    }

    const roundLimit = game.config.roundTimeLimit ?? 15;
    const maxTime =
      Number.isFinite(roundLimit) && roundLimit > 0 ? roundLimit : 15;
    const sanitizedTime = Math.min(Math.max(0, timeTaken), maxTime);
    const correct = selected !== null && selected === question.correctAnswer;
    const newPoints = correct ? calculateScore(sanitizedTime, maxTime) : 0;

    await prisma.$transaction(async (tx) => {
      const previousAnswer = await tx.answer.findUnique({
        where: {
          userId_gameId_questionId: { userId: user.id, gameId, questionId },
        },
        select: { isCorrect: true, timeTaken: true },
      });

      const previousPoints =
        previousAnswer?.isCorrect && Number.isFinite(previousAnswer.timeTaken)
          ? calculateScore(previousAnswer.timeTaken!, maxTime)
          : 0;

      await tx.answer.upsert({
        where: {
          userId_gameId_questionId: { userId: user.id, gameId, questionId },
        },
        update: {
          selected: selected ?? (undefined as string | undefined),
          isCorrect: correct,
          timeTaken: sanitizedTime,
        },
        create: {
          userId: user.id,
          gameId,
          questionId,
          selected: selected ?? "",
          isCorrect: correct,
          timeTaken: sanitizedTime,
        },
      });

      // Find the existing total Score record for this user/game
      const existingScore = await tx.score.findUnique({
        where: { userId_gameId: { userId: user.id, gameId } },
        select: { points: true },
      });

      const pointsDelta = newPoints - previousPoints;

      if (existingScore) {
        const nextTotalPoints = Math.max(0, existingScore.points + pointsDelta);
        await tx.score.update({
          where: { userId_gameId: { userId: user.id, gameId } },
          data: { points: nextTotalPoints },
        });
      } else {
        await tx.score.create({
          data: { userId: user.id, gameId, points: newPoints },
        });
      }
    });

    // Revalidate all relevant paths after an answer is submitted
    // Leaderboards
    revalidatePath(leaderboardCurrentPath(gameId));
    revalidatePath(leaderboardAllTimePath);
    // Lobby page
    revalidatePath(lobbyPath);
    // Game details page
    revalidatePath(gamePath(gameId));
    // User's profile/game interaction (if any)
    revalidatePath(userProfileGamePath(fid, gameId));

    return { success: true, correct, points: newPoints };
  } catch (err) {
    console.error("submitAnswerAction Error:", err);
    return {
      success: false,
      error: "Failed to submit answer due to a server error.",
    };
  }
}

// Define schema for joining a game
const joinGameSchema = z.object({
  fid: z.number().int().positive("Invalid FID format."),
  gameId: z.number().int().positive("Invalid Game ID."),
});

export type JoinGameResult =
  | { success: true }
  | { success: false; error: string };

/**
 * Records that a user has joined (started playing) a game.
 * - User must exist.
 * - Game must exist.
 * - User can only join the same game once (unique constraint).
 * - Uses GameParticipant model in Prisma.
 * - Leverages fetchGameById from @data.ts for game lookup.
 */
export async function joinGameAction(
  input: z.input<typeof joinGameSchema>
): Promise<JoinGameResult> {
  const validation = joinGameSchema.safeParse(input);
  if (!validation.success) {
    const firstError = validation.error.message || "Invalid input.";
    console.warn("joinGameAction validation failed:", validation.error.message);
    return { success: false, error: firstError };
  }
  const { fid, gameId } = validation.data;

  try {
    // Find the user by FID
    const user = await prisma.user.findUnique({
      where: { fid },
      select: { id: true },
    });
    if (!user) {
      return { success: false, error: "User not found." };
    }

    // Use cache-backed fetchGameById from @data.ts
    const game = await fetchGameById(gameId);
    if (!game) {
      return { success: false, error: "Game not found." };
    }

    // Create GameParticipant if it doesn't already exist (idempotent)
    await prisma.gameParticipant.upsert({
      where: {
        gameId_userId: {
          gameId,
          userId: user.id,
        },
      },
      update: {},
      create: {
        gameId,
        userId: user.id,
      },
    });

    // Revalidate relevant pages
    revalidatePath(gamePath(gameId));
    revalidatePath(lobbyPath);
    revalidatePath(userProfileGamePath(fid, gameId));
    revalidatePath(leaderboardCurrentPath(gameId));
    revalidatePath(leaderboardAllTimePath);

    return { success: true };
  } catch (err: unknown) {
    if (
      err instanceof Prisma.PrismaClientKnownRequestError &&
      err.code === "P2002"
    ) {
      // Still revalidate relevant pages in upsert duplicate case
      revalidatePath(gamePath(gameId));
      revalidatePath(lobbyPath);
      revalidatePath(userProfileGamePath(fid, gameId));
      revalidatePath(leaderboardCurrentPath(gameId));
      revalidatePath(leaderboardAllTimePath);
      return { success: true };
    }
    console.error("joinGameAction Error:", err);
    return {
      success: false,
      error: "Failed to join game due to a server error.",
    };
  }
}
// LeaveGame schema and handler for removing user participation from a game (deleting GameParticipant)

const leaveGameSchema = z.object({
  fid: z.number().int().positive("Invalid FID."),
  gameId: z.number().int().positive("Invalid gameId."),
});

export type LeaveGameResult =
  | { success: true }
  | { success: false; error: string };

/**
 * Removes the GameParticipant record (user's participation) for a game.
 * - Does NOT revoke ticket or answers; only removes participation.
 * - Safe to call multiple times (idempotent).
 * - Triggers revalidation of all views where participation matters.
 */
export async function leaveGameAction(
  input: z.input<typeof leaveGameSchema>
): Promise<LeaveGameResult> {
  const validated = leaveGameSchema.safeParse(input);
  if (!validated.success) {
    const firstError = validated.error.message || "Invalid input.";
    console.warn("leaveGameAction validation failed:", validated.error.message);
    return { success: false, error: firstError };
  }
  const { fid, gameId } = validated.data;

  try {
    // Find user by FID
    const user = await prisma.user.findUnique({
      where: { fid },
      select: { id: true },
    });
    if (!user) {
      return { success: false, error: "User not found." };
    }

    // Ensure game exists (for correct path revalidation and safety)
    const game = await fetchGameById(gameId);
    if (!game) {
      return { success: false, error: "Game not found." };
    }

    // Remove participation (may delete 0 or 1 record: idempotent)
    await prisma.gameParticipant.deleteMany({
      where: { userId: user.id, gameId },
    });

    // Revalidate all relevant paths
    revalidatePath(gamePath(gameId));
    revalidatePath(lobbyPath);
    revalidatePath(userProfileGamePath(fid, gameId));
    revalidatePath(leaderboardCurrentPath(gameId));
    revalidatePath(leaderboardAllTimePath);

    return { success: true };
  } catch (err: unknown) {
    if (
      err instanceof Prisma.PrismaClientKnownRequestError &&
      (err.code === "P2025" || err.code === "P2001")
    ) {
      // No record exists, treat as successful (idempotency)
      revalidatePath(gamePath(gameId));
      revalidatePath(lobbyPath);
      revalidatePath(userProfileGamePath(fid, gameId));
      revalidatePath(leaderboardCurrentPath(gameId));
      revalidatePath(leaderboardAllTimePath);
      return { success: true };
    }
    console.error("leaveGameAction Error:", err);
    return {
      success: false,
      error: "Failed to leave game due to a server error.",
    };
  }
}

--- File: ./src/actions/ticket.ts ---
"use server";

import { prisma } from "@/lib/db";
import { randomBytes } from "crypto";
import { revalidateTag } from "next/cache"; // Import for revalidation
import { z } from "zod";
import type { Ticket } from "@prisma/client"; // Import Prisma type

// Schema for input validation
const purchaseSchema = z.object({
  fid: z.number().int().positive("Invalid FID format."),
  gameId: z.number().int().positive("Invalid Game ID."),
  txHash: z.string().optional().nullable(), // Optional transaction hash
});

export type PurchaseResult =
  | { success: true; ticket: Ticket; alreadyExists?: boolean }
  | {
      success: false;
      error: string;
      alreadyExists?: boolean;
      existingTicket?: Ticket;
    };

/**
 * Server Action to create or confirm a ticket purchase for a user and game.
 */
export async function purchaseTicketAction(
  prevState: PurchaseResult | null, // Not used actively here, but required by useFormState if used
  formData: FormData
): Promise<PurchaseResult> {
  const rawData = {
    fid: Number(formData.get("fid")),
    gameId: Number(formData.get("gameId")), // Ensure conversion
    txHash: formData.get("txHash"),
  };

  const validation = purchaseSchema.safeParse(rawData);

  if (!validation.success) {
    const firstError = validation.error.issues[0]?.message || "Invalid input.";
    return { success: false, error: firstError };
  }

  const { fid, gameId, txHash } = validation.data;

  try {
    // 1. Find User
    const user = await prisma.user.findUnique({
      where: { fid: fid },
    });
    if (!user) {
      return { success: false, error: "User not found. Please sync profile." };
    }
    const userId = user.id;

    // 2. Find Game & Config
    const game = await prisma.game.findUnique({
      where: { id: gameId },
      include: { config: true },
    });
    if (!game) {
      return { success: false, error: "Game not found." };
    }
    if (!game.config) {
      return { success: false, error: "Game configuration is missing." };
    }

    // 3. Check for Existing Ticket (Idempotency)
    const existingTicket = await prisma.ticket.findUnique({
      where: { gameId_userId: { gameId, userId } },
    });
    if (existingTicket) {
      // If txHash is provided and different, update it? Or just return existing.
      // For simplicity, return existing ticket as success.
      console.log("Ticket already exists for user", userId, "and game", gameId);
      // Optionally update txHash if needed and different
      if (txHash && existingTicket.txHash !== txHash) {
        const updatedTicket = await prisma.ticket.update({
          where: { id: existingTicket.id },
          data: { txHash: txHash, status: "confirmed" }, // Update status too
        });
        revalidateTag(`ticket_${fid}_${gameId}`); // Revalidate SWR cache
        revalidateTag("lobby_stats");
        return { success: true, ticket: updatedTicket };
      }
      return { success: true, ticket: existingTicket, alreadyExists: true };
    }

    // 4. Generate Unique Code
    let code: string;
    for (let attempt = 0; attempt < 10; attempt++) {
      code = randomBytes(6).toString("hex").toUpperCase(); // Increased length for less collision chance
      if (!(await prisma.ticket.findUnique({ where: { code } }))) {
        break; // Found unique code
      }
      if (attempt === 9) {
        return {
          success: false,
          error: "Could not generate unique ticket code.",
        };
      }
    }

    // 5. Determine Status
    const status =
      typeof txHash === "string" && txHash.length > 0 ? "confirmed" : "pending";

    // 6. Create Ticket
    const newTicket = await prisma.ticket.create({
      data: {
        userId: userId,
        gameId: gameId,
        amountUSDC: game.config.ticketPrice, // Use price from game config
        code: code!, // Code is guaranteed to be assigned here
        txHash: txHash ?? null,
        status: status,
      },
    });

    // 7. Revalidate relevant data caches
    revalidateTag(`ticket_${fid}_${gameId}`); // Invalidate specific ticket cache for SWR
    revalidateTag("lobby_stats"); // Invalidate general lobby stats

    return { success: true, ticket: newTicket };
  } catch (e) {
    console.error("Purchase Ticket Action Error:", e);
    // Handle potential Prisma unique constraint violation if race condition occurs
    if (
      typeof e === "object" &&
      e !== null &&
      "code" in e &&
      e.code === "P2002"
    ) {
      // Fetch and return the existing ticket instead of erroring
      const user = await prisma.user.findUnique({
        where: { fid: fid },
      });
      if (user) {
        const existing = await prisma.ticket.findUnique({
          where: { gameId_userId: { gameId, userId: user.id } },
        });
        if (existing)
          return { success: true, ticket: existing, alreadyExists: true };
      }
      return {
        success: false,
        error: "Ticket already exists (race condition).",
      };
    }
    return { success: false, error: "Internal Server Error during purchase." };
  }
}

--- File: ./src/actions/waitlist.ts ---
"use server";

import { prisma } from "@/lib/db";
import { revalidatePath } from "next/cache";

/**
 * Adds a user to the waitlist.
 */
export async function joinWaitlistAction(
  formData: FormData
): Promise<{ ok: boolean; already?: boolean; error?: string }> {
  const fid = formData.get("fid");
  const referrerFid = formData.get("referrerFid");

  console.log("fid", fid);
  console.log("referrerFid", referrerFid);

  if (!fid) {
    return { ok: false, error: "FID is required." };
  }

  try {
    const user = await prisma.user.findUnique({ where: { fid: Number(fid) } });
    if (!user) {
      // Potentially create user if not found, depending on app logic.
      // For now, assume user exists from onboarding/sync.
      // user = await prisma.user.create({ data: { fid: fid } });
      return { ok: false, error: "User not found. Please sync profile first." };
    }

    const existing = await prisma.waitlist.findUnique({
      where: { userId: user.id },
    });
    if (existing) {
      return { ok: true, already: true };
    }

    let referredByUser = null;
    if (referrerFid !== null && referrerFid !== fid) {
      referredByUser = await prisma.user.findUnique({
        where: { fid: Number(referrerFid) },
      });
      if (referredByUser) {
        await prisma.waitlist.updateMany({
          where: { userId: referredByUser.id },
          data: { invites: { increment: 1 } },
        });
      }
    }

    await prisma.waitlist.create({
      data: {
        userId: user.id,
        referredBy: referredByUser?.id || null,
      },
    });

    revalidatePath("/waitlist");
    return { ok: true };
  } catch (error) {
    console.error("Error joining waitlist:", error);
    return { ok: false, error: "An unexpected error occurred." };
  }
}

--- File: ./src/lib/fetcher.ts ---
/**
 * Generic fetcher function for SWR.
 * Usage: useSWR(key, fetcher)
 */
export async function fetcher<T>(
  input: string | Request,
  init?: RequestInit
): Promise<T> {
  const res = await fetch(input, { cache: "no-store", ...init });

  if (!res.ok) {
    let errMsg = `Fetcher error: ${res.status} ${res.statusText}`;
    try {
      // Try to parse error body if possible
      const contentType = res.headers.get("content-type");
      if (contentType && contentType.includes("application/json")) {
        const errorData = await res.json();
        if (
          errorData &&
          typeof errorData === "object" &&
          "error" in errorData
        ) {
          errMsg += `: ${errorData.error}`;
        }
      } else {
        const text = await res.text();
        if (text) {
          errMsg += `: ${text}`;
        }
      }
    } catch {
      // ignore parsing errors, show generic message
    }
    throw new Error(errMsg);
  }

  // Defensive: check content type (throw if not JSON)
  const contentType = res.headers.get("content-type");
  if (!contentType || !contentType.includes("application/json")) {
    throw new Error("Fetcher error: Response is not JSON.");
  }

  try {
    return (await res.json()) as T;
  } catch (err) {
    throw new Error("Fetcher error: Failed to parse JSON response.");
  }
}

--- File: ./src/lib/data.ts ---
import { prisma } from "@/lib/db";
import { HydratedGame, HydratedUser } from "@/state/types";

/* ------------------------------------------------------ */
/*        1. UPCOMING / ACTIVE GAMES (NO PARAMS)          */
/* ------------------------------------------------------ */

export const fetchUpcomingGames = async (): Promise<HydratedGame[]> => {
  const now = new Date();
  const games = await prisma.game.findMany({
    where: { endTime: { gt: now } },
    include: {
      config: true,
      questions: { orderBy: { id: "asc" } },
      _count: { select: { tickets: true } },
    },
    orderBy: { startTime: "asc" },
    take: 1,
  });
  return games.map((g) => ({ ...g, config: g.config! }));
};

/* ------------------------------------------------------ */
/*                2. GAME DETAILS (BY ID)                 */
/* ------------------------------------------------------ */

export const fetchGameById = async (
  gameId: number
): Promise<HydratedGame | null> => {
  const game = await prisma.game.findUnique({
    where: { id: gameId },
    include: {
      config: true,
      questions: {
        orderBy: { id: "asc" },
      },
      _count: { select: { tickets: true } },
    },
  });
  if (!game?.config) return null;
  return { ...game, config: game.config };
};

/* ------------------------------------------------------ */
/*         3. USER DATA FOR LOBBY (PARAMETERIZED)         */
/* ------------------------------------------------------ */

export const fetchUserWithGameDetailsAndReferral = async (
  userFid: number,
  gameId: number
): Promise<HydratedUser | null> => {
  return prisma.user.findUnique({
    where: { fid: userFid },
    include: {
      tickets: { where: { gameId } },
      scores: { where: { gameId } },
      answers: { where: { gameId } },
      gameParticipants: { where: { gameId } },
      referrals: {
        take: 1,
        select: {
          id: true,
          code: true,
          inviterId: true,
          acceptedAt: true,
          createdAt: true,
          inviter: {
            select: {
              id: true,
              fid: true,
              name: true,
              imageUrl: true,
              wallet: true,
            },
          },
        },
      },
    },
  }) as Promise<HydratedUser | null>;
};
/* ------------------------------------------------------ */
/*            4. FETCH GAME CHAT MESSAGES                 */
/* ------------------------------------------------------ */

/**
 * Fetches the latest chat messages for a game, ordered by creation.
 * Can specify a limit (default 24).
 *
 * Each message includes user (fid, id, name, imageUrl).
 */
export const fetchChatMessages = async (gameId: number, limit: number = 24) => {
  return prisma.chat.findMany({
    where: { gameId },
    orderBy: { createdAt: "asc" },
    take: limit,
    include: {
      user: {
        select: {
          id: true,
          fid: true,
          name: true,
          imageUrl: true,
        },
      },
    },
  });
};

--- File: ./src/lib/supabaseClient.ts ---
// src/lib/supabaseClient.ts
import { createClient } from "@supabase/supabase-js"; // Supabase client library
import { env } from "./env"; // Import environment variables

// --- Initialize Supabase Client ---
// Create a single Supabase client instance using environment variables.
// This instance can be imported and used throughout the application (both server and client).
export const supabase = createClient(
  env.nextPublicSupabaseUrl, // Supabase project URL (public) [cite: 1586]
  env.nextPublicSupabaseAnonKey, // Supabase anonymous key (public) [cite: 1586]
  {
    // Optional: Configure Realtime settings if used
    realtime: {
      params: {
        // eventsPerSecond: 10 // Example: Increase event rate if needed
      },
    },
    // Optional: Configure auth settings if using Supabase Auth
    // auth: {
    //     persistSession: true, // Default: true
    //     autoRefreshToken: true, // Default: true
    // }
  }
);

// Note: For server-side operations requiring admin privileges,
// you would typically create a separate service role client using
// process.env.SUPABASE_SERVICE_ROLE_KEY (do NOT expose this key to the client).
// Example (DO NOT USE IN CLIENT COMPONENTS):
// import { createClient as createAdminClient } from '@supabase/supabase-js';
// const supabaseAdmin = createAdminClient(
//   process.env.NEXT_PUBLIC_SUPABASE_URL!,
//   process.env.SUPABASE_SERVICE_ROLE_KEY!
// );

--- File: ./src/lib/utils.ts ---
import { HydratedGame } from "@/state/types";
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}

export function getWeekdayString(
  dayIdx: number,
  options?: {
    locale?: string;
    format?: "long" | "short" | "narrow";
    emphasizeToday?: boolean;
  }
): string {
  if (
    typeof dayIdx !== "number" ||
    !Number.isFinite(dayIdx) ||
    dayIdx < 0 ||
    dayIdx > 6
  ) {
    throw new RangeError(
      "dayIdx must be an integer between 0 (Sunday) and 6 (Saturday)"
    );
  }
  const {
    locale = "en-US",
    format = "long",
    emphasizeToday = true,
  } = options || {};
  const refSunday = new Date(Date.UTC(2023, 6, 2 + dayIdx));
  const weekdayStr = new Intl.DateTimeFormat(locale, {
    weekday: format,
  }).format(refSunday);

  const now = new Date();
  const todayIdx = now.getDay();
  if (emphasizeToday && dayIdx === todayIdx) {
    let todayWord = "";
    try {
      todayWord = new Intl.RelativeTimeFormat(locale, {
        numeric: "auto",
      }).format(0, "day");
    } catch {
      todayWord = "Today";
    }
    if (todayWord && todayWord.toLowerCase() !== weekdayStr.toLowerCase()) {
      return `${todayWord} (${weekdayStr})`;
    }
    return `Today (${weekdayStr})`;
  }

  return weekdayStr;
}

export function calculatePrizePool(game: HydratedGame) {
  return (
    game._count.tickets * (game.config?.ticketPrice ?? 0) +
    (game.config?.additionPrizePool ?? 0)
  );
}
/**
 * Check if a question number is a snapshot of the total number of questions for a round.
 * @param x - The current question number.
 * @param totalQuestions - The total number of questions.
 * @returns True if x is a snapshot of totalQuestions, false otherwise.
 */
export function isSnapshot(x: number, totalQuestions: number): boolean {
  const step = Math.floor(totalQuestions / 3);
  return x === step || x === step * 2 || x === totalQuestions;
}

/**
 * Formats milliseconds into a MM:SS string.
 * @param ms - The number of milliseconds.
 * @returns A string in "MM:SS" format.
 */
export const formatMsToMMSS = (ms: number): string => {
  const totalSeconds = Math.ceil(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
    2,
    "0"
  )}`;
};

--- File: ./src/lib/constants.ts ---
export const PALETTES = [
  { bg: "#FFE8BA", border: "#FFC931", text: "#151515" },
  { bg: "#EFD6FF", border: "#B45CFF", text: "#151515" },
  { bg: "#D7EBFF", border: "#2E7DFF", text: "#151515" },
  { bg: "#D8FFF1", border: "#18DCA5", text: "#151515" },
] as const;

--- File: ./src/lib/scoring.ts ---
/**
 * Calculates the score awarded for a correct answer based on the time taken
 * relative to the maximum time allowed for the question.
 *
 * The scoring formula gives a base amount and adds bonus points for speed.
 * - Max score (timeTaken = 0) = 300 + 2700 = 3000
 * - Min score (timeTaken = maxTime) = 300 + 0 = 300
 * - Score decreases linearly as timeTaken increases.
 *
 * @param timeTaken - Time the user took to answer, in seconds (non-negative).
 * @param maxTime - Maximum time allowed for the question, in seconds (must be positive).
 * @returns The calculated score (integer, non-negative). Returns 0 if maxTime is invalid.
 */
export function calculateScore(timeTaken: number, maxTime: number): number {
  // Validate maxTime to prevent division by zero or negative results
  if (!Number.isFinite(maxTime) || maxTime <= 0) {
    console.warn(
      `calculateScore: Invalid maxTime (${maxTime}). Returning 0 points.`
    );
    return 0; // Return 0 if maxTime is invalid
  }

  // Clamp timeTaken to be within [0, maxTime]
  const clampedTime = Math.min(Math.max(0, timeTaken), maxTime); // [cite: 1602]

  // Calculate the speed ratio (1.0 for instant answer, 0.0 for max time)
  const speedRatio = (maxTime - clampedTime) / maxTime; // [cite: 1602]

  // Calculate base points + bonus points based on speed
  const basePoints = 300; // Minimum points for a correct answer
  const speedBonus = 2700; // Maximum bonus points for speed
  const calculatedScore = basePoints + speedRatio * speedBonus; // [cite: 1603]

  // Return the rounded, non-negative score
  return Math.max(0, Math.round(calculatedScore)); // [cite: 1603]
}

/**
 * Determines if a chosen item matches a target item in the final round.
 * NOTE: This is a placeholder implementation. Replace with actual matching logic.
 *
 * @param choiceId - The ID of the item the user chose.
 * @param targetId - The ID of the item the user tried to match against.
 * @returns True if the items are considered a match, false otherwise.
 */
export function isMatch(
  choiceId: number | string | null | undefined,
  targetId: number | string | null | undefined
): boolean {
  // Basic check: Ensure both IDs are provided and valid numbers/strings before comparing
  if (choiceId == null || targetId == null) {
    return false; // Cannot match if either ID is missing
  }

  // TODO: Implement actual matching logic based on how pairs are defined.
  // This placeholder assumes a match occurs if the IDs are identical.
  // In a real scenario, you might compare originalImageId to generatedImageId
  // or look up relationships in a database/mapping.
  return String(choiceId) === String(targetId); // Simple ID comparison (adjust as needed) [cite: 1604]
}

--- File: ./src/lib/SoundManager.ts ---
// src/lib/SoundManager.ts
// A unified, browser-only sound manager singleton.
// Handles both predefined static sounds and dynamic URLs.

// Define available sound names and their corresponding file paths
const PREDEFINED_SOUNDS = {
  click: "/sounds/click_001.ogg",
  countdown: "/sounds/click_001.ogg",
  correct: "/sounds/click_001.ogg",
  wrong: "/sounds/click_001.ogg",
  nextQuestion: "/sounds/click_001.ogg",
  questionStart: "/sounds/click_001.ogg",
  gameOver: "/sounds/click_001.ogg",
  roundBreak: "/sounds/click_001.ogg", // Added this
} as const;

// Type representing the valid *predefined* sound names
type PredefinedSoundName = keyof typeof PREDEFINED_SOUNDS;

// Options for playing a sound
type PlayOptions = {
  loop?: boolean; // Should the sound loop?
  volume?: number; // Volume level (0.0 to 1.0)
};

// Interface defining the public API
type SoundManagerAPI = {
  init(): Promise<void>;
  /**
   * Plays a sound.
   * @param nameOrUrl Can be a predefined sound name (e.g., 'click') or a full URL.
   * @param options Playback options like loop and volume.
   */
  play(nameOrUrl: string, options?: PlayOptions): void;
  /**
   * Stops a sound.
   * @param nameOrUrl The predefined name or full URL of the sound to stop.
   */
  stop(nameOrUrl: string): void;
  stopAll(): void;
};

const isBrowser =
  typeof window !== "undefined" && typeof window.Audio !== "undefined";

/**
 * Manages all audio playback.
 * Implemented as a Singleton.
 */
class UnifiedSoundManager implements SoundManagerAPI {
  private static instance: UnifiedSoundManager;
  private audioContext?: AudioContext;

  /**
   * Stores all active audio elements, keyed by their nameOrUrl.
   * This is crucial for stopping them, especially loops.
   */
  private activeSounds: Map<string, HTMLAudioElement> = new Map();

  private constructor() {
    // Pre-load predefined sounds for faster playback
    if (!isBrowser) return;

    (
      Object.entries(PREDEFINED_SOUNDS) as [PredefinedSoundName, string][]
    ).forEach(([name, url]) => {
      try {
        const base = new window.Audio(url);
        base.preload = "auto";
        base.load();
        // We store the *preloaded* element itself.
        // We will *clone* this for one-shot sounds.
        this.activeSounds.set(name, base);
      } catch (error) {
        console.error(`Failed to create Audio for "${name}" at ${url}:`, error);
      }
    });
  }

  public static getInstance(): UnifiedSoundManager {
    if (!UnifiedSoundManager.instance) {
      UnifiedSoundManager.instance = new UnifiedSoundManager();
    }
    return UnifiedSoundManager.instance;
  }

  public async init(): Promise<void> {
    if (this.audioContext || !isBrowser) return;

    const AudioContextCtor =
      window.AudioContext ||
      (window as unknown as { webkitAudioContext: AudioContext })
        .webkitAudioContext;
    if (!AudioContextCtor) {
      console.warn("AudioContext is not supported.");
      return;
    }

    try {
      this.audioContext = new AudioContextCtor();
      if (this.audioContext.state === "suspended") {
        await this.audioContext.resume();
      }
    } catch (error) {
      console.warn("Failed to initialize AudioContext:", error);
      this.audioContext = undefined;
    }
  }

  public play(nameOrUrl: string, options: PlayOptions = {}): void {
    if (!isBrowser) return;

    const { loop = false, volume = 0.6 } = options;
    const clampedVolume = Math.min(1, Math.max(0, volume));

    // Check if it's a predefined sound
    const isPredefined = nameOrUrl in PREDEFINED_SOUNDS;
    let audio: HTMLAudioElement;

    // --- Get or Create Audio Element ---
    if (this.activeSounds.has(nameOrUrl) && (loop || isPredefined)) {
      // 1. Reuse existing element (for loops or predefined sounds)
      audio = this.activeSounds.get(nameOrUrl)!;
    } else {
      // 2. Create new element (for one-shot URLs or if not found)
      try {
        const src = isPredefined
          ? PREDEFINED_SOUNDS[nameOrUrl as PredefinedSoundName]
          : nameOrUrl;
        audio = new window.Audio(src);
        audio.preload = "auto";
      } catch (error) {
        console.error(
          `[SoundManager] Error loading sound from ${nameOrUrl}:`,
          error
        );
        return;
      }
    }

    // --- Configure and Play ---
    audio.loop = loop;
    audio.volume = clampedVolume;
    audio.currentTime = 0; // Always play from the start

    const playPromise = audio.play();
    if (playPromise !== undefined) {
      playPromise.catch((error) => {
        if (error.name === "NotAllowedError") {
          console.debug(`[SoundManager] Playback requires user interaction.`);
        } else {
          console.error(`[SoundManager] Error playing ${nameOrUrl}:`, error);
        }
        // If it failed, remove it from active sounds if it's not predefined
        if (!isPredefined) {
          this.activeSounds.delete(nameOrUrl);
        }
      });
    }

    // --- Manage Active Sounds Map ---
    if (loop) {
      // If looping, *always* store it so we can stop it
      this.activeSounds.set(nameOrUrl, audio);
    } else if (!isPredefined) {
      // If one-shot URL, store it and remove on 'ended'
      this.activeSounds.set(nameOrUrl, audio);
      audio.addEventListener(
        "ended",
        () => {
          this.activeSounds.delete(nameOrUrl);
        },
        { once: true }
      );
    }
    // (If one-shot predefined, we just play it but don't re-store it)
  }

  public stop(nameOrUrl: string): void {
    if (!isBrowser) return;

    const audio = this.activeSounds.get(nameOrUrl);
    if (!audio) return;

    try {
      audio.pause();
      audio.currentTime = 0;
    } catch (error) {
      console.error(`[SoundManager] Error stopping ${nameOrUrl}:`, error);
    }

    // If it wasn't a predefined sound, remove it from the map
    if (!(nameOrUrl in PREDEFINED_SOUNDS)) {
      this.activeSounds.delete(nameOrUrl);
    }
  }

  public stopAll(): void {
    if (!isBrowser) return;

    this.activeSounds.forEach((audio, key) => {
      try {
        audio.pause();
        audio.currentTime = 0;
        // Don't remove predefined sounds, just stop them
        if (!(key in PREDEFINED_SOUNDS)) {
          this.activeSounds.delete(key);
        }
      } catch (error) {
        console.warn(`[SoundManager] Error stopping sound "${key}":`, error);
      }
    });
  }
}

// --- Export Singleton Instance ---
const SoundManager: SoundManagerAPI = isBrowser
  ? UnifiedSoundManager.getInstance()
  : {
      async init() {},
      play() {},
      stop() {},
      stopAll() {},
    };

export default SoundManager;

--- File: ./src/lib/env.ts ---
const resolveRootUrl = (): string => {
  const explicitUrl =
    process.env.NEXT_PUBLIC_URL ?? process.env.NEXT_PUBLIC_APP_URL ?? null;

  if (explicitUrl) {
    try {
      new URL(explicitUrl);
      return explicitUrl.replace(/\/$/, "");
    } catch {
      console.warn(
        `Invalid NEXT_PUBLIC_URL provided: ${explicitUrl}. Falling back...`
      );
    }
  }

  if (
    process.env.VERCEL_ENV === "production" &&
    process.env.VERCEL_PROJECT_PRODUCTION_URL
  ) {
    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`;
  }

  if (process.env.VERCEL_URL) {
    return `https://${process.env.VERCEL_URL}`;
  }

  return "http://localhost:3000";
};

const parseLeaderboardPageSize = (): number => {
  const defaultSize = 25;
  const envValue =
    process.env.NEXT_PUBLIC_LEADERBOARD_PAGE_SIZE ??
    process.env.LEADERBOARD_PAGE_SIZE;

  if (envValue) {
    const parsed = parseInt(envValue, 10);
    if (Number.isInteger(parsed) && parsed > 0) {
      return parsed;
    } else {
      console.warn(
        `Invalid LEADERBOARD_PAGE_SIZE provided: "${envValue}". Using default ${defaultSize}.`
      );
    }
  }
  return defaultSize;
};

export const env = {
  rootUrl: resolveRootUrl(),
  neynarApiKey: process.env.NEYNAR_API_KEY!,
  nextPublicOnchainkitApiKey: process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY!,
  waffleMainAddress: process.env
    .NEXT_PUBLIC_WAFFLE_MAIN_ADDRESS as `0x${string}`,
  nextPublicUsdcAddress: process.env.NEXT_PUBLIC_USDC_ADDRESS as `0x${string}`,
  nextPublicSupabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  nextPublicSupabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  nextPublicLeaderboardPageSize: parseLeaderboardPageSize(),
};

if (typeof window === "undefined") {
  if (!env.neynarApiKey) {
    console.error(
      "FATAL ERROR: NEYNAR_API_KEY environment variable is not set."
    );
  }
  if (!env.nextPublicOnchainkitApiKey) {
    console.error(
      "FATAL ERROR: NEXT_PUBLIC_ONCHAINKIT_API_KEY environment variable is not set."
    );
  }
  if (
    !env.waffleMainAddress ||
    !/^0x[a-fA-F0-9]{40}$/.test(env.waffleMainAddress)
  ) {
    console.error(
      `FATAL ERROR: NEXT_PUBLIC_WAFFLE_MAIN_ADDRESS is invalid or not set: "${env.waffleMainAddress}"`
    );
  }
  if (
    !env.nextPublicUsdcAddress ||
    !/^0x[a-fA-F0-9]{40}$/.test(env.nextPublicUsdcAddress)
  ) {
    console.error(
      `FATAL ERROR: NEXT_PUBLIC_USDC_ADDRESS is invalid or not set: "${env.nextPublicUsdcAddress}"`
    );
  }
  if (
    !env.nextPublicSupabaseUrl ||
    !env.nextPublicSupabaseUrl.startsWith("http")
  ) {
    console.error(
      `FATAL ERROR: NEXT_PUBLIC_SUPABASE_URL is invalid or not set: "${env.nextPublicSupabaseUrl}"`
    );
  }
  if (!env.nextPublicSupabaseAnonKey) {
    console.error(
      "FATAL ERROR: NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable is not set."
    );
  }
}

--- File: ./src/lib/neynarClient.ts ---
import { env } from "@/lib/env";
import { NeynarAPIClient } from "@neynar/nodejs-sdk";

if (!env.neynarApiKey) {
  console.error(
    "FATAL ERROR: NEYNAR_API_KEY is not configured in environment variables. Neynar client cannot be initialized."
  );
}
export const neynar = new NeynarAPIClient({
  apiKey: env.neynarApiKey!,
});

--- File: ./src/lib/fonts/ndot47_bd.woff2 ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/index.ts ---
import localFont from "next/font/local";

export const fontDisplay = localFont({
  src: [
    {
      path: "./brockmann_bd.otf",
      weight: "700",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-display",
});

export const fontBody = localFont({
  src: [
    {
      path: "./editundo_bd.ttf",
      weight: "700",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-body",
});

export const fontInput = localFont({
  src: [
    {
      path: "./ndot47_bd.woff2",
      weight: "700",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-input",
});

--- File: ./src/lib/fonts/brockmann_bd.otf ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/editundo_bd.ttf ---
[Content not included: Binary file]

--- File: ./src/lib/db.ts ---
import { PrismaClient } from "@prisma/client";

declare global {
  var prisma: PrismaClient | undefined;
}

export const prisma: PrismaClient = global.prisma || new PrismaClient({});

if (process.env.NODE_ENV !== "production") {
  global.prisma = prisma;
}

--- File: ./src/lib/auth.ts ---
import { cookies } from "next/headers";

// Get the current user's fid from cookies
export async function getCurrentUserFid(): Promise<number | null> {
  const cookieStore = await cookies();
  const fidCookie = cookieStore.get("fid")?.value;
  if (!fidCookie || isNaN(Number(fidCookie))) return null;
  return Number(fidCookie);
}

--- File: ./src/lib/wagmiConfig.ts ---
import { createConfig, http } from "wagmi";
import { base } from "wagmi/chains";
import { injected } from "wagmi/connectors";

export const wagmiConfig = createConfig({
  chains: [base],
  transports: {
    [base.id]: http(),
  },
  connectors: [injected()],
  ssr: true,
});

--- File: ./src/lib/streaks.ts ---
// Constant defining the maximum gap allowed between games to maintain a streak (in milliseconds)
// ~1.1 days (24 * 1.1 * 60 * 60 * 1000 = 95,040,000 ms) allows for slight variations around day boundaries.
const MAX_STREAK_GAP_MS = 1.1 * 24 * 60 * 60 * 1000; //

/**
 * Calculates the current consecutive game playing streak based on game end dates.
 * A streak continues if the gap between consecutive game end times is within
 * approximately 1.1 days.
 *
 * @param {Date[]} gameDates - An array of Date objects representing when games were completed/ended.
 * @returns {number} The length of the current consecutive playing streak (0 if no games played).
 */
export function calculateStreak(gameDates: Date[]): number {
  // 1. Handle Empty Input or Invalid Data
  // Filter out any potentially invalid date objects first
  const validDates =
    gameDates?.filter(
      (date) => date instanceof Date && !isNaN(date.getTime())
    ) || [];

  if (validDates.length === 0) {
    return 0; // No games played, streak is 0 [cite: 1651]
  }
  if (validDates.length === 1) {
    return 1; // Only one game played, streak is 1
  }

  // 2. Sort Dates: Most recent game first (descending order)
  const sortedDates = validDates.sort((a, b) => b.getTime() - a.getTime()); // [cite: 1652]

  // 3. Calculate Streak
  let streak = 1; // Start streak at 1 (for the most recent game) [cite: 1652]
  // Iterate from the second most recent game backwards
  for (let i = 1; i < sortedDates.length; i++) {
    // [cite: 1653]
    // Calculate the time difference between the current game and the previous (more recent) one
    const diffMs = sortedDates[i - 1].getTime() - sortedDates[i].getTime(); // [cite: 1653]

    // Check if the difference is within the allowed gap
    if (diffMs <= MAX_STREAK_GAP_MS) {
      // Compare against the constant [cite: 1654]
      streak++; // Increment streak if within the gap [cite: 1654]
    } else {
      // If the gap is too large, the streak is broken
      break; // Stop counting [cite: 1654]
    }
  }

  // 4. Return the calculated streak length
  return streak; //
}

