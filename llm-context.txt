--- File: ./.next/package.json ---
{"type": "commonjs"}
--- File: ./package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint",
    "postinstall": "prisma generate"
  },
  "prisma": {
    "seed": "tsx prisma/seed.ts"
  },
  "dependencies": {
    "@coinbase/onchainkit": "^1.1.1",
    "@farcaster/miniapp-sdk": "^0.2.1",
    "@farcaster/quick-auth": "^0.0.8",
    "@neynar/nodejs-sdk": "^3.34.0",
    "@prisma/client": "6.18.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@supabase/supabase-js": "^2.76.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.24",
    "lucide-react": "^0.546.0",
    "next": "15.5.6",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "sonner": "^2.0.7",
    "swr": "2",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.4.0",
    "viem": "^2.38.3",
    "wagmi": "^2.18.2",
    "zod": "^4.1.12"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.6",
    "prisma": "6.18.0",
    "tailwindcss": "^4",
    "tsx": "^4.20.6",
    "typescript": "^5"
  },
  "packageManager": "pnpm@9.15.4+sha512.b2dc20e2fc72b3e18848459b37359a32064663e5627a51e4c74b2c29dd8e8e0491483c3abb40789cfd578bf362fb6ba8261b05f0387d76792ed6e23ea3b1b6a0"
}

--- File: ./.env ---
# Environment variables declared in this file are NOT automatically loaded by Prisma.
# Please add `import "dotenv/config";` to your `prisma.config.ts` file, or use the Prisma CLI with Bun
# to load environment variables from .env files: https://pris.ly/prisma-config-env-vars.

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# The following `prisma+postgres` URL is similar to the URL produced by running a local Prisma Postgres 
# server with the `prisma dev` CLI command, when not choosing any non-default ports or settings. The API key, unlike the 
# one found in a remote Prisma Postgres URL, does not contain any sensitive information.

DATABASE_URL="prisma+postgres://localhost:51213/?api_key=eyJkYXRhYmFzZVVybCI6InBvc3RncmVzOi8vcG9zdGdyZXM6cG9zdGdyZXNAbG9jYWxob3N0OjUxMjE0L3RlbXBsYXRlMT9zc2xtb2RlPWRpc2FibGUmY29ubmVjdGlvbl9saW1pdD0xJmNvbm5lY3RfdGltZW91dD0wJm1heF9pZGxlX2Nvbm5lY3Rpb25fbGlmZXRpbWU9MCZwb29sX3RpbWVvdXQ9MCZzaW5nbGVfdXNlX2Nvbm5lY3Rpb25zPXRydWUmc29ja2V0X3RpbWVvdXQ9MCIsIm5hbWUiOiJkZWZhdWx0Iiwic2hhZG93RGF0YWJhc2VVcmwiOiJwb3N0Z3JlczovL3Bvc3RncmVzOnBvc3RncmVzQGxvY2FsaG9zdDo1MTIxNS90ZW1wbGF0ZTE_c3NsbW9kZT1kaXNhYmxlJmNvbm5lY3Rpb25fbGltaXQ9MSZjb25uZWN0X3RpbWVvdXQ9MCZtYXhfaWRsZV9jb25uZWN0aW9uX2xpZmV0aW1lPTAmcG9vbF90aW1lb3V0PTAmc2luZ2xlX3VzZV9jb25uZWN0aW9ucz10cnVlJnNvY2tldF90aW1lb3V0PTAifQ"

# Connect to Supabase via connection pooling

# DATABASE_URL="postgres://postgres:WafflesSupremacy@1.0@db.hizkyaqomaburfcsdymo.supabase.co:5432/postgres?pgbouncer=true"

# Direct connection to the database. Used for migrations
# DIRECT_URL="postgresql://postgres.fuoqnzdloxjgbmqcvuqs:vjvKrnek7Kip6qhO@aws-1-eu-west-1.pooler.supabase.com:5432/postgres"

NEXT_PUBLIC_SUPABASE_URL=https://hizkyaqomaburfcsdymo.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhpemt5YXFvbWFidXJmY3NkeW1vIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyNzgzMDYsImV4cCI6MjA3Njg1NDMwNn0.382bnE4iv_L2Cc4lTOMoVb0B5Y1jcFYVdMIP36V-jSY

NEYNAR_API_KEY=BDC7F176-D550-4D9E-BBF6-0B5DC52E5785
NEXT_PUBLIC_ONCHAINKIT_API_KEY=jrY4mos7-wh-8MFia-Am2Bii7mGStOxx
NEXT_PUBLIC_URL=http://localhost:3000
NEXT_PUBLIC_WAFFLE_MAIN_ADDRESS=0x0b3d62DF33521cdcE79E87586d7C1534b00EcAd7
NEXT_PUBLIC_USDC_ADDRESS=0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913



--- File: ./next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: "https",
        hostname: "**",
        port: "",
        pathname: "**",
      },
    ],
  },
};

export default nextConfig;

--- File: ./src/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/waitlist/page.tsx ---
"use client";

import { useMiniUser } from "@/hooks/useMiniUser";
import { useState, useEffect } from "react";
import Image from "next/image";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { CardStack } from "@/components/CardStack";

export default function WaitlistPage() {
  const user = useMiniUser();
  const [loading, setLoading] = useState(true);
  const [onList, setOnList] = useState(false);
  const [rank, setRank] = useState<number | null>(null);
  const [friendsCount, setFriendsCount] = useState(0);

  useEffect(() => {
    if (!user.fid) return;
    (async () => {
      const res = await fetch(`/api/waitlist/status?fid=${user.fid}`, {
        cache: "no-store",
      });
      const data = await res.json();
      console.log(data);
      if (data.onList) {
        setOnList(true);
        setRank(data.rank);
        setFriendsCount(data.invites || 0);
      }
      setLoading(false);
    })();
  }, [user.fid]);

  const join = async () => {
    if (!user.fid) return;
    await fetch(`/api/waitlist/join`, {
      method: "POST",
      body: JSON.stringify({
        fid: user.fid,
        referrer:
          new URLSearchParams(window.location.search).get("ref") || null,
      }),
    });
    window.location.reload();
  };

  if (loading || !user.fid) return null;

  return (
    <main className="relative w-[393px] h-[852px] mx-auto bg-gradient-to-b from-[#1E1E1E] to-black overflow-hidden">
      {/* Logo */}
      <div
        className="absolute left-[1/2] top-0"
        style={{
          width: "224.06px",
          height: "42.58px",
          left: "calc(50% - 224.06px/2 - 0.23px)",
          top: "calc(50% - 42.58px/2 - 294.71px)",
        }}
      >
        <div className="flex flex-row items-center justify-center w-[224.06px] h-[42.58px] gap-0">
          <div className="w-[54.82px] h-[42.58px] flex items-center justify-center">
            <Image
              src="/logo.png"
              alt="WAFFLES logo"
              width={55}
              height={43}
              className="object-contain w-[54.82px] h-[42.58px]"
              priority
            />
          </div>
          <div className="w-[157.07px] h-[27.62px] flex items-center justify-center">
            <span className="font-extrabold uppercase text-[32px] leading-[28px] text-foreground tracking-wide font-body px-2">
              WAFFLES
            </span>
          </div>
        </div>
      </div>

      {/* Scroll graphic */}
      <Image
        src="/images/illustrations/waitlist-scroll.svg"
        width={170}
        height={189}
        alt="scroll"
        className="absolute top-[213px] left-1/2 -translate-x-1/2"
      />

      {/* Dynamic Section */}
      <div className="absolute left-[16px] top-[446px] w-[361px] flex flex-col items-center gap-[20px]">
        {onList ? (
          <>
            <h1 className="font-body text-white text-[44px] leading-[92%] text-center">
              YOU&apos;RE ON
              <br />
              THE LIST
            </h1>

            <p className="text-[#99A0AE] text-center font-display text-[16px] leading-[130%]">
              You&apos;re #2311 on the waitlist. Share with friends to move up
              faster
            </p>

            <FancyBorderButton
              onClick={() =>
                navigator.share?.({
                  text: `Join me on Waffles! /waitlist?ref=${user.fid}`,
                })
              }
            >
              SHARE
            </FancyBorderButton>
          </>
        ) : (
          <>
            <h1 className="font-body text-white text-[44px] leading-[92%] text-center">
              JOIN THE
              <br />
              WAITLIST
            </h1>

            <p className="text-[#99A0AE] text-center font-display text-[16px] leading-[130%]">
              Join now to be first to play when <br />
              Waffles launches
            </p>

            <FancyBorderButton onClick={join}>
              GET ME ON THE LIST
            </FancyBorderButton>
          </>
        )}
      </div>

      {/* Crew images at bottom */}
      <div className="absolute bottom-0 w-full flex justify-center gap-[-18px]">
        <CardStack
          images={[
            { src: "/images/avatars/a.png" },
            { src: "/images/avatars/b.png" },
            { src: "/images/avatars/c.png" },
            { src: "/images/avatars/d.png" },
          ]}
          size={48}
        />
      </div>
    </main>
  );
}

--- File: ./src/app/favicon.ico ---
[Content not included: Binary file]

--- File: ./src/app/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/.well-known/farcaster.json/route.ts ---
import { withValidManifest } from "@coinbase/onchainkit/minikit";
import { minikitConfig } from "../../../../minikit.config";

export async function GET() {
  return Response.json(withValidManifest(minikitConfig));
}

--- File: ./src/app/(authenticated)/lobby/invite-code/page.tsx ---
"use client";
import LogoIcon from "@/components/logo/LogoIcon";
import React, { useEffect, useState } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useLobby } from "@/state";
import { PixelInput } from "@/components/inputs/PixelInput";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { PixelButton } from "@/components/buttons/PixelButton";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function InviteCodePage() {
  const router = useRouter();

  const { validateReferral, invitedBy, ticket } = useLobby();
  const user = useMiniUser();

  // If invite code is already valid, skip to Buy or directly into the game
  useEffect(() => {
    if (ticket) {
      // already have ticket: go straight into the game
      router.replace("/game");
    }
  }, [ticket, router]);

  const [inputCode, setInputCode] = useState(invitedBy?.code || "");
  const [error, setError] = useState<string | null>(null);
  const [status, setStatus] = useState<
    "idle" | "validating" | "success" | "failed"
  >(invitedBy?.code ? "success" : "idle");

  // Debounced code validation as user types
  useEffect(() => {
    if (inputCode.trim().length < 6 || !user.fid) {
      setError(null);
      setStatus("idle");
      return;
    }
    const timer = setTimeout(async () => {
      try {
        if (!user.fid) {
          console.error("User FID is null");
          return;
        }
        setStatus("validating");
        const ok = await validateReferral(inputCode, user.fid.toString());
        setStatus(ok ? "success" : "failed");
        if (!ok) {
          setError("Invalid code");
        } else {
          setError(null);
        }
      } catch (err) {
        console.error(err);
        setError("Validation failed");
        setStatus("failed");
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [inputCode, validateReferral, user.fid]);

  // On form submit: if code is valid, go to buy page
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputCode.trim() || inputCode.trim().length !== 6) return;
    if (!user.fid) {
      console.error("User FID is null");
      return;
    }
    if (!ticket) {
      const ok = await validateReferral(inputCode, user.fid.toString());
      setStatus(ok ? "success" : "failed");
      if (!ok) {
        setError("Invalid code");
        return;
      }
    }
    router.push("/lobby/buy");
  };

  return (
    <div className="min-h-screen max-w-screen-sm mx-auto px-8 flex flex-col">
      <div
        className={
          "p-4 flex items-center justify-center border-y border-border app-background-gradient"
        }
      >
        <LogoIcon />
      </div>
      <div className="flex flex-col items-center justify-center py-16">
        {/* ICON */}
        <div className="mb-6">
          <Image
            src="/images/illustrations/invite-key.png"
            alt="Invite Key"
            width={105}
            height={105}
            style={{ imageRendering: "pixelated" }}
          />
        </div>

        {/* TITLE */}
        <h2 className="mb-8 text-center text-3xl leading-tight font-bold uppercase tracking-wider">
          <span className="block">ENTER YOUR</span>
          <span className="block">INVITE CODE</span>
        </h2>

        {/* FORM */}
        <form
          onSubmit={handleSubmit}
          className="w-full max-w-md flex flex-col items-center gap-6"
          autoComplete="off"
        >
          <label htmlFor="inviteCodeInput" className="sr-only">
            Invite Code
          </label>

          <PixelInput
            id="inviteCodeInput"
            type="text"
            value={inputCode}
            onChange={(e) => setInputCode(e.target.value.toUpperCase())}
            placeholder="INVITE CODE"
            maxLength={6}
            autoFocus
          />

          <FancyBorderButton disabled={inputCode.trim().length !== 6}>
            GET IN
          </FancyBorderButton>

          {/* STATUS MESSAGES */}
          {status === "validating" && (
            <p
              className="text-xs mt-2"
              style={{
                color: "#a0a0a0",
                fontFamily: "'Press Start 2P', 'Geist Mono', monospace",
                letterSpacing: "0.04em",
              }}
            >
              Validating...
            </p>
          )}

          {status === "failed" && (
            <PixelButton
              className="flex items-center gap-2 font-body"
              backgroundColor="#FF5252"
              borderColor="#FF5252"
              textColor="#FFFFFF"
              onClick={() => setError(null)}
            >
              <Image
                src="/images/icons/icon-invalid.png"
                alt="Invalid Invite Code"
                width={20}
                height={20}
              />
              <span>{error || "Invalid"}</span>
            </PixelButton>
          )}

          {status === "success" && (
            <PixelButton
              className="flex items-center gap-2 font-body"
              backgroundColor="#14B985"
              borderColor="#14B985"
              textColor="#FFFFFF"
              onClick={() => router.push("/lobby/buy")}
            >
              <Image
                src="/images/icons/icon-valid.png"
                alt="Valid Invite Code"
                width={20}
                height={20}
              />
              <span>Valid</span>
            </PixelButton>
          )}
        </form>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/page.tsx ---
import { redirect } from "next/navigation";

export default function LobbyPage() {
  redirect("/game");
  return null;
}

--- File: ./src/app/(authenticated)/lobby/buy/_components/Share.tsx ---
"use client";

import Image from "next/image";
import { cn } from "@/lib/utils";

type SummaryItemProps = {
  iconSrc: string;
  label: string;
  value: string;
};

type ShareViewProps = {
  gameTitle: string;
  theme: string;
  username: string;
  avatarUrl: string;
  prizePool: number | null;
  onShare: () => void;
  onBackHome: () => void;
};

const SummaryItem = ({ iconSrc, label, value }: SummaryItemProps) => (
  <div className="flex flex-1 items-center gap-3 rounded-[16px] border border-white/10 bg-white/5 px-4 py-3 backdrop-blur-sm">
    <Image src={iconSrc} alt={label} width={32} height={32} />
    <div>
      <p className="text-sm font-display text-[#99A0AE]">{label}</p>
      <p className="font-edit-undo text-lg text-white">{value}</p>
    </div>
  </div>
);

export function Share({
  gameTitle,
  theme,
  username,
  avatarUrl,
  prizePool,
  onShare,
  onBackHome,
}: ShareViewProps) {
  const formattedPrize =
    prizePool !== null ? `$${prizePool.toLocaleString("en-US")}` : "TBA";

  return (
    <div className="min-h-[100dvh] w-full app-background noise z-50">
      <div className="mx-auto flex min-h-[100dvh] w-full max-w-[420px] flex-col items-center px-5 pb-[calc(env(safe-area-inset-bottom)+48px)] pt-14">
        <Image
          src="/images/illustrations/waffle-ticket.png"
          alt="Pixel waffle"
          width={228}
          height={132}
          priority
          className="mb-8 h-auto w-[228px]"
        />

        <h1
          className="text-foreground text-center font-edit-undo"
          style={{
            fontSize: "42px",
            lineHeight: "0.92",
            letterSpacing: "-0.03em",
          }}
        >
          WAFFLE SECURED!
        </h1>

        <p className="mt-3 text-center text-base font-display text-[#99A0AE]">
          You&apos;re in for {gameTitle}. See you Friday.
        </p>

        <div className="mt-8 w-full rounded-[24px] border border-[#FFC931]/60 bg-black/30 p-4 backdrop-blur">
          <div className="flex items-center gap-4">
            <div className="relative size-14 overflow-hidden rounded-full border border-white/15">
              <Image
                src={avatarUrl}
                alt={username}
                fill
                className="object-cover"
              />
            </div>
            <div className="flex flex-col">
              <span className="font-edit-undo text-white text-xl">
                {username}
              </span>
              <span className="text-sm font-display text-[#99A0AE]">
                has joined the next game
              </span>
            </div>
          </div>

          <div className="mt-5 flex flex-col gap-4 sm:flex-row">
            <SummaryItem
              iconSrc="/images/icons/icon-prizepool-cash.png"
              label="Prize pool"
              value={formattedPrize}
            />
            <SummaryItem
              iconSrc="/images/icons/icon-theme-football.png"
              label="Theme"
              value={theme.toUpperCase()}
            />
          </div>
        </div>

        <button
          onClick={onShare}
          className={cn(
            "mt-8 w-full rounded-[14px] bg-white px-6 py-4 text-center font-edit-undo text-2xl text-[#FB72FF]",
            "border-r-[5px] border-b-[5px] border-[#FB72FF] transition active:translate-x-[2px] active:translate-y-[2px]"
          )}
        >
          SHARE TICKET
        </button>

        <button
          onClick={onBackHome}
          className="mt-6 text-sm font-edit-undo uppercase text-[#00CFF2] transition hover:text-[#33defa]"
        >
          BACK TO HOME
        </button>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/buy/_components/SpotsLeft.tsx ---
import * as React from "react";

type SpotsLeftProps = {
  current: number;
  total: number;
  avatars: string[];
  className?: string;
};

const FALLBACK_AVATARS = [
  "/images/avatars/a.png",
  "/images/avatars/b.png",
  "/images/avatars/c.png",
  "/images/avatars/d.png",
] as const;

export function SpotsLeft({
  current,
  total,
  avatars,
  className = "",
}: SpotsLeftProps) {
  const clampedCurrent = Math.max(0, Math.min(current, total));
  const displayedAvatars = React.useMemo(
    () => {
      const sanitized = avatars
        .filter(Boolean)
        .slice(0, 4)
        .map((src, index) => src || FALLBACK_AVATARS[index] || FALLBACK_AVATARS[0]);
      if (sanitized.length > 0) {
        return sanitized;
      }
      return Array.from({ length: 4 }, (_, index) => FALLBACK_AVATARS[index]);
    },
    [avatars]
  );

  return (
    <div
      className={[
        "flex w-full max-w-[260px] flex-col items-center gap-3 text-center",
        className,
      ].join(" ")}
    >
      <div className="flex -space-x-4">
        {displayedAvatars.map((src, index) => (
          <span
            key={`${src}-${index}`}
            className="inline-flex size-12 items-center justify-center rounded-xl border border-white/10 bg-[#0E0E11] shadow-[0_4px_12px_rgba(0,0,0,0.4)]"
            style={{
              backgroundImage: `url(${src})`,
              backgroundSize: "cover",
              backgroundPosition: "center",
            }}
            aria-hidden="true"
          />
        ))}
      </div>

      <div>
        <p className="font-edit-undo text-[clamp(1.5rem,5vw,2.25rem)] leading-none text-[#00CFF2]">
          {clampedCurrent}/{total}
        </p>
        <p className="text-sm font-display uppercase tracking-[0.2em] text-[#99A0AE]">
          spots left
        </p>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/buy/page.tsx ---
"use client";

import React, { useCallback, useEffect, useMemo, useState } from "react";
import { useRouter } from "next/navigation";
import { useComposeCast, useSendToken } from "@coinbase/onchainkit/minikit";
import LogoIcon from "@/components/logo/LogoIcon";
import { cn } from "@/lib/utils";
import { InviteIcon, WalletIcon } from "@/components/icons";
import { BottomNav } from "@/components/BottomNav";
import Image from "next/image";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { SpotsLeft } from "./_components/SpotsLeft";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { InviteFriendsDrawer } from "@/app/(authenticated)/profile/_components/InviteFriendsDrawer";
import { Share } from "./_components/Share";
import { useGame, useLobby } from "@/state";

import { base } from "wagmi/chains";

type FriendSummary = {
  fid: number;
  username: string;
  displayName?: string | null;
  pfpUrl?: string | null;
  relationship: {
    isFollower: boolean;
    isFollowing: boolean;
  };
  hasTicket: boolean;
  ticketId?: number;
  ticketGameId?: number;
};

// ───────────────────────── CONSTANTS ─────────────────────────

export default function BuyWafflePage() {
  const { sendTokenAsync } = useSendToken();
  const router = useRouter();
  const { activeGame, loadActiveGame } = useGame();
  const user = useMiniUser();
  const {
    ticket,
    stats,
    refreshStats,
    fetchTicket,
    purchaseTicket,
    hasValidInvite,
    inviteStatusLoaded,
    myReferral,
  } = useLobby();
  const [isInviteOpen, setInviteOpen] = useState(false);
  const [isPurchasing, setIsPurchasing] = useState(false);
  const [friends, setFriends] = useState<FriendSummary[]>([]);
  const [friendsLoading, setFriendsLoading] = useState(false);
  const [friendsError, setFriendsError] = useState<string | null>(null);
  const [showShare, setShowShare] = useState(false);
  const [purchaseError, setPurchaseError] = useState<string | null>(null);
  const { composeCastAsync } = useComposeCast();
  const farcasterId = user.fid ? String(user.fid) : null;

  useEffect(() => {
    if (ticket) {
      router.replace("/game");
    }
  }, [ticket, router]);

  useEffect(() => {
    if (activeGame) {
      loadActiveGame().catch((err) =>
        console.error("Failed to load active game", err)
      );
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activeGame?.id, loadActiveGame]);

  const { roundedBalance } = useGetTokenBalance(user.wallet as `0x${string}`, {
    address: env.nextPublicUsdcAddress as `0x${string}`,
    chainId: base.id,
    decimals: 6,
    image: "/images/tokens/usdc.png",
    name: "USDC",
    symbol: "USDC",
  });

  useEffect(() => {
    if (!stats) {
      refreshStats().catch((err) =>
        console.error("Failed to load lobby stats", err)
      );
    }
  }, [stats, refreshStats]);

  // ───────────────────────── HANDLER ─────────────────────────
  const handlePurchase = async () => {
    if (!user.fid) {
      console.error("User FID is not set");
      return;
    }
    if (!activeGame) {
      console.error("Game is not set");
      return;
    }
    if (!activeGame.config) {
      console.error("Game config is not set");
      return;
    }

    try {
      setIsPurchasing(true);
      setPurchaseError(null);

      const inviteOk = inviteStatusLoaded && hasValidInvite;

      if (!inviteOk) {
        setPurchaseError("Redeem an invite code before buying a ticket.");
        router.push("/lobby/invite-code");
        return;
      }

      await sendTokenAsync({
        amount: (activeGame.config.ticketPrice * 10 ** 6).toString(),
        recipientAddress: env.waffleMainAddress,
      });

      const createdTicket = await purchaseTicket(user.fid!, activeGame.id);
      if (createdTicket) {
        await fetchTicket(String(user.fid), activeGame.id);
        await refreshStats();
      }

      setShowShare(true);
    } catch (err) {
      console.error("Ticket purchase failed", err);
      const inviteOk = inviteStatusLoaded && hasValidInvite;
      if (!inviteOk) {
        setPurchaseError("Redeem an invite code before buying a ticket.");
      } else if (
        err instanceof Error &&
        err.message?.toLowerCase().includes("user rejected")
      ) {
        setPurchaseError("Transaction cancelled.");
      } else {
        setPurchaseError("Ticket purchase failed. Please try again.");
      }
    } finally {
      setIsPurchasing(false);
    }
  };

  const handleOpenInvite = () => {
    setInviteOpen(true);
  };

  const handleBackToHome = useCallback(() => {
    router.replace("/game");
  }, [router]);

  const shareTicket = useCallback(async () => {
    if (!ticket || !activeGame) return;

    try {
      const message = `Just secured my waffle ticket for ${activeGame.name}!`;

      const result = await composeCastAsync({
        text: message,
        embeds: [env.rootUrl || ""],
      });

      // result.cast can be null if user cancels
      if (result?.cast) {
        console.log("Cast created successfully:", result.cast.hash);
      } else {
        console.log("User cancelled the cast");
      }
    } catch (error) {
      console.error("Error sharing cast:", error);
      alert("Unable to share your ticket right now.");
    }
  }, [ticket, activeGame, composeCastAsync]);

  useEffect(() => {
    if (!farcasterId || !activeGame?.id) return;
    fetchTicket(farcasterId, activeGame.id).catch((error) =>
      console.error("Failed to fetch ticket info", error)
    );
  }, [farcasterId, activeGame?.id, fetchTicket]);

  useEffect(() => {
    if (!farcasterId || !activeGame?.id) {
      setFriends([]);
      setFriendsError(null);
      setFriendsLoading(false);
      return;
    }
    const controller = new AbortController();
    const loadFriends = async () => {
      try {
        setFriendsLoading(true);
        setFriendsError(null);
        const res = await fetch(
          `/api/social/friends?fid=${farcasterId}&gameId=${activeGame?.id}`,
          { cache: "no-store", signal: controller.signal }
        );
        if (!res.ok) throw new Error(`Request failed with ${res.status}`);
        const data = await res.json();
        setFriends(data.friends ?? []);
      } catch (err) {
        if (controller.signal.aborted) return;
        console.error("Failed to load friends", err);
        setFriends([]);
        setFriendsError("Could not load your friends right now.");
      } finally {
        if (!controller.signal.aborted) {
          setFriendsLoading(false);
        }
      }
    };

    loadFriends();
    return () => controller.abort();
  }, [farcasterId, activeGame?.id, ticket?.id]);

  const prizePool = useMemo(() => {
    if (!stats) return null;
    return stats.totalPrize;
  }, [stats]);

  const spotsAvatars = useMemo(() => {
    const friendAvatars = friends
      .filter((friend) => friend.hasTicket && friend.pfpUrl)
      .map((friend) => friend.pfpUrl!)
      .slice(0, 4);
    if (friendAvatars.length > 0) return friendAvatars;
    const statsAvatars =
      stats?.players
        ?.map((player) => player.pfpUrl)
        .filter((url): url is string => Boolean(url)) ?? [];
    if (statsAvatars.length > 0) return statsAvatars.slice(0, 4);
    return [
      "/images/avatars/a.png",
      "/images/avatars/b.png",
      "/images/avatars/c.png",
      "/images/avatars/d.png",
    ];
  }, [friends, stats]);

  return (
    <div className="h-screen flex flex-col app-background noise relative font-body">
      {/* HEADER */}
      <div
        className={cn(
          "p-4 flex items-center justify-between border-b border-border app-background"
        )}
      >
        <LogoIcon />
        <div className="flex items-center gap-1.5 app-background rounded-full px-3 py-1.5">
          <WalletIcon className="w-4 h-4 text-foreground" />
          <span className="text-xs text-foreground">{`$${roundedBalance}`}</span>
        </div>
      </div>

      {/* MAIN CONTENT */}
      <div className="flex-1 flex flex-col items-center gap-3 justify-center overflow-y-auto">
        {showShare && activeGame ? (
          <Share
            gameTitle={activeGame.name}
            theme={activeGame.description || "See you Friday."}
            username={user.username || "Player"}
            avatarUrl={user.pfpUrl || "/images/avatars/a.png"}
            prizePool={prizePool}
            onShare={shareTicket}
            onBackHome={handleBackToHome}
          />
        ) : (
          <>
            <div className="mb-6">
              <Image
                src="/images/illustrations/waffle-ticket.png"
                alt="Waffle Ticket"
                width={152}
                height={93}
                className="mx-auto"
                style={{ imageRendering: "pixelated" }}
                priority
              />
            </div>

            <h1 className="text-foreground text-3xl text-center leading-tight">
              <span className="block">GET YOUR</span>
              <span className="block">WAFFLE</span>
            </h1>

            {/* BUY BUTTON */}
            <div className="w-full max-w-[400px] px-4">
              <FancyBorderButton
                onClick={handlePurchase}
                disabled={isPurchasing}
              >
                {isPurchasing ? "PROCESSING..." : "BUY WAFFLE"}
              </FancyBorderButton>
              {purchaseError && (
                <p className="mt-3 text-center text-sm text-red-400">
                  {purchaseError}
                </p>
              )}
            </div>
          </>
        )}

        {/* INVITE */}
        <button
          className="flex items-center gap-1 text-xs font-bold text-[#00CFF2] hover:underline focus:outline-none"
          tabIndex={0}
          onClick={handleOpenInvite}
        >
          <InviteIcon />
          INVITE FRIENDS{" "}
          <span className="text-xs font-bold ml-1">(20% BOOST!)</span>
        </button>

        {activeGame && (
          <SpotsLeft
            current={stats?.totalTickets || 0}
            total={activeGame.config!.maxPlayers}
            avatars={spotsAvatars}
          />
        )}

        <FriendsList
          friends={friends}
          isLoading={friendsLoading}
          error={friendsError}
        />
      </div>

      <BottomNav />
      <InviteFriendsDrawer
        open={isInviteOpen}
        code={myReferral?.code || "------"}
        onClose={() => setInviteOpen(false)}
      />
    </div>
  );
}

function FriendsList({
  friends,
  isLoading,
  error,
}: {
  friends: FriendSummary[];
  isLoading: boolean;
  error: string | null;
}) {
  if (error) {
    return <div className="mt-6 text-sm text-red-400">{error}</div>;
  }

  if (isLoading) {
    return <div className="mt-6 text-sm text-muted">Loading your friends…</div>;
  }

  if (!friends.length) return null;

  return (
    <section className="mt-8 w-full max-w-[420px] px-4">
      <h2 className="text-sm font-display uppercase tracking-wide text-[#99A0AE]">
        Your friends
      </h2>
      <ul className="mt-3 space-y-3">
        {friends.slice(0, 8).map((friend) => (
          <li
            key={friend.fid}
            className="flex items-center justify-between rounded-2xl border border-white/10 bg-black/25 px-3 py-2 backdrop-blur"
          >
            <div className="flex items-center gap-3">
              <div className="relative size-10 overflow-hidden rounded-full border border-white/10">
                <Image
                  src={friend.pfpUrl || "/images/avatars/a.png"}
                  alt={friend.username}
                  fill
                  className="object-cover"
                />
              </div>
              <div className="flex flex-col">
                <span className="font-edit-undo text-white">
                  {friend.displayName || friend.username}
                </span>
                <span className="text-xs font-display text-[#99A0AE]">
                  @{friend.username}
                </span>
              </div>
            </div>
            <span
              className={cn(
                "text-xs font-edit-undo uppercase",
                friend.hasTicket ? "text-[#14B985]" : "text-[#FB72FF]"
              )}
            >
              {friend.hasTicket ? "Ticket secured" : "Needs ticket"}
            </span>
          </li>
        ))}
      </ul>
    </section>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/useInfiniteLoader.ts ---
"use client";

import { useEffect, useRef } from "react";

export function useInfiniteLoader(
  onHit: () => void,
  deps: unknown[] = []
): [React.RefObject<HTMLDivElement>] {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const el = ref.current;
    if (!el) return;

    const io = new IntersectionObserver(
      ([e]) => {
        if (e.isIntersecting) onHit();
      },
      { root: null, rootMargin: "400px 0px 800px 0px", threshold: 0 }
    );

    io.observe(el);
    return () => io.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return [ref as React.RefObject<HTMLDivElement>];
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Tabs.tsx ---
"use client";
import type { LeaderboardTabKey as TabKey } from "@/state";
import { PixelButton } from "@/components/buttons/PixelButton";

export function Tabs({
  active,
  onChange,
}: {
  active: TabKey;
  onChange: (t: TabKey) => void;
}) {
  return (
    <div className="inline-flex items-center gap-2" role="tablist">
      {(["current", "allTime"] as const).map((k) => {
        const selected = active === k;
        return (
          <PixelButton
            key={k}
            role="tab"
            aria-selected={selected}
            backgroundColor={selected ? "white" : ""}
            textColor={selected ? "black" : "var(--color-waffle-gold)"}
            borderColor={"var(--color-waffle-gold)"}
            onClick={() => onChange(k)}
            borderWidth={4}
            className={[
              // Responsive paddings and text size
              "px-4 py-2 text-xs sm:px-6 sm:py-2 sm:text-sm",
              selected ? "font-bold" : "opacity-80 hover:opacity-100",
              selected ? "noise" : "app-background noise",
              "transition",
            ].join(" ")}
            tabIndex={selected ? 0 : -1}
          >
            {k === "current" ? "Current game" : "All time"}
          </PixelButton>
        );
      })}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Row.tsx ---
import { LeaderboardEntry as Entry } from "@/state";
import { UsdcIcon } from "@/components/icons";
import Image from "next/image";

export function Row({ entry }: { entry: Entry }) {
  return (
    <div className="panel flex h-12 items-center justify-between rounded-xl px-4">
      <div className="flex items-center gap-2">
        <div className="grid h-7 w-7 place-items-center rounded-full bg-white/10">
          <span className="text-xs leading-tight">{entry.rank}</span>
        </div>
        <div className="flex items-center gap-2">
          {entry.pfpUrl && (
            <Image
              src={entry.pfpUrl}
              alt={entry.username}
              width={30}
              height={30}
              className="rounded-full bg-[#F0F3F4] object-cover"
              draggable={false}
            />
          )}
          {!entry.pfpUrl && (
            <div className="grid h-7 w-7 place-items-center rounded-full bg-white/10">
              <span className="text-xs leading-tight">{entry.rank}</span>
            </div>
          )}
          <div className="text-sm leading-tight">{entry.username}</div>
        </div>
      </div>
      <div className="flex items-center gap-2">
        <UsdcIcon className="h-4 w-4" />
        <div className="font-display font-medium text-base tracking-tight">
          {entry.points.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          })}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Top3.tsx ---
import { LeaderboardEntry as Entry } from "@/state";
import { TrophyIcon, UsdcIcon } from "@/components/icons";

/** Top3: fixed single row (no wrap), fully responsive, no overflow */
export function Top3({ entries }: { entries: Entry[] }) {
  if (!entries?.length) return null;

  const cardStyles = [
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(52,199,89,0.12)]",
      trophy: "#34C759",
    },
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(25,171,211,0.12)]",
      trophy: "#19ABD3",
    },
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(211,77,25,0.12)]",
      trophy: "#D34D19",
    },
  ];

  return (
    <div
      className="
        flex w-full flex-nowrap items-stretch
        /* gap collapses on tiny screens, grows on wide */
        gap-[var(--gap)]
      "
      style={
        {
          // tune spacing & padding with CSS vars (works with Tailwind arbitrary values)
          ["--gap"]: "clamp(0.25rem, 2.2vw, 1rem)",
          ["--pad"]: "clamp(0.5rem, 2.2vw, 1rem)",
          ["--radius"]: "clamp(0.75rem, 2vw, 1rem)",
        } as React.CSSProperties
      }
    >
      {entries.slice(0, 3).map((entry, i) => (
        <article
          key={entry.rank}
          className={[
            "basis-1/3 min-w-0 flex-1",
            "rounded-[var(--radius)] border border-white/10",
            "p-[var(--pad)] bg-clip-padding",
            "flex flex-col gap-[calc(var(--pad)*1)]",
            "transition-shadow hover:shadow-lg",
            cardStyles[i]?.bg ?? "",
          ].join(" ")}
        >
          {/* trophy */}
          <TrophyIcon
            color={cardStyles[i]?.trophy}
            className="flex-shrink-0"
            style={{
              width: "clamp(14px, 2.8vw, 20px)",
              height: "clamp(14px, 2.8vw, 20px)",
            }}
            aria-label={`Place ${i + 1}`}
          />

          {/* avatar + name */}
          <div className="flex min-w-0 items-center gap-[calc(var(--pad)*0.5)]">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={entry.pfpUrl || "/avatar.png"}
              alt={entry.username}
              draggable={false}
              className="rounded-full bg-[#F0F3F4] object-cover flex-shrink-0"
              style={{
                width: "clamp(18px, 3vw, 24px)",
                height: "clamp(18px, 3vw, 24px)",
              }}
            />
            <span
              title={entry.username}
              className="
                min-w-0 truncate text-white font-body font-normal leading-tight
              "
              style={{ fontSize: "clamp(0.7rem, 2.3vw, 0.95rem)" }}
            >
              {entry.username}
            </span>
          </div>

          {/* score */}
          <div className="mt-auto flex items-center gap-[calc(var(--pad)*0.5)]">
            <UsdcIcon
              className="flex-shrink-0"
              style={{
                width: "clamp(14px, 2.8vw, 20px)",
                height: "clamp(14px, 2.8vw, 20px)",
              }}
            />
            <span
              className="font-display font-medium tracking-tight leading-[1.1]"
              style={{ fontSize: "clamp(0.85rem, 2.6vw, 1rem)" }}
            >
              {entry.points.toLocaleString(undefined, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              })}
            </span>
          </div>
        </article>
      ))}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/page.tsx ---
"use client";

import Image from "next/image";
import { useEffect, useMemo, useRef } from "react";
import { Tabs } from "./_components/Tabs";
import { useLeaderboard, LeaderboardEntry as Entry } from "@/state";
import { Top3 } from "./_components/Top3";
import { Row } from "./_components/Row";
import { WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";

export default function LeaderboardPage() {
  const { activeTab, slices, setActiveTab, fetchLeaderboard, rememberScroll } =
    useLeaderboard();

  const slice = slices[activeTab];

  // ───────────────────────── DATA PREP ─────────────────────────
  const top3 = useMemo<Entry[]>(
    () => slice.entries.slice(0, 3),
    [slice.entries]
  );
  const rest = useMemo<Entry[]>(() => slice.entries.slice(3), [slice.entries]);

  // ───────────────────────── HERO ANIMATION ─────────────────────────
  const crownRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const el = crownRef.current;
    if (!el) return;
    const io = new IntersectionObserver(
      ([e]) => {
        const ratio = 1 - e.intersectionRatio;
        document.documentElement.style.setProperty(
          "--lb-progress",
          `${Math.min(Math.max(ratio, 0), 1)}`
        );
      },
      { threshold: Array.from({ length: 21 }, (_, i) => i / 20) }
    );
    io.observe(el);
    return () => io.disconnect();
  }, []);

  // ───────────────────────── SCROLL PERSISTENCE ─────────────────────────
  useEffect(() => setActiveTab(activeTab), [activeTab, setActiveTab]);

  useEffect(() => {
    const onScroll = () => rememberScroll(activeTab, window.scrollY);
    window.addEventListener("scroll", onScroll, { passive: true });
    return () => window.removeEventListener("scroll", onScroll);
  }, [activeTab, rememberScroll]);

  useEffect(() => {
    requestAnimationFrame(() =>
      window.scrollTo({
        top: slices[activeTab].scrollTop ?? 0,
        behavior: "instant" as const,
      })
    );
  }, [activeTab, slices]);

  // ───────────────────────── FETCHING ─────────────────────────
  useEffect(() => {
    const s = slices[activeTab];
    if (!s.entries.length && !s.isLoading) {
      fetchLeaderboard(activeTab).catch(console.error);
    }
  }, [activeTab, slices, fetchLeaderboard]);

  const loadMore = () => {
    const s = slices[activeTab];
    if (!s.isLoading && s.hasMore) {
      fetchLeaderboard(activeTab).catch(console.error);
    }
  };

  // ───────────────────────── OPTIONAL AUTO-REFRESH ─────────────────────────
  // 💡 Toggle ON/OFF easily by commenting this block ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  useEffect(() => {
    if (activeTab !== "current") return; // refresh only for current game
    const interval = setInterval(() => {
      fetchLeaderboard("current", { replace: true }).catch(console.error);
    }, 15000); // every 15 seconds
    return () => clearInterval(interval);
  }, [activeTab, fetchLeaderboard]);
  // 💡 End of auto-refresh block ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

  // ───────────────────────── RENDER ─────────────────────────
  return (
    <main className="min-h-[100dvh] app-background">
      {/* HEADER */}
      <header className="sticky top-0 z-20 w-full border-b border-white/20 px-4 py-3 app-background">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between ">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center"
                style={{ fontSize: "clamp(0.95rem, 1.9vw, 1rem)" }}
              >
                $983.23
              </span>
            </div>
          </div>
        </div>
      </header>

      {/* HERO + TABS */}
      <section className="mx-auto max-w-screen-sm px-4 pt-6 md:pt-10 relative">
        <div ref={crownRef} className="relative grid place-items-center">
          <Image
            src="/images/chest-crown.png"
            alt=""
            width={320}
            height={260}
            priority
            className="h-[180px] w-auto md:h-[220px] will-change-transform transition-[opacity,transform] duration-300"
            style={{
              opacity: `calc(1 - var(--lb-progress, 0))`,
              transform: `translateY(calc(-8px * var(--lb-progress, 0))) scale(calc(1 - 0.05 * var(--lb-progress, 0)))`,
            }}
          />
        </div>

        <div className="sticky top-14 z-10 -mx-4 px-4 pb-2 pt-1 bg-transparent">
          <h1 className="text-center font-body text-2xl md:text-3xl tracking-wide">
            LEADERBOARD
          </h1>

          <div className="mt-5 flex items-center justify-center gap-6">
            <Tabs active={activeTab} onChange={setActiveTab} />
          </div>

          <p className="mt-4 text-center text-muted font-display">
            {activeTab === "current"
              ? "Real-time standings from the current game"
              : "The greatest of all time"}
          </p>
        </div>
      </section>

      {/* LIST */}
      <section className="mx-auto max-w-screen-sm px-4 pb-24 pt-4 space-y-4">
        <Top3 entries={top3} />

        <div className="space-y-3">
          {rest.map((e) => (
            <Row key={e.rank} entry={e} />
          ))}

          {slice.isLoading && (
            <div className="h-11 rounded-2xl panel animate-pulse" />
          )}
          {slice.error && (
            <div className="panel px-4 py-3 text-sm text-danger">
              {slice.error}
            </div>
          )}
          {!slice.isLoading && !slice.entries.length && !slice.error && (
            <div className="panel px-4 py-6 text-center text-sm text-muted">
              Nothing here yet.
            </div>
          )}

          <button
            onFocus={loadMore}
            onMouseEnter={loadMore}
            onClick={loadMore}
            disabled={slice.isLoading}
            className="mx-auto block h-10 w-full max-w-[220px] rounded-xl border border-white/10 bg-white/5 text-sm transition disabled:opacity-50"
          >
            {slice.hasMore
              ? slice.isLoading
                ? "Loading…"
                : "Load more"
              : "End"}
          </button>
        </div>
      </section>

      <BottomNav />
    </main>
  );
}

--- File: ./src/app/(authenticated)/game/_components/GradientMask.tsx ---
"use client";

import Image from "next/image";
import clsx from "clsx";

/**
 * Bottom fade overlay that masks an image (or uses a solid fill if no src).
 *
 * - Sits on top of content (pointer-events: none)
 * - Width is responsive: clamps to container, not fixed Figma px
 * - Height is configurable (defaults to ~136px from the comp)
 *
 * Example:
 * <GradientMask className="bottom-24" src="/noise-bottom.png" />
 */
export default function GradientMask({
  className,
  height = 136,
  src,
  alt = "",
}: {
  className?: string;
  height?: number;
  /** Optional image to “fade”; if omitted we just fade a solid. */
  src?: string;
  alt?: string;
}) {
  return (
    <div
      aria-hidden
      className={clsx(
        "pointer-events-none absolute left-1/2 -translate-x-1/2 w-[min(94vw,40rem)]", // ~377px max but responsive
        className
      )}
      style={{ height }}
    >
      {src ? (
        <div className="relative h-full w-full">
          <Image
            src={src}
            alt={alt}
            fill
            sizes="(max-width: 768px) 94vw, 40rem"
            className={clsx(
              "object-cover",
              // Mask the image so it fades in (transparent → opaque) towards the bottom.
              "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
              "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]"
            )}
            priority
          />
        </div>
      ) : (
        // Fallback: just fade a solid surface to the page background.
        <div
          className={clsx(
            "h-full w-full",
            "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "bg-background"
          )}
        />
      )}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/ChatTickerOverlay.tsx ---
import { useEffect, useMemo, useRef } from "react";
import Image from "next/image";
import clsx from "clsx";
import { useGame } from "@/state";

export default function ChatTickerOverlay({
  className,
  maxItems = 4,
}: {
  className?: string;
  maxItems?: number;
}) {
  const { messages } = useGame();
  const containerRef = useRef<HTMLDivElement>(null);

  const items = useMemo(() => {
    const trimmed = messages.slice(-maxItems);
    return trimmed.map((m, i) => ({
      id: `${i}-${m.user.name}-${m.message.slice(0, 6)}`,
      username: m.user.name ?? "anon",
      message: m.message ?? "",
      avatar: m.user.imageUrl as string | undefined,
    }));
  }, [messages, maxItems]);

  useEffect(() => {
    const el = containerRef.current;
    if (el) el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
  }, [items.length]);

  return (
    <div
      aria-hidden
      className={clsx(
        "pointer-events-none absolute z-20 left-1/2 -translate-x-1/2 w-[min(94vw,40rem)] font-display",
        className
      )}
    >
      <div
        ref={containerRef}
        className="max-h-[7.5rem] overflow-hidden px-2 text-white/60"
        style={{
          WebkitMaskImage:
            "linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.1) 10%, rgba(0,0,0,1) 25%, rgba(0,0,0,1) 100%)",
          maskImage:
            "linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.1) 10%, rgba(0,0,0,1) 25%, rgba(0,0,0,1) 100%)",
        }}
      >
        <ul className="space-y-1.5">
          {items.map((m) => (
            <li
              key={m.id}
              className="flex items-start gap-2 text-xs sm:text-sm leading-relaxed"
            >
              <AvatarCircle src={m.avatar} name={m.username} />
              <div className="mt-[1px]">
                <span className="font-medium text-white/70">{m.username}</span>{" "}
                <span className="text-white/60">{m.message}</span>
              </div>
            </li>
          ))}
          <li className="h-2" />
        </ul>
      </div>
    </div>
  );
}

function AvatarCircle({ src, name }: { src?: string; name: string }) {
  const initial = name?.trim()?.charAt(0)?.toUpperCase() || "•";
  return src ? (
    <div className="relative mt-[2px] size-5 shrink-0 overflow-hidden rounded-full ring-1 ring-white/5">
      <Image src={src} alt={name} fill className="object-cover" />
    </div>
  ) : (
    <div className="grid size-5 shrink-0 place-items-center rounded-full bg-white/10 text-[.65rem] text-white/70 ring-1 ring-white/5">
      {initial}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/RoundCountdownView.tsx ---
"use client";

import { useGame } from "@/state";
import ChatTickerOverlay from "./ChatTickerOverlay";
import ChatDrawer from "./ChatDrawer";
import { useCountdown } from "@/hooks/useCountdown";

/** blue used in mocks */
const BLUE = "#1E8BFF";

export default function RoundCountdownStage() {
  const { state: gameStateType, activeGame } = useGame();
  const { setStateType } = useGame();
  const totalSeconds = activeGame?.config?.roundTimeLimit ?? 0;
  const { millisecondsLeft, secondsLeft } = useCountdown({
    durationSeconds: totalSeconds,
    autoStart: gameStateType === "GAME_LIVE_ROUND_COUNTDOWN",
    onComplete: () => {
      // Move into the next question after the round countdown fully elapses
      setStateType("GAME_LIVE");
    },
  });
  const ratio =
    totalSeconds > 0
      ? Math.max(0, Math.min(1, millisecondsLeft / (totalSeconds * 1000)))
      : 0;

  return (
    <div>
      <section className="mx-auto w-full max-w-screen-sm px-4 pt-10 pb-8">
        <p className="mb-6 text-center text-white/85">PLEASE WAIT</p>

        <h1
          className="mb-8 text-center font-bold leading-tight whitespace-nowrap overflow-hidden text-ellipsis"
          style={{
            fontSize: "clamp(1.15rem, 7vw, 2.5rem)",
            letterSpacing: "-0.03em",
          }}
        >
          NEXT&nbsp;ROUND&nbsp;IN
        </h1>

        <div className="grid place-items-center">
          <CountdownCircle
            ratio={ratio}
            total={totalSeconds}
            secondsLeft={secondsLeft}
          />
        </div>

        <p className="mt-10 text-center text-muted text-lg font-display">
          Get ready for the next round!
        </p>
      </section>

      <section>
        <ChatTickerOverlay />
        <ChatDrawer />
      </section>
    </div>
  );
}

/* ——————————— visual countdown ring ——————————— */
function CountdownCircle({
  total,
  ratio,
  secondsLeft,
}: {
  total: number;
  ratio: number;
  secondsLeft: number;
}) {
  const size = 240; // px
  const stroke = 14;
  const r = (size - stroke) / 2;
  const clampedRatio = Math.max(0, Math.min(1, ratio));
  const circumference = 2 * Math.PI * r;
  const dashOffset = circumference * (1 - clampedRatio);
  const angle = clampedRatio * 360 - 90;
  const dotDistance = r;

  return (
    <div
      className="relative"
      style={{ width: size, height: size }}
      aria-label="Next round countdown"
      role="timer"
      aria-live="polite"
    >
      <svg
        width={size}
        height={size}
        viewBox={`0 0 ${size} ${size}`}
        className="block"
      >
        {/* track */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke="rgba(255,255,255,0.15)"
          strokeWidth={stroke}
        />
        {/* progress */}
        <g transform={`rotate(-90 ${size / 2} ${size / 2})`}>
          <circle
            cx={size / 2}
            cy={size / 2}
            r={r}
            fill="none"
            stroke={BLUE}
            strokeWidth={stroke}
            strokeLinecap="round"
            strokeDasharray={circumference}
            strokeDashoffset={dashOffset}
            style={{ transition: "stroke-dashoffset 1s linear" }}
          />
        </g>
      </svg>

      {/* orbiting dot */}
      <div
        className="absolute left-1/2 top-1/2"
        style={{
          transform: `translate(-50%, -50%) rotate(${angle}deg)`,
          transition: "transform 1s linear",
          width: size,
          height: size,
          pointerEvents: "none",
        }}
      >
        <span
          className="absolute block rounded-full"
          style={{
            width: stroke + 6,
            height: stroke + 6,
            background: BLUE,
            left: "50%",
            top: "50%",
            transform: `translate(-50%, -50%) translateY(${-dotDistance}px)`,
            boxShadow: "0 0 0 2px rgba(30,139,255,0.35)",
          }}
        />
      </div>

      {/* numeric value - remaining whole seconds */}
      <div className="pointer-events-none absolute inset-0 grid place-items-center">
        <span
          className="text-[12vw] sm:text-7xl md:text-8xl lg:text-9xl font-bold leading-none text-white"
          style={{
            fontSize: "clamp(2.5rem, 10vw, 7rem)",
          }}
        >
          {String(Math.max(0, Math.min(total, secondsLeft))).padStart(2, "0")}
        </span>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/GameOverView.tsx ---
"use client";

import Image from "next/image";
import {
  useCallback,
  useEffect,
  useMemo,
  useState,
  type ReactNode,
} from "react";
import { useRouter } from "next/navigation";

import { useGame, useLobby } from "@/state";
import { useMiniUser } from "@/hooks/useMiniUser";
import { ZapIcon, WinningsIcon, TrophyIcon } from "@/components/icons";
import { cn } from "@/lib/utils";
import { useComposeCast } from "@coinbase/onchainkit/minikit";
import { env } from "@/lib/env";

type SummaryState =
  | { status: "idle" | "loading" }
  | {
      status: "ready";
      data: {
        rank: number;
        score: number;
        totalPlayers: number;
        totalPoints: number;
        username: string;
        avatarUrl: string | null;
      };
    }
  | { status: "error"; message: string };

const numberFormatter = new Intl.NumberFormat("en-US");
const formatNumber = (value: number | null | undefined) =>
  numberFormatter.format(Math.max(0, Math.round(value ?? 0)));

export default function GameOverView() {
  const router = useRouter();
  const { activeGame } = useGame();

  const {
    fid,
    username: fallbackUsername,
    pfpUrl: fallbackAvatar,
  } = useMiniUser();

  const { stats: lobbyStats, refreshStats: fetchLobbyStats } = useLobby();

  const [summary, setSummary] = useState<SummaryState>({ status: "idle" });

  // Ensure prize/pool stats are available for earnings interpolation.
  useEffect(() => {
    if (!lobbyStats) {
      fetchLobbyStats().catch((err) =>
        console.error("Failed to load lobby stats", err)
      );
    }
  }, [lobbyStats, fetchLobbyStats]);

  useEffect(() => {
    if (!fid || !activeGame?.id) return;

    const controller = new AbortController();

    const loadSummary = async () => {
      setSummary({ status: "loading" });
      try {
        let userId: number | null = null;
        let resolvedName = fallbackUsername || "Player";
        let resolvedAvatar = fallbackAvatar ?? null;

        const userRes = await fetch(
          `/api/user?farcasterId=${encodeURIComponent(String(fid))}`,
          { signal: controller.signal }
        );
        if (userRes.ok) {
          const payload = await userRes.json();
          if (payload?.user) {
            userId = payload.user.id ?? null;
            resolvedName = payload.user.name ?? resolvedName;
            resolvedAvatar = payload.user.imageUrl ?? resolvedAvatar;
          }
        }

        const params = new URLSearchParams({
          tab: "current",
          page: "0",
          gameId: String(activeGame.id),
        });
        if (userId) params.set("userId", String(userId));

        const standingsRes = await fetch(
          `/api/leaderboard?${params.toString()}`,
          { cache: "no-store", signal: controller.signal }
        );
        if (!standingsRes.ok) throw new Error("Failed to load final standings");
        const standings = await standingsRes.json();

        const me =
          standings.me ??
          standings.users?.find(
            (entry: { id: string }) => Number(entry.id) === userId
          );

        if (!me) {
          throw new Error("Unable to determine your final rank.");
        }

        setSummary({
          status: "ready",
          data: {
            rank: me.rank ?? 0,
            score: me.points ?? 0,
            totalPlayers:
              standings.totalPlayers ?? standings.users?.length ?? 0,
            totalPoints: standings.totalPoints ?? 0,
            username: me.name || resolvedName || "Player",
            avatarUrl: me.imageUrl || resolvedAvatar,
          },
        });
      } catch (error) {
        if (controller.signal.aborted) return;
        console.error("Failed to prepare game over summary", error);
        setSummary({
          status: "error",
          message:
            error instanceof Error
              ? error.message
              : "Something went wrong while loading your results.",
        });
      }
    };

    loadSummary();

    return () => controller.abort();
  }, [fid, activeGame?.id, fallbackAvatar, fallbackUsername]);

  const earnings = useMemo(() => {
    if (summary.status !== "ready") return 0;
    const totalPrize = lobbyStats?.totalPrize ?? 0;
    if (!totalPrize || summary.data.totalPoints <= 0) return 0;
    return Math.round(
      (summary.data.score / summary.data.totalPoints) * totalPrize
    );
  }, [summary, lobbyStats]);

  const percentile = useMemo(() => {
    if (summary.status !== "ready") return null;
    const { rank, totalPlayers } = summary.data;
    if (!rank || !totalPlayers) return null;
    return Math.max(
      0,
      Math.min(100, Math.round(((totalPlayers - rank) / totalPlayers) * 100))
    );
  }, [summary]);

  const { composeCastAsync } = useComposeCast();

  const handleShare = useCallback(async () => {
    if (summary.status !== "ready") return;
    const { rank, score } = summary.data;
    const message = `I placed #${rank} with a score of ${formatNumber(
      score
    )} in Waffles!`;

    try {
      const result = await composeCastAsync({
        text: message,
        embeds: [env.rootUrl || ""],
      });

      // result.cast can be null if user cancels
      if (result?.cast) {
        console.log("Cast created successfully:", result.cast.hash);
      } else {
        console.log("User cancelled the cast");
      }

      // result.cast can be null if user cancels; do nothing in either case
    } catch (error) {
      console.error("Error sharing to Farcaster:", error);
    }
  }, [summary, composeCastAsync]);

  const handleBackHome = useCallback(() => {
    router.replace("/lobby");
  }, [router]);

  const handleViewLeaderboard = useCallback(() => {
    router.push("/leaderboard");
  }, [router]);

  const headingTheme =
    activeGame?.description || activeGame?.name || "Game Over";

  const rankDisplay =
    summary.status === "ready" ? `#${summary.data.rank}` : "--";
  const scoreDisplay =
    summary.status === "ready" ? formatNumber(summary.data.score) : "--";
  const earningsDisplay =
    summary.status === "ready" ? formatNumber(earnings) : "--";
  const playerName =
    summary.status === "ready"
      ? summary.data.username
      : fallbackUsername || "Player";
  const avatarUrl =
    summary.status === "ready"
      ? summary.data.avatarUrl
      : fallbackAvatar ?? "/images/avatars/a.png";

  return (
    <main className="relative min-h w-full app-background noise">
      <div className="relative mx-auto flex w-full max-w-lg flex-col items-center px-4 pb-[calc(env(safe-area-inset-bottom)+7vw)] pt-12 sm:pt-16">
        <div className="w-full flex justify-center">
          <Image
            src="/images/illustrations/waffle-ticket.png"
            alt="Pixel waffle"
            width={228}
            height={132}
            priority
            className="mb-6 w-full max-w-xs h-auto"
            style={{
              aspectRatio: "228/132",
              height: "auto",
              width: "100%",
              maxWidth: "228px",
            }}
          />
        </div>

        <h1
          className="font-edit-undo text-white leading-none"
          style={{
            fontSize: "clamp(2rem, 9vw, 2.75rem)",
            letterSpacing: "-0.03em",
          }}
        >
          GAME OVER
        </h1>

        <p className="mt-1 text-base sm:text-lg font-display text-[#99A0AE] text-center">
          {headingTheme}
        </p>

        <div className="mt-10 flex w-full max-w-md flex-col items-center gap-3">
          <div className="w-full rounded-3xl border border-white/10 bg-[radial-gradient(circle_at_top,_rgba(255,255,255,0.18),_rgba(0,0,0,0))] p-4 backdrop-blur-sm">
            <div className="flex flex-wrap items-center justify-between gap-3 rounded-2xl border border-white/10 bg-black/20 px-3 py-2">
              <span className="mx-auto text-sm font-display text-[#99A0AE] whitespace-nowrap">
                Your final rank
              </span>
              <div className="flex items-center gap-2 min-w-0">
                <div className="relative aspect-square w-8 h-8 overflow-hidden rounded-full border border-white/20 shrink-0">
                  <Image
                    src={avatarUrl || "/images/avatars/a.png"}
                    alt={playerName}
                    fill
                    className="object-cover"
                  />
                </div>
                <span className="font-edit-undo text-white truncate max-w-[8rem]">
                  {playerName}
                </span>
              </div>
            </div>

            <div className="mt-6 flex items-center justify-between gap-4 flex-wrap">
              <div>
                <p
                  className="font-edit-undo text-white"
                  style={{
                    fontSize: "clamp(2.25rem, 13vw, 4.5rem)",
                    lineHeight: "0.9",
                  }}
                >
                  {rankDisplay}
                </p>
              </div>
              <div
                className="flex items-center justify-center"
                style={{
                  height: "clamp(2.5rem, 10vw, 4.375rem)",
                  width: "clamp(2.5rem, 10vw, 4.375rem)",
                  minWidth: "2.5rem",
                }}
              >
                <TrophyIcon
                  className="w-full h-full text-[#FFC931]"
                  aria-label="Trophy"
                />
              </div>
            </div>

            <div className="mt-4 grid grid-cols-2 gap-3">
              <StatCard
                label="Score"
                value={scoreDisplay}
                icon={<ZapIcon className="h-5 w-5 text-[#FFC931]" />}
              />
              <StatCard
                label="Earnings"
                value={earningsDisplay}
                icon={<WinningsIcon className="h-5 w-5 text-[#14B985]" />}
                prefix="$"
              />
            </div>

            {summary.status === "error" && (
              <p className="mt-4 text-center text-sm text-red-400">
                {summary.message}
              </p>
            )}
            {summary.status === "loading" && (
              <p className="mt-4 text-center text-sm text-muted">
                Calculating final standings…
              </p>
            )}
          </div>

          <button
            onClick={handleShare}
            className={cn(
              "w-full rounded-xl bg-white px-6 py-4 text-center font-edit-undo text-2xl text-[#14B985] transition active:translate-x-[2px] active:translate-y-[2px]",
              "border-r-[5px] border-b-[5px] border-[#14B985]",
              "sm:text-2xl text-xl"
            )}
            style={{
              fontSize: "clamp(1.125rem, 4vw, 1.5rem)",
              padding:
                "clamp(0.875rem, 3vw, 1.25rem) clamp(1.25rem, 6vw, 1.5rem)",
            }}
          >
            SHARE SCORE
          </button>

          <div className="flex w-full flex-row items-center justify-between max-w-md flex-wrap gap-2">
            <TextButton onClick={handleBackHome}>BACK TO HOME</TextButton>
            <TextButton onClick={handleViewLeaderboard}>
              VIEW LEADERBOARD
            </TextButton>
          </div>

          {percentile !== null && (
            <div className="mt-4 flex items-center gap-2 text-sm font-display text-white">
              <ZapIcon className="h-4 w-4 text-[#FFC931]" />
              <span className="truncate">
                You finished faster than {percentile}% of your friends
              </span>
            </div>
          )}
        </div>
      </div>
    </main>
  );
}

function StatCard({
  label,
  value,
  icon,
  prefix,
}: {
  label: string;
  value: string;
  icon: ReactNode;
  prefix?: string;
}) {
  return (
    <div className="flex-1 rounded-[16px] border border-white/10 bg-white/5 px-3 py-3 backdrop-blur-sm">
      <p className="text-sm font-display text-[#99A0AE]">{label}</p>
      <div className="mt-2 flex items-center gap-2">
        {icon}
        <span className="font-edit-undo text-2xl text-white">
          {prefix}
          {value}
        </span>
      </div>
    </div>
  );
}

function TextButton({
  children,
  onClick,
}: {
  children: ReactNode;
  onClick: () => void;
}) {
  return (
    <button
      onClick={onClick}
      className="text-sm font-edit-undo uppercase text-[#00CFF2] transition hover:text-[#33defa]"
    >
      {children}
    </button>
  );
}

--- File: ./src/app/(authenticated)/game/_components/QuestionTop.tsx ---
"use client";

import { useMemo } from "react";
import { useGame } from "@/state";

function mmss(total: number) {
  const m = Math.max(0, Math.floor(total / 60));
  const s = Math.max(0, total % 60);
  return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

/**
 * Top strip used inside QuestionView:
 *  - Left: Q index (01/20)
 *  - Right: two timers (round & question)
 *  - Row 2: Centered title (e.g., "WHO IS THIS?")
 */
export default function QuestionTop() {
  const { questionIndex: currentQuestionIndex, activeGame } = useGame();

  const qCount = useMemo(() => {
    const now = Math.max(0, currentQuestionIndex + 1);
    return `${String(now).padStart(2, "0")}/${String(
      activeGame?.questions?.length ?? 0
    ).padStart(2, "0")}`;
  }, [currentQuestionIndex, activeGame?.questions?.length]);

  return (
    <div className="w-full max-w-md sm:max-w-lg mx-auto mt-14">
      {/* Row 1: counters */}
      <div className="flex items-center justify-between px-2 xs:px-3 sm:px-4 py-1.5">
        <span className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight">
          {qCount}
        </span>

        <div className="flex items-center gap-3 sm:gap-4">
          <span
            aria-label="Round timer"
            className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight"
          >
            {mmss(activeGame?.config?.roundTimeLimit ?? 0)}
          </span>
          <span
            aria-label="Question timer"
            className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight"
          >
            {mmss(activeGame?.config?.roundTimeLimit ?? 0)}
          </span>
        </div>
      </div>

      {/* Row 2: title */}
      <div className="flex flex-col items-center gap-0.5">
        <h1 className="font-edit-undo text-white text-3xl sm:text-4xl md:text-5xl leading-[0.92] tracking-tight text-center">
          {activeGame?.questions?.[currentQuestionIndex]?.text ?? "—"}
        </h1>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/JoinGameView.tsx ---
"use client";

import { useCallback, useEffect, useMemo } from "react";
import Image from "next/image";
import { useMotionValue, useTransform } from "framer-motion";
import { CardStack } from "@/components/CardStack";
import { useGame, useLobby } from "@/state";
import { useRouter } from "next/navigation";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

const FALLBACK_AVATARS = [
  "/images/avatars/a.png",
  "/images/avatars/b.png",
  "/images/avatars/c.png",
  "/images/avatars/d.png",
];

export default function JoinGameView() {
  const router = useRouter();
  const { setStateType } = useGame();
  const { stats, refreshStats, ticket } = useLobby();

  useEffect(() => {
    if (!stats) {
      refreshStats().catch((error) =>
        console.error("Failed to refresh lobby stats before join", error)
      );
    }
  }, [stats, refreshStats]);

  const joinedCount = stats?.totalTickets ?? 0;

  const avatars = useMemo(() => {
    const players = stats?.players ?? [];

    const source =
      players.length > 0
        ? players
        : FALLBACK_AVATARS.map((src, index) => ({
            username: `guest-${index + 1}`,
            wallet: "",
            pfpUrl: src,
          }));

    return source.slice(0, 4).map((player, index) => ({
      src: player.pfpUrl || FALLBACK_AVATARS[index % FALLBACK_AVATARS.length],
      alt: player.username || `Player ${index + 1}`,
    }));
  }, [stats?.players]);

  const bx = useMotionValue(0);
  const by = useMotionValue(0);
  // const bRotateX = useTransform(by, [-40, 40], [6, -6]);
  // const bRotateY = useTransform(bx, [-40, 40], [-6, 6]);

  const onBtnMove: React.PointerEventHandler<HTMLButtonElement> = (e) => {
    const rect = (e.currentTarget as HTMLElement).getBoundingClientRect();
    bx.set(e.clientX - (rect.left + rect.width / 2));
    by.set(e.clientY - (rect.top + rect.height / 2));
  };

  const onBtnLeave = () => {
    bx.set(0);
    by.set(0);
  };

  const canJoin = Boolean(ticket);

  const handleJoin = useCallback(() => {
    if (!canJoin) {
      router.replace("/lobby/buy");
      return;
    }
    if (typeof window !== "undefined" && "vibrate" in navigator) {
      navigator.vibrate?.(10);
    }
    setStateType("GAME_LIVE");
  }, [setStateType, canJoin, router]);

  const joinedLabel = joinedCount === 1 ? "person has" : "people have";

  return (
    <div className="relative flex h-[100dvh] w-full overflow-hidden bg-black text-white">
      {/* Background */}
      <Image
        src="/images/game-hero.gif"
        alt="Game hero"
        fill
        priority
        className="object-cover"
      />
      <div className="absolute inset-0 bg-gradient-to-b from-black/20 via-black/60 to-black/95" />

      {/* Content Container */}
      <div className="absolute inset-0 flex flex-col justify-end px-6 pb-10 gap-6 pointer-events-none">
        {/* Join Game Button */}
        <div className="pointer-events-auto">
          <FancyBorderButton
            aria-label="Join game"
            onPointerMove={onBtnMove}
            onPointerLeave={onBtnLeave}
            disabled={!canJoin}
            onClick={handleJoin}
            className="w-full rounded-[18px] border-b-[6px] border-r-[6px] border-[#FFC931] bg-white px-6 py-4 text-center shadow-[0_6px_0_0_#FFC931] transition disabled:cursor-not-allowed disabled:opacity-70"
          >
            <span className="block font-[Edit_Undo_BRK] text-2xl leading-none text-[#F5BB1B]">
              {canJoin ? "JOIN GAME" : "TICKET REQUIRED"}
            </span>
          </FancyBorderButton>
        </div>

        {/* Avatars + Joined Count */}
        <div className="flex items-center justify-center gap-3 pointer-events-auto">
          <CardStack
            images={avatars}
            size="clamp(32px, 7vw, 52px)"
            rotations={[-8.7, 5.85, -3.57, 7.56]}
            ariaLabel="People joined"
          />
          <span className="text-sm font-display text-[#DBE0F0]">
            {joinedCount} {joinedLabel} joined the game
          </span>
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/LeaveGameDrawer.tsx ---
"use client";

import { useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";

type Props = {
  open: boolean;
  onClose: () => void;
  onConfirmLeave: () => void;
};

export default function LeaveGameDrawer({
  open,
  onClose,
  onConfirmLeave,
}: Props) {
  // Prevent background scroll when sheet is open
  useEffect(() => {
    if (!open) return;
    const prev = document.body.style.overflow;
    document.body.style.overflow = "hidden";
    return () => {
      document.body.style.overflow = prev;
    };
  }, [open]);

  // Close on ESC
  useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  return (
    <AnimatePresence>
      {open && (
        <motion.div
          role="dialog"
          aria-modal="true"
          className="fixed inset-0 z-[100] font-display"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          {/* Backdrop */}
          <div
            className="absolute inset-0 bg-black/60 backdrop-blur-sm"
            onClick={onClose}
          />

          {/* Sheet */}
          <motion.div
            className="absolute inset-x-0 bottom-0"
            initial={{ y: "100%" }}
            animate={{ y: 0 }}
            exit={{ y: "100%" }}
            transition={{ type: "spring", stiffness: 240, damping: 28 }}
          >
            <div
              className="mx-auto w-full max-w-[480px] rounded-t-2xl overflow-hidden"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Header */}
              <div className="relative bg-[#191919] border-b border-white/5 px-4 pt-3 pb-3">
                <div className="absolute left-1/2 top-2 -translate-x-1/2 h-[5px] w-9 rounded-[2.5px] bg-white/40" />
                <div className="pt-5 text-center">
                  {/* optional timer/title slot if you need it */}
                </div>
              </div>

              {/* Body (scroll area) */}
              <div
                className="noise bg-gradient-to-b from-[#1E1E1E] to-black px-4"
                style={{
                  maxHeight: "min(75vh, 644px)",
                  overflowY: "auto",
                }}
              >
                <div className="mx-auto w-full max-w-[393px] pt-8 pb-6">
                  {/* Illustration */}
                  <div className="w-full flex items-center justify-center mb-3">
                    <Image
                      src="/images/illustrations/leave-door.svg" // <- drop your pixel door here
                      alt="Leave"
                      width={84}
                      height={90}
                      priority
                    />
                  </div>

                  {/* Title */}
                  <h2
                    className="text-center font-body text-white"
                    style={{
                      fontSize: "44px",
                      lineHeight: "0.92",
                      letterSpacing: "-0.03em",
                    }}
                  >
                    RAGE QUIT?
                  </h2>

                  {/* Subtitle */}
                  <div className="mt-2 mb-6">
                    <p className="text-center font-brockmann font-medium text-[16px] leading-[130%] tracking-[-0.03em] text-[#99A0AE]">
                      Leaving so soon?
                    </p>
                  </div>

                  {/* Primary CTA (STAY) */}
                  <button
                    onClick={onClose}
                    className="group w-full rounded-xl bg-white px-4 py-[12px] border-0 relative text-center select-none"
                    style={{
                      borderRight: "5px solid var(--brand-green, #14B985)",
                      borderBottom: "5px solid var(--brand-green, #14B985)",
                    }}
                  >
                    <span
                      className="block font-body"
                      style={{
                        color: "var(--brand-green, #14B985)",
                        fontSize: "26px",
                        lineHeight: "1.15",
                        letterSpacing: "-0.02em",
                      }}
                    >
                      STAY
                    </span>
                    {/* subtle shadow base for the 'retro drop' effect */}
                    <span
                      className="pointer-events-none absolute -z-10 inset-0 translate-y-[6px] translate-x-[6px] rounded-xl"
                      style={{ background: "transparent" }}
                    />
                  </button>

                  {/* Secondary CTA (YES, LEAVE) */}
                  <div className="mt-3">
                    <button
                      onClick={onConfirmLeave}
                      className="w-full rounded-xl px-4 py-[12px] text-center"
                    >
                      <span
                        className="font-body"
                        style={{
                          color: "var(--brand-cyan, #00CFF2)",
                          fontSize: "18px",
                          lineHeight: "1.15",
                          letterSpacing: "-0.02em",
                        }}
                      >
                        YES, LEAVE
                      </span>
                    </button>
                  </div>

                  <div className="h-4" />
                </div>
              </div>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}

--- File: ./src/app/(authenticated)/game/_components/WaitingView.tsx ---
"use client";
import { useEffect } from "react";
import { Clock } from "@/components/icons";
import { AvatarDiamond } from "./AvatarDiamond";
import ChatDrawer from "./ChatDrawer";
import ChatTickerOverlay from "./ChatTickerOverlay";
import { useGame, useLobby } from "@/state";
import { useCountdown } from "@/hooks/useCountdown";

export default function WaitingView() {
  const { activeGame, setStateType } = useGame();
  const { ticket } = useLobby();

  // Get countdown targets from game start/end times, if available
  const startTimeMs = activeGame?.startTime
    ? new Date(activeGame.startTime).getTime()
    : 0;
  // const endTimeMs = game?.endTime ? new Date(game.endTime).getTime() : 0;

  // Handle immediate state updates based on start and end times
  useEffect(() => {
    // If the game has ended, jump to GAME_OVER
    if (
      activeGame?.endTime &&
      new Date(activeGame.endTime).getTime() < Date.now()
    ) {
      setStateType("GAME_OVER");
      return;
    }
    // If it's past start time but not ended, go to JOIN_GAME
    if (
      activeGame?.startTime &&
      new Date(activeGame.startTime).getTime() < Date.now() &&
      (!activeGame?.endTime ||
        new Date(activeGame.endTime).getTime() > Date.now())
    ) {
      setStateType("JOIN_GAME");
    }
  }, [activeGame?.startTime, activeGame?.endTime, setStateType]);

  // Use countdown. If game ends while waiting, go to GAME_OVER. Otherwise, JOIN_GAME on start.
  const { millisecondsLeft } = useCountdown({
    target: startTimeMs,
    autoStart: true,
    onComplete: () => {
      // If the game has ended, set to GAME_OVER; otherwise, join game.
      if (
        activeGame?.endTime &&
        new Date(activeGame.endTime).getTime() < Date.now()
      ) {
        setStateType("GAME_OVER");
      } else {
        setStateType("JOIN_GAME");
      }
    },
  });
  const totalSec = Math.max(0, Math.ceil(millisecondsLeft / 1000));
  const minutes = Math.floor(totalSec / 60);
  const seconds = totalSec % 60;

  return (
    /**
     * Root takes full height and acts as the positioning context for overlays.
     * Max width lives here, so the whole lobby sits within the game screen nicely.
     */
    <div className="w-full min-h-[92dvh] flex flex-col flex-1 app-background text-foreground overflow-hidden items-center relative max-w-screen-sm mx-auto px-4">
      <section className="flex-1 flex flex-col items-center gap-3 w-full pt-6 pb-4 overflow-visible">
        {/* Top bar */}
        <div className="flex w-full h-10 min-h-[38px] items-center justify-center gap-0.5 p-2 sm:p-3">
          {/* Title + clock */}
          <div className="order-0 flex h-7 sm:h-[28px] min-w-0 flex-1 flex-col justify-center gap-3.5 font-body">
            <div className="order-0 flex h-7 sm:h-[28px] min-w-0 w-full flex-row items-center gap-2">
              <span
                className="h-7 w-7 flex-none sm:h-[28px] sm:w-[28px]"
                aria-label="Countdown"
              >
                <Clock />
              </span>
              <span
                className="truncate pl-1 select-none text-white font-normal leading-[0.92] tracking-tight"
                style={{
                  fontSize: "clamp(1rem,4vw,1.6rem)",
                  letterSpacing: "-0.03em",
                }}
              >
                GAME STARTS IN
              </span>
            </div>
          </div>
          {/* Timer pill */}
          <div className="order-1 box-border z-0 flex h-10 min-w-[64px] w-[clamp(72px,20vw,110px)] max-w-[140px] flex-none flex-row items-center justify-center rounded-full border-2 border-[var(--color-neon-pink)] bg-transparent px-4 py-1 sm:px-5 sm:py-2">
            <span className="px-0 flex items-end justify-center w-full min-w-0 select-none not-italic text-center text-xs leading-[115%] text-[var(--color-neon-pink)]">
              {minutes}M {String(seconds).padStart(2, "0")}s
            </span>
          </div>
        </div>
        {/* Prize copy */}
        <div className="flex w-full min-h-24 flex-col items-center justify-end gap-1 pb-2.5">
          <p className="w-auto min-w-[60px] sm:min-w-[80px] select-none text-center font-display font-medium leading-[1.3] tracking-tight text-muted text-[0.95rem] sm:text-base md:text-lg">
            Current prize pool
          </p>
          <div className="flex min-h-10 sm:min-h-[2.7rem] w-full items-center justify-center px-2 sm:px-4">
            <span className="block min-w-[70px] sm:min-w-[90px] select-none text-center font-body font-normal leading-[0.92] tracking-tight text-success text-[clamp(2rem,6vw,3rem)]">
              $2,500
            </span>
          </div>
        </div>
        {/* Avatar diamond */}
        <div className="w-full flex justify-center">
          <AvatarDiamond
            avatars={[
              { id: "1", src: "/images/avatars/a.png", alt: "Avatar 1" },
              { id: "2", src: "/images/avatars/b.png", alt: "Avatar 2" },
              { id: "3", src: "/images/avatars/c.png", alt: "Avatar 3" },
              {
                id: "4",
                src: "/images/avatars/d.png",
                alt: "Avatar 4",
                opacity: 0.2,
              },
              { id: "5", src: "/images/avatars/a.png", alt: "Avatar 5" },
              { id: "6", src: "/images/avatars/a.png", alt: "Avatar 6" },
              { id: "7", src: "/images/avatars/a.png", alt: "Avatar 7" },
              { id: "8", src: "/images/avatars/a.png", alt: "Avatar 8" },
              {
                id: "9",
                src: "/images/avatars/a.png",
                alt: "Avatar 9",
                opacity: 0.2,
              },
              { id: "10", src: "/images/avatars/a.png", alt: "Avatar 10" },
              { id: "11", src: "/images/avatars/a.png", alt: "Avatar 11" },
              { id: "12", src: "/images/avatars/a.png", alt: "Avatar 12" },
              { id: "13", src: "/images/avatars/a.png", alt: "Avatar 13" },
              { id: "14", src: "/images/avatars/a.png", alt: "Avatar 14" },
              { id: "15", src: "/images/avatars/a.png", alt: "Avatar 15" },
              { id: "16", src: "/images/avatars/a.png", alt: "Avatar 16" },
              {
                id: "17",
                src: "/images/avatars/a.png",
                alt: "Avatar 17",
                opacity: 0.2,
              },
            ]}
            cellMin={32}
            cellMax={54}
            gap={2}
            className="scale-95 sm:scale-100"
          />
        </div>
        {/* joined count */}
        <p className="mt-1 min-w-[120px] text-center font-display font-medium tracking-[-0.03em] text-muted text-[clamp(13px,4vw,16px)] leading-[130%]">
          {ticket?.id} players have joined
        </p>
      </section>
      {/* bottom shadow mask */}
      <div className="pointer-events-none absolute left-0 right-0 bottom-[110px] h-28 w-full">
        <div
          className="absolute inset-0 opacity-0"
          style={{
            background:
              "linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 6%, #FFFFFF 100%)",
          }}
        />
        <div className="absolute inset-0 opacity-0" />
      </div>
      {/* overlays anchored to this view - chat at the bottom */}
      <ChatTickerOverlay
        className="absolute! left-0 right-0 bottom-[70px] sm:bottom-[90px] z-10"
        maxItems={4}
      />
      <ChatDrawer />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/QuestionView.tsx ---
"use client";

import * as React from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";
import { PixelButton } from "@/components/buttons/PixelButton";
import { useGame } from "@/state";
import { useMiniUser } from "@/hooks/useMiniUser";
// import { Clock } from "@/components/icons";
import { NEXT_QUESTION_DELAY_SECONDS } from "@/state/game/constants";
import { useTimer } from "@/hooks/useTimer";

/** Shared cap so the image and buttons are exactly the same width */
const CONTENT_CAP = "max-w-[560px]";

/** Answer row palettes (gold, purple, blue, green) */
const PALETTES = [
  { bg: "#FFE8BA", border: "#FFC931", text: "#151515" },
  { bg: "#EFD6FF", border: "#B45CFF", text: "#151515" },
  { bg: "#D7EBFF", border: "#2E7DFF", text: "#151515" },
  { bg: "#D8FFF1", border: "#18DCA5", text: "#151515" },
] as const;

export default function QuestionView() {
  // ── Context selectors
  const {
    activeGame,
    questionIndex: currentQuestionIndex,
    selectedAnswer,
    selectAnswer,
    state: gameStateType,
    submitAnswer,
    advanceToNextQuestion,
  } = useGame();
  const user = useMiniUser();

  // ── Timer logic using useTimer
  const maxTime = activeGame?.config?.roundTimeLimit;
  if (!maxTime) throw new Error("Round time limit not set"); // safety

  // Question timer (countdown when answering)
  const {
    remaining: questionRemaining,
    percent: questionPercent,
    reset: resetQuestionTimer,
    start: startQuestionTimer,
    pause: pauseQuestionTimer,
  } = useTimer({
    duration: maxTime * 1000,
    autoStart: gameStateType === "GAME_LIVE",
    // We do not set onComplete here but could if needed
  });

  // Lock timer (countdown between questions)
  const {
    remaining: lockRemaining,
    percent: lockPercent,
    reset: resetLockTimer,
    start: startLockTimer,
    pause: pauseLockTimer,
  } = useTimer({
    duration: NEXT_QUESTION_DELAY_SECONDS * 1000,
    autoStart: gameStateType === "GAME_LIVE_NEXT_QUESTION_COUNTDOWN",
  });

  // Reset timers on round/question transitions
  React.useEffect(() => {
    if (gameStateType === "GAME_LIVE") {
      resetQuestionTimer();
      startQuestionTimer();
      pauseLockTimer();
      resetLockTimer();
    } else {
      resetLockTimer();
      startLockTimer();
      pauseQuestionTimer();
      resetQuestionTimer();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [gameStateType, maxTime]);

  const onPick = React.useCallback(
    async (val: string) => {
      selectAnswer(val);
      // Compute time taken using the timer hook
      const elapsedMs = maxTime * 1000 - questionRemaining;
      const timeTaken = Math.max(0, Math.round(elapsedMs / 1000));
      if (user.fid) {
        try {
          await submitAnswer({
            farcasterId: user.fid,
            selected: val,
            timeTaken,
          });
          setTimeout(() => {
            advanceToNextQuestion();
          }, NEXT_QUESTION_DELAY_SECONDS * 1000);
        } catch (e) {
          console.error("submitAnswer failed", e);
        }
      }
    },
    [
      selectAnswer,
      submitAnswer,
      advanceToNextQuestion,
      user.fid,
      maxTime,
      questionRemaining,
    ]
  );

  // Render the correct time and progress depending on state
  const time =
    gameStateType === "GAME_LIVE"
      ? Math.ceil(questionRemaining / 1000)
      : Math.ceil(lockRemaining / 1000);

  const progress =
    gameStateType === "GAME_LIVE"
      ? 1 - questionPercent // percent is elapsed [0,1], but we want time-left fraction [1..0]
      : 1 - lockPercent;

  return (
    <section
      className="mx-auto w-full max-w-screen-sm px-4 pb-24 pt-6 animate-up"
      aria-live="polite"
    >
      {/* ───────── HUD (question counter + timer) ───────── */}
      <div className="mb-3 flex items-center justify-between text-white">
        <div className="font-body text-sm tracking-wide">
          {String(currentQuestionIndex + 1).padStart(2, "0")}/
          {String(activeGame?.questions?.length ?? 0).padStart(2, "0")}
        </div>

        <div className="flex items-center gap-3">
          <div className="font-body text-sm tabular-nums">
            00:{String(time).padStart(2, "0")}
          </div>
          <div
            className="relative h-3 w-28 overflow-hidden rounded-full border border-black/40 bg-white/20"
            role="progressbar"
            aria-valuemin={0}
            aria-valuemax={maxTime}
            aria-valuenow={time}
          >
            <div
              className="absolute inset-y-0 left-0 rounded-full"
              style={{
                width: `${progress * 100}%`,
                background: "linear-gradient(90deg,#FF7A3D 0%,#FFB36B 100%)",
              }}
            />
          </div>
        </div>
      </div>

      {/* Question text */}
      <h1 className="mb-5 text-center font-body text-4xl md:text-5xl">
        {activeGame?.questions?.[currentQuestionIndex]?.text}
      </h1>

      {/* Question image (defines width for buttons as well) */}
      <figure
        className={cn("mx-auto mb-6 w-full flex justify-center", CONTENT_CAP)}
        style={{
          // Center and space for the responsive image box
          borderRadius: 10,
        }}
      >
        <div
          className="relative w-full"
          style={{
            aspectRatio: "299 / 158",
            borderRadius: 10,
            maxWidth: 480, // allow bigger size on larger screens
            minWidth: 200,
            background: "rgba(0,0,0,0.3)",
            border: "1px solid rgba(255,255,255,0.10)",
            flex: "none",
            order: 0,
            flexGrow: 0,
            overflow: "hidden",
          }}
        >
          <Image
            src={
              activeGame?.questions?.[currentQuestionIndex]?.imageUrl ||
              "/images/avatars/a.png"
            }
            alt="Question image"
            fill
            className="object-cover w-full h-full"
            style={{
              borderRadius: 10,
            }}
            priority
            sizes="(max-width: 600px) 90vw, 299px"
          />
        </div>
      </figure>

      {/* Answers — EXACT same width as image via CONTENT_CAP */}
      <ul className={cn("mx-auto flex w-full flex-col gap-4", CONTENT_CAP)}>
        {activeGame?.questions?.[currentQuestionIndex]?.options.map(
          (opt, idx) => {
            const isChosen = selectedAnswer === opt;

            const palette = PALETTES[idx] ?? PALETTES[PALETTES.length - 1];
            const borderWidth = isChosen ? 6 : 4;

            // Determine scale and width: normal for unselected, bigger & full for chosen, shrunken & narrower for others
            let scale = 1,
              width = "100%";
            if (selectedAnswer != null) {
              if (isChosen) {
                scale = 1.08;
                width = "100%";
              } else {
                scale = 0.96;
                width = "50%";
              }
            }

            return (
              <li key={idx} className="min-w-0 flex justify-center">
                <PixelButton
                  backgroundColor={palette.bg}
                  borderColor={palette.border}
                  textColor={palette.text}
                  borderWidth={borderWidth}
                  aria-pressed={isChosen}
                  onClick={() => onPick(opt)}
                  className={cn(
                    "rounded-xl px-4 py-3 text-base sm:px-6 sm:py-4 sm:text-lg",
                    "transition-transform transition-all duration-200"
                  )}
                  style={{
                    width,
                    transform: `scale(${scale})`,
                    zIndex: isChosen ? 2 : 1,
                  }}
                >
                  <span className="truncate">{opt}</span>
                </PixelButton>
              </li>
            );
          }
        )}
      </ul>

      {/* Submitted message */}
      <div
        className={cn(
          "mx-auto mt-6 text-center text-sm text-muted transition-opacity md:text-base",
          CONTENT_CAP,
          gameStateType === "GAME_LIVE_ANSWER_SUBMITTED"
            ? "opacity-100"
            : "opacity-0"
        )}
        aria-live="polite"
      >
        Answer submitted! Wait for the next question…
      </div>
    </section>
  );
}

--- File: ./src/app/(authenticated)/game/_components/AvatarDiamond.tsx ---
import * as React from "react";
import Image from "next/image";

type Avatar = {
  id: string | number;
  src: string;
  alt?: string;
  // optional per-tile opacity (e.g. 0.2 / 0.6 / 0.7 like in the mock)
  opacity?: number;
};

type Props = {
  avatars: Avatar[]; // supply as many as you have; we’ll clip to capacity
  // visual controls
  cellMin?: number; // min outer square size
  cellMax?: number; // max outer square size
  gap?: number; // gap between squares
  className?: string;
};

/**
 * Renders a fixed “diamond” pattern:
 * rows: 5  | cols: 7
 * counts per row: 3,4,3,4,3 at columns [2,4,6] / [1,3,5,7] repeating.
 */
export function AvatarDiamond({
  avatars,
  cellMin = 32,
  cellMax = 54,
  gap = 8,
  className = "",
}: Props) {
  // where tiles live (1-based columns)
  const pattern: number[][] = [
    [2, 4, 6],
    [1, 3, 5, 7],
    [2, 4, 6],
    [1, 3, 5, 7],
    [2, 4, 6],
  ];
  const capacity = pattern.reduce((n, row) => n + row.length, 0);
  const data = avatars.slice(0, capacity); // clamp to visible capacity

  // compute per-slot metadata (row, col, avatar)
  const slots: { row: number; col: number; avatar?: Avatar }[] = [];
  let i = 0;
  pattern.forEach((cols, r) => {
    cols.forEach((c) => {
      slots.push({ row: r + 1, col: c, avatar: data[i++] });
    });
  });

  // CSS variables (responsive size)
  const style = {
    // outer cell size (34px in Figma -> responsive here)
    ["--cell" as keyof React.CSSProperties]: `clamp(${cellMin}px, 7.5vw, ${cellMax}px)`,
    // inner image size (30px in Figma)
    ["--tile" as keyof React.CSSProperties]: "calc(var(--cell) - 4px)",
    // gap
    ["--gap" as keyof React.CSSProperties]: `${gap}px`,
  };

  return (
    <div
      className={[
        "relative",
        // 7 equal columns, fixed 5 rows, with gaps
        "grid [grid-template-columns:repeat(7,var(--cell))] [grid-auto-rows:var(--cell)]",
        "gap-[var(--gap)]",
        className,
      ].join(" ")}
      style={style}
      aria-label="Avatar grid"
      role="grid"
    >
      {slots.map((slot) => (
        <div
          key={`${slot.row}-${slot.col}`}
          role="gridcell"
          // place item in the right row/column (1-based)
          className="relative"
          style={{
            gridColumnStart: slot.col,
            gridRowStart: slot.row,
            opacity: slot.avatar?.opacity ?? 1,
          }}
          aria-hidden={!slot.avatar}
        >
          <Tile avatar={slot.avatar} />
        </div>
      ))}
    </div>
  );
}

function Tile({ avatar }: { avatar?: Avatar }) {
  // empty slots are simply transparent (keeps the shape)
  if (!avatar) return <div className="w-[var(--cell)] h-[var(--cell)]" />;

  return (
    <div className="relative w-[var(--cell)] h-[var(--cell)]">
      {/* 30px image + 1px border on a 34px cell in the design */}
      <Image
        src={avatar.src}
        alt={avatar.alt ?? ""}
        width={30}
        height={30}
        className="absolute left-1 top-1 size-[var(--tile)] rounded-sm border border-[#464646] object-cover bg-[#F0F3F4]"
        draggable={false}
      />
      {/* 4 corner nubs (4x4, 1px inset from the edges) */}
      <span className="absolute left-0 top-0 size-1 bg-white/30" />
      <span className="absolute right-0 top-0 size-1 bg-white/30" />
      <span className="absolute right-0 bottom-0 size-1 bg-white/30" />
      <span className="absolute left-0 bottom-0 size-1 bg-white/30" />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/ChatDrawer.tsx ---
"use client";

import { useState, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";
import { ForwardMessageIcon, MessageIcon } from "@/components/icons";
import { useGame } from "@/state";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function ChatDrawer() {
  const [open, setOpen] = useState(false);
  const [newMessage, setNewMessage] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { messages, sendMessage } = useGame();
  const user = useMiniUser();

  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, open]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const trimmed = newMessage.trim();
    if (!trimmed) return;

    sendMessage(trimmed, {
      // Coerce fid for typing; server persistence will be skipped if fid is falsy
      fid: Number(user.fid ?? 0),
      username: user.username || "You",
      pfpUrl: user.pfpUrl || "",
    });

    setNewMessage("");
  };

  return (
    <>
      {/* Trigger Input */}
      <div
        className="absolute left-0 bottom-0 w-full mx-auto flex flex-row items-start px-4 pb-5 pt-3 gap-3 app-background z-30"
        onClick={() => setOpen(true)}
      >
        <div className="flex flex-col justify-center items-start grow bg-white/5 rounded-full px-5 py-3 gap-1">
          <input
            readOnly
            placeholder="Type..."
            className="bg-transparent font-brockmann font-medium text-[14px] leading-[130%] tracking-[-0.03em] text-white opacity-40 outline-none cursor-pointer w-20 min-w-[42px] h-[18px]"
          />
        </div>
      </div>

      {/* Drawer */}
      <AnimatePresence>
        {open && (
          <motion.div
            className="fixed inset-0 z-50 flex flex-col justify-end bg-black/60 backdrop-blur-md font-display"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setOpen(false)}
          >
            <motion.div
              className="relative w-full mx-auto flex flex-col rounded-t-full app-background noise h-[85vh] max-h-[90dvh] sm:max-h-[600px] min-h-[60dvh] overflow-hidden"
              style={{
                width: "100%",
                borderTopLeftRadius: "1.25rem",
                borderTopRightRadius: "1.25rem",
              }}
              initial={{ y: "100%" }}
              animate={{ y: 0 }}
              exit={{ y: "100%" }}
              transition={{ type: "spring", stiffness: 200, damping: 25 }}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Header */}
              <div className="flex flex-row items-center justify-between px-4 pt-8 pb-3 border-b border-white/5 bg-[#191919] rounded-t-2xl font-body">
                <div className="flex flex-row items-center gap-2">
                  <MessageIcon />
                  <h2 className="font-pixel text-white text-lg md:text-xl select-none">
                    lobby CHAT
                  </h2>
                </div>
                <span className="font-pixel text-white text-base md:text-lg select-none">
                  00:10
                </span>
              </div>

              {/* Messages */}
              <div className="flex flex-col items-start gap-3 sm:gap-4 pb-4 pt-6 px-4 flex-1 min-h-0 overflow-y-scroll scrollbar-none w-full">
                {messages.map((msg, idx) => {
                  const username = msg.user?.name ?? "anon";
                  const avatar = msg.user?.imageUrl ?? null;
                  const time = new Date(msg.createdAt).toLocaleTimeString([], {
                    hour: "2-digit",
                    minute: "2-digit",
                  });

                  return (
                    <div
                      key={msg.id}
                      className="flex flex-col items-start gap-2 w-full"
                      style={{ order: idx }}
                    >
                      <div className="flex flex-row items-center gap-1.5 sm:gap-2 min-h-5 mb-0.5">
                        <div className="w-5 h-5 rounded-full bg-gray-100 overflow-hidden flex items-center justify-center">
                          {avatar ? (
                            <Image
                              src={avatar}
                              alt={username}
                              width={20}
                              height={20}
                              className="w-5 h-5 object-cover"
                            />
                          ) : (
                            <span className="text-gray-400 text-xs font-semibold">
                              {username?.[0]?.toUpperCase() ?? "•"}
                            </span>
                          )}
                        </div>
                        <span className="ml-1 font-brockmann font-medium text-[0.92rem] leading-[130%] tracking-[-0.03em] text-white">
                          {username}
                        </span>
                        <span className="mx-1 w-[0.28rem] h-[0.28rem] bg-[#D9D9D9] rounded-full inline-block" />
                        <span className="font-brockmann font-medium text-[0.72rem] leading-[130%] tracking-[-0.03em] text-[#99A0AE]">
                          {time}
                        </span>
                      </div>

                      <div className="w-full bg-white/[0.10] border border-white/[0.03] rounded-[0px_0.75rem_0.75rem_0.75rem] px-4 py-3 flex flex-col justify-center">
                        <p className="font-brockmann font-medium text-base leading-[130%] tracking-[-0.03em] text-white break-words">
                          {msg.message}
                        </p>
                      </div>
                    </div>
                  );
                })}
                <div ref={messagesEndRef} />
              </div>

              {/* Input */}
              <form
                onSubmit={handleSubmit}
                className="absolute left-0 bottom-0 w-full flex flex-row items-center bg-[#0E0E0E] px-4 py-5 gap-3 border-t border-white/5"
                style={{
                  minHeight: "min(90px,12vh)",
                  maxHeight: "18vh",
                }}
              >
                <div className="flex items-center bg-white/5 rounded-full flex-1 px-5 py-3">
                  <input
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder="Type a comment"
                    className="flex-1 bg-transparent outline-none text-white placeholder-white/40 text-base font-brockmann"
                  />
                </div>
                <AnimatePresence>
                  {newMessage.trim() && (
                    <motion.button
                      type="submit"
                      className="ml-3 bg-[#1B8FF5] rounded-full w-10 h-10 flex items-center justify-center active:scale-95 transition-transform shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400"
                      initial={{ scale: 0 }}
                      animate={{ scale: 1 }}
                      exit={{ scale: 0 }}
                    >
                      <ForwardMessageIcon />
                    </motion.button>
                  )}
                </AnimatePresence>
              </form>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}

--- File: ./src/app/(authenticated)/game/gameClientImpl.tsx ---
"use client";

import { useCallback, useEffect, useState } from "react";
import RoundCountdownView from "./_components/RoundCountdownView";
import QuestionView from "./_components/QuestionView";
import WaitingView from "./_components/WaitingView";
import GameOverView from "./_components/GameOverView";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useRouter } from "next/navigation";
import { cn } from "@/lib/utils";
import LogoIcon from "@/components/logo/LogoIcon";
import { LeaveGameIcon, WalletIcon } from "@/components/icons";
import { useGetTokenBalance } from "@coinbase/onchainkit/wallet";
import { env } from "@/lib/env";
import { baseSepolia } from "wagmi/chains";
import LeaveGameDrawer from "./_components/LeaveGameDrawer";
import SoundManager from "@/lib/SoundManager";
import { useLobby } from "@/state";
import JoinGameView from "./_components/JoinGameView";
import { useGame, GameStateType } from "@/state/game/GameContext";
import React from "react";
import type { Prisma } from "@prisma/client";

// Use the fully hydrated Game type as seen in page.tsx's prisma.game.findFirst(...)
// Should match the include: { config, questions, tickets, scores, chats, answers }
export type HydratedGame = Prisma.GameGetPayload<{
  include: {
    config: true;
    questions: true;
    chats: true;
  };
}>;

interface GameClientImplProps {
  game: HydratedGame | null;
}

export function GameClientImpl({ game }: GameClientImplProps) {
  const router = useRouter();
  const { ticket, fetchTicket } = useLobby();
  const user = useMiniUser();
  const {
    state: gameStateType,
    setStateType,
    activeGame,
    resetGame,
    round,
    questionIndex,
  } = useGame();

  // Used to toggle drawer for leaving game
  const [isLeaveGameDrawerOpen, setIsLeaveGameDrawerOpen] = useState(false);

  // For sound settings based on game (defaults to enabled)
  // Use hydrated game prop (from SSR/props) if available, else fallback to global state
  const soundEnabled =
    game?.config?.soundEnabled ?? activeGame?.config?.soundEnabled ?? false;

  const { roundedBalance } = useGetTokenBalance(user.wallet as `0x${string}`, {
    address: env.nextPublicUsdcAddress as `0x${string}`,
    chainId: baseSepolia.id,
    decimals: 6,
    image: "/images/tokens/usdc.png",
    name: "USDC",
    symbol: "USDC",
  });

  // Initial hydration: if there is a hydrated game prop, sync it to GameContext
  useEffect(() => {
    // On first mount, if there is a hydrated game but context has no activeGame, hydrate context.
    // This prevents overriding if context is already set (e.g., client-side transitions).
    if (game && (!activeGame || activeGame.id !== game.id)) {
      // Set GameContext's activeGame, round, etc. by resetting then hydrating.
      resetGame();
      // Custom action: setStateType, but also set game in context if needed
      // For this example, we use setStateType as proxy/hydrater
      // 1. GameContext reducer should receive the new game
      // 2. Optionally: you could expose a "hydrateGame" action/method.
      // For now, we'll simulate as follows:
      setStateType("WAITING");
      // You might want to add a dedicated "hydrateGame" action for true data.
    }
  }, [game, activeGame, resetGame, setStateType]);

  // Fetch ticket for user/game
  useEffect(() => {
    if ((game?.id || activeGame?.id) && user.fid) {
      fetchTicket(user.fid.toString(), (game?.id ?? activeGame?.id)!);
    }
  }, [fetchTicket, user.fid, game?.id, activeGame?.id]);

  // Unlock Web Audio API after first user interaction
  useEffect(() => {
    if (!soundEnabled) return;

    const handleFirstInteraction = () => {
      SoundManager.init().catch((error) => {
        console.debug("Sound manager init failed", error);
      });
    };

    window.addEventListener("pointerdown", handleFirstInteraction, {
      once: true,
    });
    window.addEventListener("keydown", handleFirstInteraction, { once: true });

    return () => {
      window.removeEventListener("pointerdown", handleFirstInteraction);
      window.removeEventListener("keydown", handleFirstInteraction);
    };
  }, [soundEnabled]);

  // Handle ambience / countdown sounds as the view changes
  useEffect(() => {
    if (!soundEnabled) {
      SoundManager.stop("countdown");
      return;
    }

    if (gameStateType === "GAME_LIVE_ROUND_COUNTDOWN") {
      SoundManager.play("countdown", { loop: true });
    } else {
      SoundManager.stop("countdown");
    }
  }, [gameStateType, soundEnabled]);

  useEffect(() => {
    if (!soundEnabled) {
      SoundManager.stopAll();
    }
  }, [soundEnabled]);

  useEffect(() => {
    return () => {
      SoundManager.stopAll();
    };
  }, []);

  // Confirm leave: reset global game state and route back to lobby buy page
  const leaveGame = useCallback(() => {
    try {
      resetGame();
      setStateType("WAITING");
    } finally {
      setIsLeaveGameDrawerOpen(false);
      router.replace("/game");
    }
  }, [resetGame, setStateType, router]);

  // Use hydrated prop OR GameContext game for not-found logic
  const activeOrHydratedGame = game ?? activeGame;

  // If game data is missing: show not-found message/UI
  if (!activeOrHydratedGame) {
    return (
      <div className="flex flex-col items-center justify-center min-h-[80dvh]">
        <LogoIcon className="w-12 h-12 mb-4" />
        <h1 className="text-2xl font-bold text-foreground mb-2">
          No Active Game
        </h1>
        <p className="text-md text-muted-foreground mb-8">
          There isn&apos;t a game running right now. Check back soon!
        </p>
        <div className="flex items-center gap-1.5 app-background rounded-full px-3 py-1.5">
          <WalletIcon className="w-4 h-4 text-foreground" />
          <span className="text-xs text-foreground">
            {new Intl.NumberFormat("en-US", {
              style: "currency",
              currency: "USD",
              minimumFractionDigits: 2,
              maximumFractionDigits: 2,
            }).format(Number(roundedBalance || 0))}
          </span>
        </div>
      </div>
    );
  }

  // Main game section rendered based on global state (hydrated/canonical)
  const view = (() => {
    switch (gameStateType) {
      case "WAITING":
        return <WaitingView />;
      case "JOIN_GAME":
        return <JoinGameView />;
      case "GAME_LIVE":
      case "GAME_LIVE_ANSWER_SELECTED":
      case "GAME_LIVE_ANSWER_SUBMITTED":
      case "GAME_LIVE_NEXT_QUESTION_COUNTDOWN":
        return <QuestionView />;
      case "GAME_LIVE_ROUND_COUNTDOWN":
        return <RoundCountdownView />;
      case "GAME_OVER":
        return <GameOverView />;
      default:
        return <WaitingView />;
    }
  })();

  return (
    <div className="w-full min-h-[100dvh] overflow-hidden app-background">
      {/* HEADER */}
      <div
        className={cn(
          "p-4 flex items-center justify-between border-b border-border app-background"
        )}
      >
        <LogoIcon />
        <div className="flex items-center gap-2">
          {["GAME_LIVE"].includes(gameStateType) ? (
            <div className="flex items-center gap-1.5 bg-white/10 rounded-full px-3 py-1.5 ">
              <LeaveGameIcon className="w-4 h-4 text-foreground" />

              <button
                onClick={() => setIsLeaveGameDrawerOpen(true)}
                className="text-xs font-body"
              >
                <span className="text-xs text-foreground">leave game</span>
              </button>
            </div>
          ) : (
            <div className="flex items-center gap-1.5 app-background rounded-full px-3 py-1.5">
              <WalletIcon className="w-4 h-4 text-foreground" />
              <span className="text-xs text-foreground">
                {new Intl.NumberFormat("en-US", {
                  style: "currency",
                  currency: "USD",
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
                }).format(Number(roundedBalance || 0))}
              </span>
            </div>
          )}
        </div>
      </div>

      {view}

      <LeaveGameDrawer
        open={isLeaveGameDrawerOpen}
        onClose={() => setIsLeaveGameDrawerOpen(false)}
        onConfirmLeave={leaveGame}
      />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/error.tsx ---
"use client";

import React from "react";

export default function ErrorPage({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div className="flex flex-col items-center justify-center min-h-[60vh]">
      <h1 className="text-2xl font-bold text-red-600 mb-2">
        Game failed to load
      </h1>
      <p className="mb-4 text-gray-700">
        Sorry, there was a problem loading the game.
        <br />
        {error?.message && (
          <span className="block text-sm text-gray-500 mt-2">
            {error.message}
          </span>
        )}
      </p>
      <button
        onClick={() => reset()}
        className="px-4 py-2 bg-blue-600 text-white rounded-lg shadow hover:bg-blue-700 transition"
      >
        Try again
      </button>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/loading.tsx ---
"use client";

import { SplashScreen } from "@/components/ui/SplashScreen";

export default function Loading() {
  return <SplashScreen />;
}

--- File: ./src/app/(authenticated)/game/page.tsx ---
import { GameClientImpl } from "./gameClientImpl";
import { prisma } from "@/lib/db";
import { redirect } from "next/navigation";
import React from "react";

/**
 * Fetches the currently active game, including only the fields/relations
 * required by <GameClientImpl />, in the exact shape/types expected.
 * Robust error handling for all major failure scenarios.
 */
async function fetchActiveGameForClient() {
  try {
    const now = new Date();

    const game = await prisma.game.findFirst({
      where: {
        endTime: { gt: now },
        startTime: { lte: now },
      },
      include: {
        config: true,
        questions: { orderBy: { id: "asc" } },
        chats: true,
      },
      orderBy: { createdAt: "desc" },
    });

    if (!game) {
      return { error: "No active game" };
    }
    if (!game.config) {
      return { error: "Active game missing config" };
    }
    if (!Array.isArray(game.questions) || game.questions.length === 0) {
      return { error: "Active game missing questions" };
    }

    // Remove any unnecessary/sensitive fields here if needed (future-proofing)

    return { game };
  } catch (err) {
    console.error("GamePage fetchActiveGameForClient error:", err);
    return { error: "Internal server error" };
  }
}

export default async function GamePage() {
  const data = await fetchActiveGameForClient();

  if (data.error === "No active game") {
    redirect("/waitlist");
  }

  if (data.error) {
    return <div className="p-8 text-red-500 text-center">{data.error}</div>;
  }

  // All required info is present, pass the game object to the client implementation
  // Types now match: may be `null` but never `undefined`.
  return <GameClientImpl game={data.game ?? null} />;
}

--- File: ./src/app/(authenticated)/profile/_components/InviteFriendsDrawer.tsx ---
"use client";

import * as React from "react";
import { createPortal } from "react-dom";
import Image from "next/image";
import { CopyIcon, InviteFriendsIcon } from "@/components/icons";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

type Props = {
  open: boolean;
  code: string;
  onClose: () => void;
};

export function InviteFriendsDrawer({ open, code, onClose }: Props) {
  const [mounted, setMounted] = React.useState(false);
  const drawerRef = React.useRef<HTMLDivElement | null>(null);
  const [toast, setToast] = React.useState<string | null>(null);

  // drag
  const startY = React.useRef<number | null>(null);
  const [dragY, setDragY] = React.useState(0);
  const isDragging = startY.current !== null;

  React.useEffect(() => setMounted(true), []);

  // Lock scroll while open
  React.useEffect(() => {
    if (!open) {
      document.documentElement.style.overflow = "";
      return;
    }
    document.documentElement.style.overflow = "hidden";
    return () => {
      document.documentElement.style.overflow = "";
    };
  }, [open]);

  // esc to close
  React.useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  // drag handlers
  const onPointerDown = (e: React.PointerEvent) => {
    startY.current = e.clientY;
    setDragY(0);
    drawerRef.current?.setPointerCapture(e.pointerId);
  };
  const onPointerMove = (e: React.PointerEvent) => {
    if (startY.current == null) return;
    const dy = Math.max(0, e.clientY - startY.current);
    setDragY(dy);
  };
  const onPointerUp = () => {
    if (startY.current == null) return;
    const dy = dragY;
    startY.current = null;
    setDragY(0);
    if (dy > 140) onClose();
  };

  const copy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setToast("Code copied!");
    } catch {
      setToast("Couldn’t copy");
    } finally {
      setTimeout(() => setToast(null), 1400);
    }
  };

  const share = async () => {
    const text = `Join me on Waffle — use my invite code: ${code}`;
    if (navigator.share) {
      try {
        await navigator.share({ title: "Waffle Invite", text });
        setToast("Invite shared!");
      } catch {
        /* dismissed */
      } finally {
        setTimeout(() => setToast(null), 1400);
      }
    } else {
      await copy();
    }
  };

  if (!mounted) return null;

  return createPortal(
    <>
      {/* Backdrop */}
      <div
        aria-hidden
        className={[
          "fixed inset-0 z-[80] bg-black/60 transition-opacity",
          open
            ? "opacity-100 pointer-events-auto"
            : "opacity-0 pointer-events-none",
        ].join(" ")}
        onClick={onClose}
      />

      {/* Drawer */}
      <section
        id="invite-friends-drawer"
        role="dialog"
        aria-modal="true"
        aria-label="Invite friends"
        className={[
          "fixed inset-x-0 bottom-0 z-[81]",
          open ? "pointer-events-auto" : "pointer-events-none",
        ].join(" ")}
      >
        <div
          ref={drawerRef}
          onPointerDown={onPointerDown}
          onPointerMove={onPointerMove}
          onPointerUp={onPointerUp}
          className={[
            "relative isolate", // keeps z layering correct
            "mx-auto w-full max-w-screen-sm",
            "rounded-t-[1.25rem] overflow-hidden", // ensures radius applies visually
            "border-t border-white/5",
            "bg-gradient-to-b from-[#1E1E1E] to-black",
            "shadow-[0_-20px_60px_rgba(0,0,0,.6)]",
            "transform transition-[transform,opacity] duration-300 ease-[cubic-bezier(.2,.8,.2,1)]",
            open && !isDragging
              ? "translate-y-0 opacity-100"
              : "translate-y-full opacity-0",
          ].join(" ")}
          style={
            isDragging
              ? {
                  transform: `translateY(${dragY}px)`,
                  opacity: Math.max(0.6, 1 - dragY / 800),
                }
              : undefined
          }
        >
          {/* Handle + Title */}
          <div
            className="
            relative border-b border-white/5 bg-[#191919]
            px-4 pb-3
            pt-6

          "
          >
            <div
              className="absolute left-1/2 top-3 h-1 w-9 -translate-x-1/2 rounded-full bg-white/40"
              aria-hidden
            />
            <div className="mx-auto flex w-full max-w-xs items-center justify-center gap-2">
              <InviteFriendsIcon className="h-6 w-6 text-waffle-yellow" />
              <h2
                className="font-edit-undo text-white leading-[1.15]"
                style={{ fontSize: "clamp(1.05rem, 3.7vw, 1.25rem)" }}
              >
                INVITE FRIENDS
              </h2>
            </div>
          </div>

          {/* Body */}
          <div className="mx-auto flex w-full max-w-xs flex-col gap-3.5 px-4 py-4">
            {/* Gift + code card */}
            <div
              className="
              rounded-2xl border border-white/10
              bg-[linear-gradient(90deg,rgba(255,255,255,0)_0%,rgba(255,201,49,.12)_100%)]
              flex flex-col items-center justify-center gap-3
              px-3 py-12 sm:py-14
            "
            >
              <Image
                src="/images/icons/gift.svg"
                alt="Gift"
                width={96}
                height={96}
                className="w-24 h-24 sm:w-28 sm:h-28"
                priority
              />
              <div className="mt-1.5 flex w-full flex-col items-center">
                <p
                  className="font-brockmann text-waffle-gray tracking-[-0.03em]"
                  style={{
                    fontSize: "clamp(0.95rem, 3vw, 1rem)",
                    lineHeight: "130%",
                  }}
                >
                  Your code is
                </p>
                <p
                  className="font-edit-undo text-white"
                  style={{
                    fontSize: "clamp(1.9rem, 6vw, 2.375rem)",
                    lineHeight: "1.3",
                  }}
                >
                  {code}
                </p>
              </div>
            </div>

            {/* Share button (white tile with yellow “pixel” shadow) */}
            <FancyBorderButton onClick={share} className="border-waffle-gold">
              SHARE INVITE
            </FancyBorderButton>

            {/* Copy row */}
            <button
              onClick={copy}
              className="inline-flex w-full items-center justify-center gap-2 rounded-xl py-2.5"
            >
              <CopyIcon />
              <span
                className="font-edit-undo text-[#00CFF2] tracking-[-0.02em]"
                style={{
                  fontSize: "clamp(1rem, 3.2vw, 1.125rem)",
                  lineHeight: "1.15",
                }}
              >
                COPY CODE
              </span>
            </button>
          </div>
        </div>
      </section>

      {/* Toast */}
      <div
        aria-live="polite"
        className={[
          "fixed inset-x-0 z-[82] flex justify-center transition-opacity duration-200",
          "bottom-[calc(env(safe-area-inset-bottom,0px)+88px)]",
          toast ? "opacity-100" : "opacity-0 pointer-events-none",
        ].join(" ")}
      >
        <div className="rounded-full bg-white/10 px-3 py-2 text-sm text-white backdrop-blur">
          {toast}
        </div>
      </div>
    </>,
    document.body
  );
}

--- File: ./src/app/(authenticated)/profile/_components/GameHistory.tsx ---
// Past Games Section
import { WaffleIcon, ZapIcon } from "@/components/icons";
import type { GameHistory } from "@/state";
import Link from "next/link";
import React from "react";

export function GameHistory({ gameHistory }: { gameHistory: GameHistory[] }) {
  return (
    <section aria-labelledby="past-games-heading" className="w-full">
      <div className="flex items-center justify-between mb-3.5 font-semibold">
        <h2
          id="past-games-heading"
          className="font-display font-medium text-muted tracking-[-0.03em]"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)", // ~14–16
            lineHeight: "130%",
          }}
        >
          Past games
        </h2>
        <Link
          href="/profile/history"
          className="font-display font-medium text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>

      {/* Show two items like the design; spacing scales with screen */}
      <ul className="space-y-2">
        {gameHistory.slice(0, 2).map((game) => (
          <li key={game.id}>
            <GameHistoryItem game={game} />
          </li>
        ))}
      </ul>
    </section>
  );
}

export const GameHistoryItem = ({ game }: { game: GameHistory }) => {
  const amount = "$" + game.winnings;

  return (
    <div
      className={[
        "flex items-center justify-between",
        "noise rounded-2xl border border-white/20 ",
        "p-3 sm:p-4",
      ].join(" ")}
    >
      {/* Left block: avatar-ish icon + name + score */}
      <div className="flex min-w-0 items-center gap-2 sm:gap-3">
        <div className="size-10 rounded-full bg-white/10 grid place-items-center shrink-0">
          <WaffleIcon aria-hidden className="text-waffle-yellow" />
        </div>

        <div className="min-w-0 flex flex-col gap-1">
          <p
            className="font-body truncate"
            style={{
              fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)", // ~18–20
              lineHeight: "100%",
              letterSpacing: "-0.03em",
            }}
          >
            {game.name}
          </p>

          <div className="mt-1 flex items-center gap-1">
            <span className="text-waffle-yellow" aria-hidden>
              <ZapIcon />
            </span>
            <span
              className="font-display font-medium text-white/90 tracking-[-0.03em]"
              style={{
                fontSize: "clamp(0.75rem, 1.1vw, 0.875rem)", // ~12–14
                lineHeight: "1rem",
              }}
            >
              {game.score}
            </span>
          </div>
        </div>
      </div>

      {/* Right block: winnings */}
      <p
        className={[
          "font-display font-medium whitespace-nowrap ml-3",
          game.winningsColor === "green" ? "text-success" : "text-muted",
        ].join(" ")}
        style={{
          fontSize: "clamp(1rem, 1.8vw, 1rem)", // ~16
          lineHeight: "1.2rem",
          letterSpacing: "-0.03em",
        }}
      >
        {amount}
      </p>
    </div>
  );
};

--- File: ./src/app/(authenticated)/profile/_components/ProfileCard.tsx ---
"use client";

import Image from "next/image";
import { UploadIcon } from "@/components/icons";

type ProfileCardProps = {
  username: string;
  streak: number;
  /** same URL is used for avatar + blurred bg */
  avatarUrl: string;
  onUpload?: () => void;
};

export function ProfileCard({
  username,
  streak,
  avatarUrl,
  onUpload,
}: ProfileCardProps) {
  return (
    <section
      className={[
        "relative overflow-hidden rounded-2xl border border-white/10",
        "px-3 py-3 sm:px-4 sm:py-3.5",
        // gold tint like the figma
        // "bg-[linear-gradient(90deg,rgba(255,255,255,0)_0%,rgba(255,201,49,0.12)_100%)]",
      ].join(" ")}
      aria-label={`${username} profile`}
    >
      {/* background: same as avatar, soft/blurred */}
      <div aria-hidden className="absolute inset-0 -z-10">
        <Image
          src={avatarUrl}
          alt=""
          fill
          className="object-cover object-center opacity-70 blur-[18px] scale-125"
          priority
        />
        {/* subtle vignette so text pops */}
        <div className="absolute inset-0 bg-gradient-to-r from-black/10 via-transparent to-black/20" />
      </div>

      {/* row: upload • centered identity • spacer */}
      <div className="flex items-start justify-between gap-2">
        {/* upload button (left) */}
        <button
          onClick={onUpload}
          aria-label="Upload"
          className={[
            "grid size-9 place-items-center rounded-full bg-white/15",
            "transition-opacity hover:opacity-80 focus:outline-none focus:ring-2 focus:ring-white/30",
          ].join(" ")}
        >
          <UploadIcon className="h-[18px] w-[18px] text-white" />
        </button>

        {/* center block */}
        <div className="flex min-w-0 flex-col items-center gap-3">
          {/* avatar + name */}
          <div className="flex items-center gap-2">
            <Image
              src={avatarUrl}
              alt={`${username} avatar`}
              width={36}
              height={36}
              className="h-9 w-9 rounded-full bg-[#FFF7B8] ring-2 ring-black/20"
              priority
            />
            <span
              className="font-body text-white tracking-tight"
              style={{ fontSize: "clamp(1.05rem,2.6vw,1.25rem)" }}
            >
              {username}
            </span>
          </div>

          {/* streak block */}
          <div className="flex flex-col items-center gap-1">
            <span
              className="font-display text-white/95"
              style={{
                fontSize: "clamp(.85rem,2vw,1rem)",
                letterSpacing: "-0.03em",
              }}
            >
              Streak
            </span>
            <div className="flex items-center gap-2">
              <Image
                src="/images/icons/streak-flame.svg"
                alt=""
                width={20}
                height={36}
                className="h-9 w-5 object-contain"
              />
              <span
                className="font-body text-foreground leading-none"
                style={{ fontSize: "clamp(1.75rem,4.6vw,2.25rem)" }}
              >
                {streak}
              </span>
            </div>
          </div>
        </div>

        {/* right spacer (keeps center truly centered) */}
        <div className="pointer-events-none size-9 opacity-0">
          <UploadIcon className="h-[18px] w-[18px]" />
        </div>
      </div>
    </section>
  );
}

--- File: ./src/app/(authenticated)/profile/_components/Stats.tsx ---
// Stats Section
import { GamePadIcon, WinningsIcon, WinsIcon } from "@/components/icons";
import Link from "next/link";
import React from "react";

type StatCardProps = {
  icon: React.ReactNode;
  label: string;
  value: number | string;
};

export function Stats({
  stats,
}: {
  stats: { games: number; wins: number; winnings: number };
}) {
  return (
    <section aria-labelledby="stats-heading" className="w-full ">
      <div className="flex items-center justify-between mb-3.5 font-semibold">
        <h2
          id="stats-heading"
          className="font-display text-muted tracking-[-0.03em]"
          style={{
            // ~14–16px depending on width, 130% line-height
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          Stats
        </h2>
        <Link
          href="/profile/stats"
          className="font-display text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>

      {/* Always 3 cards like the design, but fluid widths & spacing */}
      <div className="grid grid-cols-3 gap-2">
        <StatCard icon={<GamePadIcon />} label="Games" value={stats.games} />
        <StatCard icon={<WinsIcon />} label="Wins" value={stats.wins} />
        <StatCard
          icon={<WinningsIcon />}
          label="Winnings"
          value={stats.winnings}
        />
      </div>
    </section>
  );
}

export const StatCard = ({ icon, label, value }: StatCardProps) => (
  <div
    className={[
      "flex-1",
      "flex flex-col justify-between",

      "noise ",
      "rounded-2xl border border-white/20 ",
      "p-3 sm:p-4 gap-5",
      // keep heights visually consistent without hardcoding 74px
      "min-h-[3.75rem] sm:min-h-[4.25rem]",
    ].join(" ")}
  >
    <p
      className="font-display font-medium text-muted tracking-[-0.03em]"
      style={{
        // ~13–14px fluid label, 130% line-height
        fontSize: "clamp(0.8125rem, 1.3vw, 0.875rem)",
        lineHeight: "130%",
      }}
    >
      {label}
    </p>

    <div className="flex items-center gap-1">
      {/* icon inherits the yellow from the design */}
      <span className="shrink-0 text-waffle-yellow" aria-hidden>
        {icon}
      </span>
      <p
        className="font-body leading-none"
        style={{
          // ~20px value on small, scales up slightly; 100% line-height like Figma
          fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)",
          lineHeight: "100%",
          letterSpacing: "-0.03em",
        }}
      >
        {value}
      </p>
    </div>
  </div>
);

--- File: ./src/app/(authenticated)/profile/history/page.tsx ---
// app/profile/history/page.tsx
"use client";

import Link from "next/link";
import { useProfile, type GameHistory } from "@/state";
import { BottomNav } from "@/components/BottomNav";
import LogoIcon from "@/components/logo/LogoIcon";
import {
  ArrowLeftIcon,
  WalletIcon,
  WaffleIcon,
  ZapIcon,
} from "@/components/icons";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useEffect } from "react";
/* ---------- Top bar (shared look) ---------- */
const TopBar = () => (
  <header
    className={`
      sticky top-0 z-10 w-full
      border-b border-[color:var(--surface-stroke)]
      bg-[color:var(--brand-ink-900)]
    `}
  >
    <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
      <LogoIcon />
      <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
        <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
        <span
          className="text-center text-[color:var(--text-primary)] font-display"
          style={{
            fontSize: "clamp(.95rem,1.9vw,1rem)",
            lineHeight: "1.1",
          }}
        >
          $983.23
        </span>
      </div>
    </div>
  </header>
);

/* ---------- Sub-page header ---------- */
const SubPageHeader = ({ title }: { title: string }) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    <Link
      href="/profile"
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80"
      aria-label="Back"
    >
      <ArrowLeftIcon />
    </Link>

    <h1
      className="flex-grow text-center text-white font-body"
      style={{
        fontWeight: 400,
        fontSize: "clamp(1.25rem,4.5vw,1.375rem)", // ~22px target
        lineHeight: ".92",
        letterSpacing: "-0.03em",
      }}
    >
      {title}
    </h1>

    {/* spacer to balance back button */}
    <div className="h-[34px] w-[34px]" />
  </div>
);

/* ---------- List item ---------- */

const GameHistoryItem = ({ game }: { game: GameHistory }) => (
  <div
    className={`
      flex items-center justify-between
      rounded-2xl border border-white/20 bg-transparent
      p-3 sm:p-4
    `}
  >
    <div className="flex min-w-0 items-center gap-2 sm:gap-3">
      <div className="grid size-10 shrink-0 place-items-center rounded-full bg-white/10">
        <WaffleIcon aria-hidden />
      </div>

      <div className="min-w-0">
        <p
          className="truncate text-white font-body"
          style={{
            fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)", // ~18–20
            lineHeight: "1",
            letterSpacing: "-0.03em",
          }}
        >
          {game.name}
        </p>

        <div className="mt-1 flex items-center gap-1">
          <span className="text-waffle-yellow" aria-hidden>
            <ZapIcon />
          </span>
          <span
            className="tracking-[-0.03em] text-white/90 font-display"
            style={{
              fontWeight: 500,
              fontSize: "clamp(.75rem,1.2vw,.875rem)", // ~12–14
              lineHeight: "1rem",
            }}
          >
            {game.score}
          </span>
        </div>
      </div>
    </div>

    <p
      className={`ml-3 whitespace-nowrap tracking-[-0.03em] font-display ${
        game.winningsColor === "green" ? "text-success" : "text-muted"
      }`}
      style={{
        fontWeight: 500,
        fontSize: "clamp(1rem,1.8vw,1rem)", // ~16
        lineHeight: "1.2rem",
      }}
    >
      ${game.winnings.toFixed(2)}
    </p>
  </div>
);

/* ---------- Page ---------- */
export default function GameHistoryPage() {
  const { gameHistory, fetchProfile } = useProfile();
  const { fid } = useMiniUser();

  useEffect(() => {
    if (fid) {
      fetchProfile(String(fid)).catch((err) =>
        console.error("Failed to load profile history", err)
      );
    }
  }, [fid, fetchProfile]);

  return (
    <div
      className={`
        min-h-screen flex flex-col
        bg-[linear-gradient(180deg,#1E1E1E_0%,#000_100%)]
        text-[color:var(--text-primary)]
      `}
    >
      <TopBar />
      <SubPageHeader title="GAME HISTORY" />

      <main
        className={`
          mx-auto w-full max-w-lg
          px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          mt-4
        `}
      >
        {/* List */}
        <ul className="flex flex-col gap-3.5 sm:gap-4">
          {gameHistory.map((g) => (
            <li key={g.id}>
              <GameHistoryItem game={g} />
            </li>
          ))}
        </ul>
      </main>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/page.tsx ---
"use client";

import {
  ArrowRightIcon,
  InviteFriendsIcon,
  UploadIcon,
  WalletIcon,
} from "@/components/icons";
import { useProfile, useLobby } from "@/state";
import { GameHistory } from "./_components/GameHistory";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { ProfileCard } from "./_components/ProfileCard";
import { Stats } from "./_components/Stats";
import { InviteFriendsDrawer } from "./_components/InviteFriendsDrawer";
import { useEffect, useState } from "react";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function ProfilePage() {
  const { username, streak, stats, gameHistory, fetchProfile } = useProfile();
  const [inviteOpen, setInviteOpen] = useState(false);
  const { myReferral } = useLobby();
  const inviteCode = myReferral?.code ?? "------";
  const { fid } = useMiniUser();

  useEffect(() => {
    if (fid) {
      fetchProfile(String(fid)).catch((err) =>
        console.error("Failed to load profile", err)
      );
    }
  }, [fid, fetchProfile]);

  return (
    <div className="min-h-screen flex flex-col app-background noise ">
      {/* Header */}
      <header className="sticky top-0 z-10 w-full border-b border-white/20 px-4 py-3">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center"
                style={{ fontSize: "clamp(0.95rem, 1.9vw, 1rem)" }}
              >
                $983.23
              </span>
            </div>
          </div>
        </div>
      </header>

      {/* Main */}
      <main
        className="
          mx-auto w-full max-w-screen-sm px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          flex flex-col gap-6 sm:gap-8 pt-4
        "
      >
        {/* Title bar */}
        <div className="flex items-center justify-between">
          <button
            aria-label="Upload"
            className="flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full p-1 opacity-0"
          >
            <UploadIcon className="h-3.5 w-3.5" />
          </button>

          <h1
            className="font-edit-undo font-normal tracking-tight text-white leading-[0.92] text-center select-none"
            style={{
              fontSize: "clamp(1.2rem, 4vw, 1.375rem)",
              letterSpacing: "-0.03em",
            }}
          >
            PROFILE
          </h1>

          {/* ✨ Wire the icon to open the drawer */}
          <button
            onClick={() => setInviteOpen(true)}
            aria-label="Invite Friends"
            className="box-border flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-full bg-white/15 p-2 transition-opacity hover:opacity-80"
          >
            <InviteFriendsIcon className="h-[18px] w-[18px]" />
          </button>
        </div>

        <ProfileCard
          username={username}
          streak={streak}
          avatarUrl="/images/avatars/a.png"
          onUpload={() => {
            /* open picker */
          }}
        />

        {/* Big invite CTA */}
        <button
          onClick={() => setInviteOpen(true)}
          className="
            flex flex-row items-center justify-between
            w-full max-w-screen-sm min-h-[64px] h-[74px]
            mx-auto px-3 sm:px-4 box-border gap-3 rounded-[16px]
            border border-white/40 transition-transform hover:scale-[1.02]
            bg-[#FFC931] bg-blend-overlay
            [background:linear-gradient(189.66deg,rgba(0,0,0,0)_-6.71%,rgba(0,0,0,0.8)_92.73%),_#FFC931]
          "
          aria-haspopup="dialog"
          aria-controls="invite-friends-drawer"
        >
          <span
            className="font-normal text-[clamp(1.08rem,2.7vw,1.31rem)] leading-[1.3] text-foreground tracking-tight select-none px-2"
            style={{ letterSpacing: "-0.03em", fontWeight: 400 }}
          >
            INVITE FRIENDS
          </span>
          <div className="flex items-center justify-center w-[34px] h-[34px] rounded-full bg-white/15 flex-shrink-0 p-0.5 ml-2">
            <ArrowRightIcon className="w-[18px] h-[18px]" />
          </div>
        </button>

        <div className="mt-2">
          <Stats stats={stats} />
        </div>

        <div className="mt-4">
          <GameHistory gameHistory={gameHistory} />
        </div>
      </main>

      <BottomNav />

      {/* Drawer */}
      <InviteFriendsDrawer
        open={inviteOpen}
        code={inviteCode}
        onClose={() => setInviteOpen(false)}
      />
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/stats/page.tsx ---
"use client";

import { useProfile } from "@/state";
import Link from "next/link";
import Image from "next/image";
import { ArrowLeftIcon, WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useEffect } from "react";

/* ---------- Header (same style as other profile screens) ---------- */
const TopBar = () => (
  <header
    className={`
      sticky top-0 z-10 w-full
      border-b border-[color:var(--surface-stroke)]
      bg-[color:var(--brand-ink-900)]
    `}
  >
    <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
      <LogoIcon />
      <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
        <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
        <span
          className="text-center text-[color:var(--text-primary)]"
          style={{
            fontFamily: "Edit Undo BRK",
            fontSize: "clamp(.95rem,1.9vw,1rem)",
            lineHeight: "1.1",
          }}
        >
          $983.23
        </span>
      </div>
    </div>
  </header>
);

/* ---------- Sub page header ---------- */
const SubPageHeader = ({ title }: { title: string }) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    <Link
      href="/profile"
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80"
      aria-label="Back"
    >
      <ArrowLeftIcon />
    </Link>

    <h1
      className="font-body flex-grow text-center text-white"
      style={{
        fontWeight: 400,
        fontSize: "clamp(0.94rem, 3vw, 0.98rem)", // ~15px target
        lineHeight: ".92",
        letterSpacing: "-0.03em",
      }}
    >
      {title}
    </h1>

    {/* spacer to balance the back button */}
    <div className="h-[34px] w-[34px]" />
  </div>
);

/* ---------- Stat atoms ---------- */
const LargeStat = ({
  label,
  value,
}: {
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-2">
    <p
      className="text-muted font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem,2.8vw,1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>
    <p
      className="text-white font-body"
      style={{
        fontSize: "clamp(1.15rem,4vw,1.25rem)", // ~20px target
        lineHeight: "1",
      }}
    >
      {value}
    </p>
  </div>
);

const IconStat = ({
  icon,
  label,
  value,
}: {
  icon: string;
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-1">
    <Image
      src={icon}
      alt={label}
      width={36}
      height={36}
      className="h-9 w-9"
      sizes="(max-width: 420px) 36px, 36px"
      priority
    />
    <p
      className="text-waffle-gray text-center font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem,2.8vw,1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>
    <p
      className="text-white leading-none font-body"
      style={{
        fontSize: "clamp(1.15rem,4vw,1.25rem)", // ~20px target
        lineHeight: "1",
      }}
    >
      {value}
    </p>
  </div>
);

/* ---------- Page ---------- */
export default function AllTimeStatsPage() {
  const { allTimeStats, fetchProfile } = useProfile();
  const { fid } = useMiniUser();

  useEffect(() => {
    if (fid) {
      fetchProfile(String(fid)).catch((err) =>
        console.error("Failed to load profile stats", err)
      );
    }
  }, [fid, fetchProfile]);

  return (
    <div
      className={`
        min-h-screen flex flex-col
        app-background
        noise
      `}
    >
      <TopBar />
      <SubPageHeader title="ALL-TIME STATS" />

      <main
        className={`
          mx-auto w-full max-w-lg
          px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          flex flex-col
          gap-5 sm:gap-6
          mt-4
        `}
      >
        {/* ---- Block 1: Totals ---- */}
        <section
          className={`
            rounded-2xl border border-white/20
            p-4 sm:p-5
          `}
        >
          <div
            className={`
              grid grid-cols-2
              gap-x-4 gap-y-4 sm:gap-y-6
              justify-items-center
            `}
          >
            <LargeStat label="Total games" value={allTimeStats.totalGames} />
            <LargeStat label="Wins" value={allTimeStats.wins} />
            <LargeStat label="Win rate" value={allTimeStats.winRate} />
            <LargeStat label="Total won" value={allTimeStats.totalWon} />
          </div>
        </section>

        {/* ---- Block 2: Icon stats ---- */}
        <section
          className={`
            rounded-2xl border border-white/20
            p-4 sm:p-5
          `}
        >
          <div
            className={`
              grid grid-cols-2
              gap-x-6 gap-y-6 sm:gap-y-8
              justify-items-center
            `}
          >
            <IconStat
              icon="/images/icons/trophy.svg"
              label="Highest score"
              value={allTimeStats.highestScore}
            />
            <IconStat
              icon="/images/icons/average.svg"
              label="Average score"
              value={allTimeStats.averageScore}
            />
            <IconStat
              icon="/images/icons/streak-flame.svg"
              label="Current streak"
              value={allTimeStats.currentStreak}
            />
            <IconStat
              icon="/images/icons/rank.svg"
              label="Best rank"
              value={allTimeStats.bestRank}
            />
          </div>
        </section>
      </main>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/(authenticated)/layout.tsx ---
import type { ReactNode } from "react";
import { AppStateProvider } from "@/state";

export default function AuthenticatedLayout({
  children,
}: {
  children: ReactNode;
}) {
  return (
    <div className="min-h-dvh app-background noise text-foreground">
      <AppStateProvider>{children}</AppStateProvider>
    </div>
  );
}

--- File: ./src/app/layout.tsx ---
import "./globals.css";
import { fontBody, fontDisplay, fontInput } from "@/lib/fonts";
import "./globals.css";

import { Metadata } from "next";
import { env } from "@/lib/env";

import { MinikitProvider } from "@/components/providers/MinikitProvider";
import { OnboardingGate } from "@/components/onboarding/onboarding-gate";
import GlobalToaster from "@/components/ui/Toaster";

export async function generateMetadata(): Promise<Metadata> {
  return {
    other: {
      "fc:miniapp": JSON.stringify({
        version: "next",
        imageUrl: `${env.rootUrl}/logo.png`,
        button: {
          title: "Waffles",
          action: {
            type: "launch_miniapp",
            name: "Waffles",
            url: env.rootUrl,
            splashImageUrl: `${env.rootUrl}/images/splash-icon.png`,
            splashBackgroundColor: "#",
          },
        },
      }),
    },
  };
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html
      lang="en"
      className={`${fontBody.variable} ${fontDisplay.variable} ${fontInput.variable}`}
    >
      <body className="text-foreground app-background noise">
        <MinikitProvider>
          <OnboardingGate>{children}</OnboardingGate>
          <GlobalToaster />
        </MinikitProvider>
      </body>
    </html>
  );
}

--- File: ./src/app/api/waitlist/join/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function POST(req: Request) {
  const { fid, referrer } = await req.json();
  if (!fid)
    return NextResponse.json({ error: "fid required" }, { status: 400 });

  let user = await prisma.user.findUnique({ where: { farcasterId: fid } });
  if (!user) user = await prisma.user.create({ data: { farcasterId: fid } });

  // Already on list?
  const existing = await prisma.waitlist.findUnique({
    where: { userId: user.id },
  });
  if (existing) return NextResponse.json({ ok: true, already: true });

  let referredByUser = null;
  if (referrer && referrer !== fid) {
    referredByUser = await prisma.user.findUnique({
      where: { farcasterId: referrer },
    });
    if (referredByUser) {
      // increment inviter invites
      await prisma.waitlist.updateMany({
        where: { userId: referredByUser.id },
        data: { invites: { increment: 1 } },
      });
    }
  }

  await prisma.waitlist.create({
    data: {
      userId: user.id,
      referredBy: referredByUser?.id || null,
    },
  });

  return NextResponse.json({ ok: true });
}

--- File: ./src/app/api/waitlist/status/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const fid = searchParams.get("fid");
  if (!fid)
    return NextResponse.json({ error: "fid required" }, { status: 400 });

  const user = await prisma.user.findUnique({ where: { farcasterId: fid } });
  if (!user) return NextResponse.json({ onList: false });

  const entry = await prisma.waitlist.findUnique({
    where: { userId: user.id },
  });
  if (!entry) return NextResponse.json({ onList: false });

  const rank = await prisma.$queryRaw<{ rank: number }[]>`
    SELECT rank FROM (
      SELECT 
        id,
        ROW_NUMBER() OVER (ORDER BY createdAt - (invites * INTERVAL '2 minutes')) as rank
      FROM "Waitlist"
    ) t
    WHERE t.id = ${entry.id}
  `;

  return NextResponse.json({
    onList: true,
    rank: rank[0]?.rank ?? null,
    invites: entry.invites,
  });
}

--- File: ./src/app/api/tickets/verify/route.ts ---
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/tickets/verify
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json(
      { valid: false, message: "Unauthorized" },
      { status: 401 }
    );
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json(
      { valid: false, message: "User not found" },
      { status: 404 }
    );
  }
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json(
      { valid: false, message: "Missing gameId" },
      { status: 400 }
    );
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json(
      { valid: false, message: "Invalid gameId" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId },
  });
  if (!ticket) {
    return NextResponse.json({ valid: false, message: "Ticket not found" });
  }
  return NextResponse.json({ valid: true });
}

--- File: ./src/app/api/tickets/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { randomBytes } from "crypto";
import { prisma } from "@/lib/db";

// GET /api/tickets
export async function GET(request: Request) {
  try {
    const farcasterId = request.headers.get("x-farcaster-id");
    if (!farcasterId) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    const user = await prisma.user.findUnique({
      where: { farcasterId },
    });
    if (!user) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }
    const tickets = await prisma.ticket.findMany({
      where: { userId: user.id },
      include: { game: true },
    });
    const result = tickets.map((ticket) => ({
      id: ticket.id,
      gameId: ticket.gameId,
      gameTitle: ticket.game.name,
      code: ticket.code,
      amountUSDC: ticket.amountUSDC,
      status: ticket.status,
      txHash: ticket.txHash,
      purchasedAt: ticket.purchasedAt,
      usedAt: ticket.usedAt,
    }));
    return NextResponse.json(result);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// POST /api/tickets
export async function POST(request: Request) {
  const schema = z.object({
    typeId: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { typeId } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const referral = await prisma.referral.findFirst({
    where: { inviteeId: user.id },
  });
  if (!referral) {
    return NextResponse.json(
      { error: "Invite required" },
      { status: 403 }
    );
  }
  // Find game by slug or typeId
  const game = await prisma.game.findUnique({
    where: { id: parseInt(typeId, 10) },
  });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const now = new Date();
  if (game.startTime && now >= game.startTime) {
    return NextResponse.json(
      { error: "Game has already started" },
      { status: 400 }
    );
  }
  const existing = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId: game.id },
  });
  if (existing) {
    return NextResponse.json(
      { error: "Ticket already purchased" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.create({
    data: {
      userId: user.id,
      gameId: game.id,
      amountUSDC: 50,
      code: randomBytes(4).toString("hex").toUpperCase(),
      txHash: null,
      status: "pending",
    },
  });
  return NextResponse.json({
    id: ticket.id,
    gameId: ticket.gameId,
    gameTitle: game.name,
    code: ticket.code,
    amountUSDC: ticket.amountUSDC,
    status: ticket.status,
    txHash: ticket.txHash,
    purchasedAt: ticket.purchasedAt,
    usedAt: ticket.usedAt,
  });
}

--- File: ./src/app/api/tickets/buy/route.ts ---
import { prisma } from "@/lib/db";
import { randomBytes } from "crypto";

/**
 * POST endpoint for creating a Ticket, validated against schema.prisma.
 * - Ensures user and game exist.
 * - Respects unique ticket constraint per (gameId, userId).
 * - Checks for valid positive amount.
 * - Validates USDC amount matches game's config.ticketPrice if available.
 * - Sets status based on txHash.
 * - Returns appropriate error codes and messages for all errors.
 *
 * NOTE: This endpoint now expects `farcasterId` (not userId) and will look up the user.
 */
export async function POST(req: Request) {
  try {
    const { farcasterId, gameId, txHash } = await req.json();
    console.log("buyTicket request:", farcasterId, gameId, txHash);

    // Input validation
    if (!farcasterId || !gameId) {
      return Response.json(
        { error: "Invalid or missing farcasterId, gameId" },
        { status: 400 }
      );
    }

    // Look up user by farcasterId (assume column name is `farcasterId`)
    const user = await prisma.user.findUnique({
      where: { farcasterId: farcasterId.toString() },
    });
    if (!user) {
      return Response.json({ error: "User not found" }, { status: 404 });
    }
    const userId = user.id;

    // Check if game exists and load config
    const game = await prisma.game.findUnique({
      where: { id: gameId },
      include: { config: true },
    });
    if (!game) {
      return Response.json({ error: "Game not found" }, { status: 404 });
    }

    if (!game.config) {
      return Response.json({ error: "Game config not found" }, { status: 404 });
    }

    // Only one ticket per user per game: if already exists, return success
    const existingTicket = await prisma.ticket.findUnique({
      where: {
        gameId_userId: {
          gameId,
          userId,
        },
      },
    });
    if (existingTicket) {
      // Return success with the existing ticket object
      return Response.json(existingTicket, { status: 200 });
    }

    // Generate unique 8-char code
    let code: string;
    let retry = 0;
    while (true) {
      code = randomBytes(6).toString("hex").toUpperCase();
      if (!(await prisma.ticket.findUnique({ where: { code } }))) {
        break;
      }
      retry++;
      if (retry > 5) {
        return Response.json(
          { error: "Could not generate unique ticket code" },
          { status: 500 }
        );
      }
    }

    // Set status
    const status =
      typeof txHash === "string" && txHash.length > 0 ? "confirmed" : "pending";

    // Compose ticket data
    const ticket = await prisma.ticket.create({
      data: {
        user: { connect: { id: userId } },
        game: { connect: { id: gameId } },
        amountUSDC: game.config.ticketPrice,
        code,
        txHash: txHash ?? null,
        status,
      },
    });

    return Response.json(ticket);
  } catch (e) {
    // Prisma known request error for unique constraint violation
    if (
      typeof e === "object" &&
      e !== null &&
      "code" in e &&
      e.code === "P2002"
    ) {
      return Response.json(
        { error: "Ticket already exists for this user and game" },
        { status: 409 }
      );
    }
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/referral/validate/route.ts ---
// ───────────────────────── src/app/api/referral/validate/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

// Accept referral code, and invitee's Farcaster ID (fid)
const bodySchema = z.object({
  code: z.string().length(6),
  fid: z
    .union([z.number().int().nonnegative(), z.string().regex(/^\d+$/)])
    .transform((value) => Number(value)),
});

export async function POST(req: Request) {
  try {
    const json = await req.json();
    const { code, fid } = bodySchema.parse(json);

    // 1️⃣ Find invitee by fid (prisma schema: farcasterId is string)
    const invitee = await prisma.user.findUnique({
      where: { farcasterId: String(fid) },
    });
    console.log("invitee farcasterId:", invitee?.farcasterId);
    if (!invitee) {
      return NextResponse.json(
        {
          valid: false,
          error: "Invitee not found. Complete onboarding first.",
        },
        { status: 404 }
      );
    }
    console.log("Invitee found:", invitee.name);
    console.log("Validating referral code:", code);

    // 2️⃣ Find the referral code (on "referral" table, column: code)
    const referral = await prisma.referral.findUnique({
      where: { code },
    });
    if (!referral) {
      return NextResponse.json(
        { valid: false, error: "Invalid code" },
        { status: 404 }
      );
    }

    console.log("Referral record found:", referral);

    // 3️⃣ Prevent self-referral (can't use your own code)
    if (referral.inviterId === invitee.id) {
      return NextResponse.json(
        { valid: false, error: "Cannot use your own code" },
        { status: 400 }
      );
    }

    console.log("Referral found for code:", code);

    // 4️⃣ Prevent duplicate referrals (same inviter & invitee can't refer more than once)
    const duplicate = await prisma.referral.findFirst({
      where: {
        inviterId: referral.inviterId,
        inviteeId: invitee.id,
      },
    });
    if (duplicate) {
      return NextResponse.json({
        valid: true,
        message: "Already validated",
        inviterId: referral.inviterId,
        inviteeId: invitee.id,
        referral: duplicate,
      });
    }

    // 5️⃣ Set inviteeId on this referral row if not already set (the code is single-use for one invitee)
    // If already set, treat as successful but return that referral row
    if (referral.inviteeId && referral.inviteeId !== invitee.id) {
      // Code already used for another invitee
      return NextResponse.json(
        { valid: false, error: "Code already redeemed by another user." },
        { status: 400 }
      );
    }

    // If this code has not yet been used for an invitee, update the inviteeId column
    let updatedReferral;
    if (!referral.inviteeId) {
      updatedReferral = await prisma.referral.update({
        where: { code },
        data: { inviteeId: invitee.id },
      });
    } else {
      updatedReferral = referral;
    }

    return NextResponse.json({
      valid: true,
      inviterId: referral.inviterId,
      inviteeId: invitee.id,
      referral: updatedReferral,
    });
  } catch (err) {
    console.error("[REFERRAL_VALIDATE_ERROR]", err);
    return NextResponse.json(
      { valid: false, error: "Validation failed" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/referral/status/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const fidParam = searchParams.get("fid");
    if (!fidParam) {
      return NextResponse.json({ error: "Missing fid" }, { status: 400 });
    }

    const user = await prisma.user.findUnique({
      where: { farcasterId: String(fidParam) },
    });

    if (!user) {
      return NextResponse.json({ hasInvite: false });
    }

    const referral = await prisma.referral.findFirst({
      where: { inviteeId: user.id },
      include: {
        inviter: {
          select: { farcasterId: true, name: true },
        },
      },
    });

    if (!referral) {
      return NextResponse.json({ hasInvite: false });
    }

    return NextResponse.json({
      hasInvite: true,
      referral: {
        code: referral.code,
        inviterFarcasterId: referral.inviter?.farcasterId ?? "",
        inviteeId: referral.inviteeId ?? undefined,
        acceptedAt: referral.acceptedAt,
      },
    });
  } catch (error) {
    console.error("Failed to fetch referral status", error);
    return NextResponse.json(
      { error: "Failed to fetch referral status" },
      { status: 500 }
    );
  }
}

export const dynamic = "force-dynamic";

--- File: ./src/app/api/referral/create/route.ts ---
// ───────────────────────── src/app/api/referral/create/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

// Generate a code using modern crypto
function generateCode(length = 6) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const bytes = new Uint8Array(length);
  // Use crypto.getRandomValues for secure randomness
  crypto.getRandomValues(bytes);
  let code = "";
  for (let i = 0; i < length; i++) {
    code += alphabet[bytes[i] % alphabet.length];
  }
  return code;
}

const bodySchema = z.object({
  inviterId: z.number().int().positive(), // User.id of inviter
  fid: z.number().int().positive().optional(), // Farcaster ID of inviter (legacy, optional)
});

export async function POST(req: Request) {
  try {
    const json = await req.json();
    // Accept either { inviterId } or legacy { fid }
    let inviter;
    let inviterId: number | undefined;

    const parsed = bodySchema.safeParse(json);

    if (!parsed.success) {
      return NextResponse.json({ error: "Invalid request" }, { status: 400 });
    }

    if (typeof parsed.data.inviterId === "number") {
      inviterId = parsed.data.inviterId;
      inviter = await prisma.user.findUnique({ where: { id: inviterId } });
    } else if (typeof parsed.data.fid === "number") {
      // Find user by Farcaster ID (string in Prisma schema)
      inviter = await prisma.user.findUnique({
        where: { farcasterId: parsed.data.fid.toString() },
      });
      inviterId = inviter?.id;
    }

    if (!inviter || typeof inviterId !== "number") {
      return NextResponse.json({ error: "Inviter not found" }, { status: 404 });
    }

    // 2️⃣ Check if inviter already has a code
    const existing = await prisma.referral.findFirst({
      where: { inviterId },
      orderBy: { createdAt: "asc" },
    });
    if (existing)
      return NextResponse.json({
        code: existing.code,
        inviterId: existing.inviterId,
        inviteeId: existing.inviteeId ?? undefined,
      });

    // 3️⃣ Create a new referral code (safe & unique)
    let code: string;
    let tries = 0;
    while (true) {
      code = generateCode();
      const already = await prisma.referral.findUnique({ where: { code } });
      if (!already) break;
      tries++;
      if (tries > 10) throw new Error("Referral code collision");
    }
    const referral = await prisma.referral.create({
      data: {
        code,
        inviterId,
      },
    });

    return NextResponse.json({
      code: referral.code,
      inviterId: referral.inviterId,
      inviteeId: referral.inviteeId ?? undefined,
    });
  } catch (err) {
    console.error("[REFERRAL_CREATE_ERROR]", err);
    return NextResponse.json(
      { error: "Failed to create referral code" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/chat/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/chat?gameId=
export async function GET(request: Request) {
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json({ error: "Missing gameId" }, { status: 400 });
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid gameId" }, { status: 400 });
  }
  const messages = await prisma.chat.findMany({
    where: { gameId },
    include: { user: true },
    orderBy: { createdAt: "asc" },
  });
  // Return shape compatible with Chat components (messages with nested user)
  return NextResponse.json(
    messages.map((msg) => ({
      id: msg.id,
      gameId: msg.gameId,
      userId: msg.userId,
      user: {
        name: msg.user?.name ?? "anon",
        imageUrl: msg.user?.imageUrl ?? null,
      },
      message: msg.message,
      createdAt: msg.createdAt,
    }))
  );
}

// POST /api/chat
export async function POST(request: Request) {
  const schema = z.object({
    gameId: z.number(),
    message: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { gameId, message } = parseResult.data;
  // Allow either header or body to provide farcasterId
  let farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    try {
      const bodyJson = await request.clone().json();
      if (bodyJson?.farcasterId) farcasterId = String(bodyJson.farcasterId);
    } catch {}
  }
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId: String(farcasterId) },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const game = await prisma.game.findUnique({ where: { id: gameId } });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const chat = await prisma.chat.create({
    data: {
      userId: user.id,
      gameId,
      message,
    },
  });
  return NextResponse.json(chat);
}

--- File: ./src/app/api/auth/route.ts ---
import { Errors, createClient } from "@farcaster/quick-auth";
import { NextRequest, NextResponse } from "next/server";

const client = createClient();

// Helper function to determine the correct domain for JWT verification
function getUrlHost(request: NextRequest): string {
  // First try to get the origin from the Origin header (most reliable for CORS requests)
  const origin = request.headers.get("origin");
  if (origin) {
    try {
      const url = new URL(origin);
      return url.host;
    } catch (error) {
      console.warn("Invalid origin header:", origin, error);
    }
  }

  // Fallback to Host header
  const host = request.headers.get("host");
  if (host) {
    return host;
  }

  // Final fallback to environment variables (your original logic)
  let urlValue: string;
  if (process.env.VERCEL_ENV === "production") {
    urlValue = process.env.NEXT_PUBLIC_URL!;
  } else if (process.env.VERCEL_URL) {
    urlValue = `https://${process.env.VERCEL_URL}`;
  } else {
    urlValue = "http://localhost:3000";
  }

  const url = new URL(urlValue);
  return url.host;
}

export async function GET(request: NextRequest) {
  // Because we're fetching this endpoint via `sdk.quickAuth.fetch`,
  // if we're in a mini app, the request will include the necessary `Authorization` header.
  const authorization = request.headers.get("Authorization");

  // Here we ensure that we have a valid token.
  if (!authorization || !authorization.startsWith("Bearer ")) {
    return NextResponse.json({ message: "Missing token" }, { status: 401 });
  }

  try {
    // Now we verify the token. `domain` must match the domain of the request.
    // In our case, we're using the `getUrlHost` function to get the domain of the request
    // based on the Vercel environment. This will vary depending on your hosting provider.
    const payload = await client.verifyJwt({
      token: authorization.split(" ")[1] as string,
      domain: getUrlHost(request),
    });

    console.log("payload", payload);

    // If the token was valid, `payload.sub` will be the user's Farcaster ID.
    const userFid = payload.sub;

    // Return user information for your waitlist application
    return NextResponse.json({
      success: true,
      user: {
        fid: userFid,
        issuedAt: payload.iat,
        expiresAt: payload.exp,
      },
    });

  } catch (e) {
    if (e instanceof Errors.InvalidTokenError) {
      return NextResponse.json({ message: "Invalid token" }, { status: 401 });
    }
    if (e instanceof Error) {
      return NextResponse.json({ message: e.message }, { status: 500 });
    }
    throw e;
  }
}
--- File: ./src/app/api/lobby/join/route.ts ---
import { prisma } from "@/lib/db";

export async function POST(req: Request) {
  try {
    const { userId, gameId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    await prisma.chat.create({
      data: {
        userId,
        gameId,
        message: "joined the lobby.",
      },
    });

    return Response.json({ success: true });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/lobby/stats/route.ts ---
import { prisma } from "@/lib/db";

export async function GET() {
  try {
    const tickets = await prisma.ticket.findMany({
      where: { status: "confirmed" },
      include: { user: true },
    });

    const totalTickets = tickets.length;
    const totalPrize = totalTickets * 50; // each ticket costs 50 USDC

    // Return top 10 players by activity
    const players = tickets.map((t) => ({
      name: t.user.name,
      wallet: t.user.wallet,
      imageUrl: t.user.imageUrl,
    }));

    return Response.json({
      totalTickets,
      totalPrize,
      players,
    });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/user/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

// GET /api/user?farcasterId=123
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const farcasterId = searchParams.get("farcasterId");

  if (!farcasterId) {
    return NextResponse.json(
      { success: false, error: "Missing farcasterId parameter" },
      { status: 400 }
    );
  }

  try {
    const user = await prisma.user.findUnique({
      where: { farcasterId: farcasterId },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, user });
  } catch (err) {
    console.error("User get failed", err);
    return NextResponse.json(
      { success: false, error: "User get failed" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/user/sync/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";
import { randomBytes } from "crypto";

const schema = z.object({
  fid: z.number(),
  username: z.string().optional(),
  pfpUrl: z.string().url().optional(),
  wallet: z.string().optional(),
});

const REFERRAL_CODE_LENGTH = 6;

function generateReferralCode(): string {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const bytes = randomBytes(REFERRAL_CODE_LENGTH);
  let code = "";
  for (let i = 0; i < REFERRAL_CODE_LENGTH; i++) {
    code += alphabet[bytes[i] % alphabet.length];
  }
  return code;
}

async function ensureReferral(inviterId: number) {
  const existing = await prisma.referral.findFirst({
    where: { inviterId },
    orderBy: { createdAt: "asc" },
  });
  if (existing) return existing;

  // Generate a unique code – retry a few times to avoid collisions
  for (let attempt = 0; attempt < 10; attempt++) {
    const code = generateReferralCode();
    try {
      return await prisma.referral.create({
        data: {
          code,
          inviterId,
        },
      });
    } catch (err) {
      if (
        typeof err === "object" &&
        err !== null &&
        "code" in err &&
        err.code === "P2002"
      ) {
        continue; // collision, try again
      }
      throw err;
    }
  }

  throw new Error("Failed to generate referral code");
}

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const data = schema.parse(body);

    const user = await prisma.user.upsert({
      where: { farcasterId: String(data.fid) },
      update: {
        name: data.username ?? undefined,
        imageUrl: data.pfpUrl ?? undefined,
        wallet: data.wallet ?? undefined,
      },
      create: {
        farcasterId: String(data.fid),
        name: data.username ?? null,
        imageUrl: data.pfpUrl ?? null,
        wallet: data.wallet ?? null,
      },
    });

    const referral = await ensureReferral(user.id);

    return NextResponse.json({
      success: true,
      user,
      referralCode: referral.code,
    });
  } catch (err) {
    console.error("User sync failed", err);
    return NextResponse.json(
      {
        success: false,
        error: "User sync failed",
      },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/leaderboard/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { env } from "@/lib/env";

export type LeaderboardUser = {
  id: string;
  rank: number;
  name: string;
  imageUrl: string;
  points: number;
};

// GET /api/leaderboard?tab=current|allTime&page=0&gameId=&userId=
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const tabParam = (searchParams.get("tab") || "allTime") as
    | "current"
    | "allTime";
  const page = Number.parseInt(searchParams.get("page") ?? "0", 10);
  const gameIdParam = searchParams.get("gameId");
  const userIdParam = searchParams.get("userId");

  if (!["current", "allTime"].includes(tabParam)) {
    return NextResponse.json({ error: "Invalid tab" }, { status: 400 });
  }
  if (!Number.isFinite(page) || page < 0) {
    return NextResponse.json({ error: "Invalid page" }, { status: 400 });
  }

  let users: LeaderboardUser[] = [];

  if (tabParam === "current") {
    // Determine which game is "current"
    let game = null;
    if (gameIdParam) {
      game = await prisma.game.findUnique({
        where: { id: Number(gameIdParam) },
      });
    } else {
      const now = new Date();
      game =
        (await prisma.game.findFirst({
          where: { startTime: { lte: now }, endTime: { gte: now } },
          orderBy: { startTime: "desc" },
        })) ??
        (await prisma.game.findFirst({
          where: { endTime: { lte: now } },
          orderBy: { endTime: "desc" },
        }));
    }

    if (game) {
      const scores = await prisma.score.findMany({
        where: { gameId: game.id },
        include: { user: true },
        orderBy: { points: "desc" },
      });

      users = scores.map((s, i) => ({
        id: s.userId.toString(),
        rank: i + 1,
        name: s.user?.name || "",
        imageUrl: s.user?.imageUrl || "",
        points: s.points,
      }));
    }
  } else {
    // All-time leaderboard (sum of points per user)
    const grouped = await prisma.score.groupBy({
      by: ["userId"],
      _sum: { points: true },
      orderBy: { _sum: { points: "desc" } },
    });

    const userIds = grouped.map((g) => g.userId);
    const usersData = await prisma.user.findMany({
      where: { id: { in: userIds } },
    });

    users = grouped.map((g, i) => {
      const user = usersData.find((u) => u.id === g.userId);
      return {
        id: g.userId.toString(),
        rank: i + 1,
        name: user?.name || "",
        imageUrl: user?.imageUrl || "",
        points: g._sum.points || 0,
      };
    });
  }

  // pagination
  const totalPlayers = users.length;
  const totalPoints = users.reduce((sum, u) => sum + (u.points ?? 0), 0);
  const pageSize = env.nextPublicLeaderboardPageSize;
  const start = page * pageSize;
  const end = start + pageSize;
  const pageUsers = users.slice(start, end);
  const hasMore = end < users.length;

  // optional "me"
  let me = null;
  if (userIdParam) {
    const userId = Number(userIdParam);
    const found = users.find((u) => Number(u.id) === userId);
    if (found) me = found;
  }

  return NextResponse.json({
    users: pageUsers,
    hasMore,
    me,
    totalPlayers,
    totalPoints,
  });
}

export const dynamic = "force-dynamic";

--- File: ./src/app/api/game/answer/route.ts ---
import { prisma } from "@/lib/db";
import { calculateScore } from "@/lib/scoring";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    const { farcasterId, gameId, questionId, selected, timeTaken } =
      await req.json();

    if (!farcasterId || !gameId || !questionId || !selected)
      return NextResponse.json({ error: "Missing fields" }, { status: 400 });

    const user = await prisma.user.findUnique({
      where: { farcasterId: String(farcasterId) },
    });
    if (!user)
      return NextResponse.json({ error: "User not found" }, { status: 404 });

    const question = await prisma.question.findUnique({
      where: { id: questionId },
    });
    if (!question)
      return NextResponse.json(
        { error: "Question not found" },
        { status: 404 }
      );

    const game = await prisma.game.findUnique({
      where: { id: gameId },
      include: { config: true },
    });
    if (!game)
      return NextResponse.json({ error: "Game not found" }, { status: 404 });

    const roundLimit = game.config?.roundTimeLimit ?? 15;
    const maxTime =
      Number.isFinite(roundLimit) && roundLimit > 0 ? roundLimit : 15;
    const sanitizedTime = Math.min(
      Math.max(0, Number(timeTaken) || 0),
      maxTime
    );
    const correct = selected === question.correctAnswer;
    const newPoints = correct ? calculateScore(sanitizedTime, maxTime) : 0;

    await prisma.$transaction(async (tx) => {
      const previousAnswer = await tx.answer.findUnique({
        where: {
          userId_gameId_questionId: { userId: user.id, gameId, questionId },
        },
      });

      const previousPoints =
        previousAnswer?.isCorrect && Number.isFinite(previousAnswer.timeTaken)
          ? calculateScore(previousAnswer.timeTaken, maxTime)
          : 0;

      await tx.answer.upsert({
        where: {
          userId_gameId_questionId: { userId: user.id, gameId, questionId },
        },
        update: {
          selected,
          isCorrect: correct,
          timeTaken: sanitizedTime,
        },
        create: {
          userId: user.id,
          gameId,
          questionId,
          selected,
          isCorrect: correct,
          timeTaken: sanitizedTime,
        },
      });

      const existingScore = await tx.score.findUnique({
        where: { userId_gameId: { userId: user.id, gameId } },
      });

      const delta = newPoints - previousPoints;

      if (existingScore) {
        const nextPoints = Math.max(0, existingScore.points + delta);
        await tx.score.update({
          where: { userId_gameId: { userId: user.id, gameId } },
          data: { points: nextPoints },
        });
      } else {
        await tx.score.create({
          data: { userId: user.id, gameId, points: newPoints },
        });
      }
    });

    return NextResponse.json({ correct, points: newPoints });
  } catch (e) {
    console.error(e);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/game/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/games
export async function GET() {
  const games = await prisma.game.findMany({
    orderBy: { startTime: "asc" },
  });
  return NextResponse.json(games);
}

// POST /api/games
export async function POST(request: NextRequest) {
  const schema = z.object({
    name: z.string().min(1),
    description: z.string().optional(),
    startTime: z.string(),
    endTime: z.string(),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { name, description, startTime, endTime } = parseResult.data;
  const start = new Date(startTime);
  const end = new Date(endTime);
  if (isNaN(start.getTime()) || isNaN(end.getTime())) {
    return NextResponse.json({ error: "Invalid date format" }, { status: 400 });
  }
  if (start >= end) {
    return NextResponse.json(
      { error: "startTime must be before endTime" },
      { status: 400 }
    );
  }
  const game = await prisma.game.create({
    data: {
      name,
      description,
      startTime: start,
      endTime: end,
    },
  });
  return NextResponse.json(game);
}

--- File: ./src/app/api/game/active/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

// This route returns the "active" game, defined as a game with an endTime in the future (per schema.prisma).
// It is robust against multiple edge cases and ensures the latest game is returned.

export async function GET() {
  try {
    // Find the most recently created game whose endTime is still in the future
    const now = new Date();

    const game = await prisma.game.findFirst({
      where: {
        endTime: {
          gt: now,
        },
        startTime: {
          lte: now, // only return started games
        },
      },
      include: {
        config: true,
        questions: {
          orderBy: { id: "asc" }, // always order Qs by id for predictability
        },
      },
      orderBy: { createdAt: "desc" },
    });

    if (!game) {
      return NextResponse.json({ error: "No active game" }, { status: 404 });
    }

    // Defensive: ensure config and questions are present per @schema.prisma constraints
    if (!game.config) {
      return NextResponse.json(
        { error: "Active game missing config" },
        { status: 500 }
      );
    }
    if (!Array.isArray(game.questions) || game.questions.length === 0) {
      return NextResponse.json(
        { error: "Active game missing questions" },
        { status: 500 }
      );
    }

    // Remove sensitive or large fields (future-proofing)
    const { ...sanitizedGame } = game;
    // e.g. delete sanitizedGame.secretField; if ever such is added

    return NextResponse.json(sanitizedGame, { status: 200 });
  } catch (err) {
    // Catch all runtime and DB errors
    console.error("/api/game/active GET Error:", err);
    return NextResponse.json(
      { error: "Internal server error", detail: (err as Error).message || err },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/game/[id]/route.ts ---
import { prisma } from "@/lib/db";
import { NextResponse } from "next/server";

export async function GET(
  _req: Request,
  context: { params: Promise<{ id: string }> }
) {
  const resolvedParams = await context.params;
  const gameId = parseInt(resolvedParams.id, 10);
  if (Number.isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
  }
  const game = await prisma.game.findUnique({
    where: { id: gameId },
    include: { questions: true },
  });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  // Exclude correct answers in questions
  const questions = game.questions.map((q) => ({
    id: q.id,
    questionText: q.text,
    imageUrl: q.imageUrl,
    options: q.options,
  }));
  const { id, name, description, startTime, endTime } = game;
  return NextResponse.json({
    id,
    name,
    description,
    startTime,
    endTime,
    questions,
  });
}

--- File: ./src/app/api/game/[id]/questions/route.ts ---
import { prisma } from "@/lib/db";
import { NextResponse } from "next/server";

export async function GET(
  _req: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const resolved = await context.params;
    const gameId = Number(resolved.id);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid game id" }, { status: 400 });
    }

    const game = await prisma.game.findUnique({ where: { id: gameId } });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const questions = await prisma.question.findMany({
      where: { gameId },
      orderBy: { id: "asc" },
      select: {
        id: true,
        text: true,
        imageUrl: true,
        options: true,
        correctAnswer: true,
      },
    });

    return NextResponse.json({ gameId, questions });
  } catch (e) {
    console.error("questions GET error", e);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/social/friends/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { neynar } from "@/lib/neynarClient";
import { fetchActiveGame } from "@/lib/server/game";

type FriendSummary = {
  fid: number;
  username: string;
  displayName?: string | null;
  pfpUrl?: string | null;
  relationship: {
    isFollower: boolean;
    isFollowing: boolean;
  };
  hasTicket: boolean;
  ticketId?: number;
  ticketGameId?: number;
};

const DEFAULT_LIMIT = 20;

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const fidParam = searchParams.get("fid");
    if (!fidParam) {
      return NextResponse.json(
        { error: "Missing fid parameter" },
        { status: 400 }
      );
    }
    const fid = Number(fidParam);
    if (!Number.isFinite(fid) || fid <= 0) {
      return NextResponse.json({ error: "Invalid fid" }, { status: 400 });
    }

    const limitParam = Number.parseInt(
      searchParams.get("limit") ?? String(DEFAULT_LIMIT),
      10
    );
    const limit = Number.isFinite(limitParam)
      ? Math.max(1, Math.min(limitParam, 150))
      : DEFAULT_LIMIT;

    const gameIdParam = searchParams.get("gameId");
    let targetGameId: number | null = null;
    if (gameIdParam) {
      const parsed = Number(gameIdParam);
      if (Number.isFinite(parsed)) {
        targetGameId = parsed;
      }
    }
    if (!targetGameId) {
      const active = await fetchActiveGame();
      targetGameId = active?.id ?? null;
    }

    const [followersRes, followingRes] = await Promise.all([
      neynar.fetchUserFollowers({
        fid,
        limit,
      }),
      neynar.fetchUserFollowing({
        fid,
        limit,
      }),
    ]);

    console.log("followersRes", followersRes);
    console.log("followingRes", followingRes);

    type FriendAccumulator = {
      username: string;
      displayName?: string | null;
      pfpUrl?: string | null;
      isFollower: boolean;
      isFollowing: boolean;
    };

    const friends = new Map<number, FriendAccumulator>();

    const ingest = (
      list: typeof followersRes.users,
      key: "isFollower" | "isFollowing"
    ) => {
      for (const entry of list) {
        const user = entry?.user;
        if (!user?.fid) continue;
        const existing = friends.get(user.fid);
        if (existing) {
          existing[key] = true;
        } else {
          friends.set(user.fid, {
            username: user.username,
            displayName: user.display_name ?? null,
            pfpUrl: user.pfp_url ?? null,
            isFollower: key === "isFollower",
            isFollowing: key === "isFollowing",
          });
        }
      }
    };

    ingest(followersRes.users ?? [], "isFollower");
    ingest(followingRes.users ?? [], "isFollowing");

    if (friends.size === 0) {
      return NextResponse.json({ friends: [], gameId: targetGameId });
    }

    const friendFids = Array.from(friends.keys());
    const friendFidStrings = friendFids.map(String);

    const friendUsers = await prisma.user.findMany({
      where: { farcasterId: { in: friendFidStrings } },
      include: {
        tickets: targetGameId
          ? {
              where: { gameId: targetGameId },
              orderBy: { purchasedAt: "desc" },
            }
          : {
              orderBy: { purchasedAt: "desc" },
              take: 1,
            },
      },
    });

    const ticketLookup = new Map<
      string,
      { ticketId: number; gameId: number }
    >();
    for (const user of friendUsers) {
      const firstTicket = user.tickets?.[0];
      if (firstTicket) {
        ticketLookup.set(String(user.farcasterId), {
          ticketId: firstTicket.id,
          gameId: firstTicket.gameId,
        });
      }
    }

    const result: FriendSummary[] = friendFids.map((friendFid) => {
      const base = friends.get(friendFid)!;
      const ticketInfo = ticketLookup.get(String(friendFid));
      return {
        fid: friendFid,
        username: base.username,
        displayName: base.displayName,
        pfpUrl: base.pfpUrl,
        relationship: {
          isFollower: base.isFollower,
          isFollowing: base.isFollowing,
        },
        hasTicket: Boolean(
          ticketInfo && (!targetGameId || ticketInfo.gameId === targetGameId)
        ),
        ticketId: ticketInfo?.ticketId,
        ticketGameId: ticketInfo?.gameId,
      };
    });

    // Sort: friends with tickets first, then alphabetically
    result.sort((a, b) => {
      if (a.hasTicket !== b.hasTicket) {
        return a.hasTicket ? -1 : 1;
      }
      return a.username.localeCompare(b.username);
    });

    return NextResponse.json({
      friends: result,
      gameId: targetGameId,
    });
  } catch (error) {
    console.error("Failed to fetch Farcaster friends", error);
    return NextResponse.json(
      { error: "Failed to fetch friends" },
      { status: 500 }
    );
  }
}

export const dynamic = "force-dynamic";

--- File: ./src/app/api/profile/route.ts ---
// ───────────────────────── /app/api/profile/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/profile
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { farcasterId },
    select: { id: true, name: true, wallet: true, imageUrl: true },
  });

  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  return NextResponse.json(user);
}

// PUT /api/profile
export async function PUT(request: Request) {
  const schema = z.object({
    name: z.string().trim().optional(),
    wallet: z.string().trim().optional(),
    imageUrl: z.string().url().optional(),
  });

  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  const parsed = schema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }

  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const updated = await prisma.user.update({
    where: { id: user.id },
    data: parsed.data,
    select: { id: true, name: true, wallet: true, imageUrl: true },
  });

  return NextResponse.json(updated);
}

--- File: ./src/app/api/profile/history/route.ts ---
// ───────────────────────── /app/api/profile/history/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
    orderBy: { game: { endTime: "desc" } },
  });

  const history = scores.map((s) => ({
    id: s.id,
    name: s.game.name,
    score: s.points,
    winnings: s.points,
    winningsColor: s.points > 0 ? "green" : "gray",
  }));

  return NextResponse.json(history);
}

--- File: ./src/app/api/profile/stats/route.ts ---
// ───────────────────────── /app/api/profile/stats/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
  });

  const totalGames = scores.length;
  if (totalGames === 0) {
    return NextResponse.json({
      totalGames: 0,
      wins: 0,
      winRate: 0,
      totalWon: 0,
      highestScore: 0,
      avgScore: 0,
      currentStreak: 0,
      bestRank: 0,
    });
  }

  let wins = 0;
  let totalWon = 0;
  let highestScore = 0;
  let bestRank = Infinity;

  // Sort by endTime (latest first)
  const sortedScores = [...scores].sort((a, b) => {
    const aTime = a.game.endTime?.getTime() ?? 0;
    const bTime = b.game.endTime?.getTime() ?? 0;
    return bTime - aTime;
  });

  // Preload all game results to calculate ranks efficiently
  const gameIds = [...new Set(sortedScores.map((s) => s.gameId))];
  const allGameScores = await prisma.score.findMany({
    where: { gameId: { in: gameIds } },
    select: { gameId: true, points: true },
  });

  // Compute stats
  let currentStreak = 0;
  for (const s of sortedScores) {
    totalWon += s.points;
    highestScore = Math.max(highestScore, s.points);

    // Rank calculation
    const rank =
      allGameScores.filter((g) => g.gameId === s.gameId && g.points > s.points)
        .length + 1;
    bestRank = Math.min(bestRank, rank);

    if (rank === 1) {
      wins++;
      currentStreak++;
    } else {
      break;
    }
  }

  const avgScore = totalWon / totalGames;
  const winRate = (wins / totalGames) * 100;

  return NextResponse.json({
    totalGames,
    wins,
    winRate: Math.round(winRate * 10) / 10,
    totalWon,
    highestScore,
    avgScore: Math.round(avgScore * 100) / 100,
    currentStreak,
    bestRank: bestRank === Infinity ? 0 : bestRank,
  });
}

--- File: ./src/app/api/final/match/route.ts ---
import { prisma } from "@/lib/db";
import { isMatch } from "@/lib/scoring";

export async function POST(req: Request) {
  try {
    const { userId, gameId, choiceId, targetId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const correct = isMatch(choiceId, targetId);
    const points = correct ? 100 : 0;

    await prisma.score.upsert({
      where: { userId_gameId: { userId, gameId } },
      update: { points: { increment: points } },
      create: { userId, gameId, points },
    });

    return Response.json({ correct, points });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/final/start/route.ts ---
import { prisma } from "@/lib/db";

export async function GET() {
  try {
    const allQuestions = await prisma.question.findMany({
      take: 20,
      orderBy: { id: "asc" },
    });

    const pairs = allQuestions.map((q) => ({
      id: q.id,
      originalUrl: q.imageUrl,
      generatedUrl: q.imageUrl.replace("original", "ai"), // simple mock pattern
    }));

    return Response.json({ pairs });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/og/image.tsx ---
import { ImageResponse } from "next/og";

export const runtime = "edge";

export const size = { width: 1200, height: 630 };
export const contentType = "image/png";

export default async function Image({
  searchParams,
}: {
  searchParams: { username?: string; score?: string };
}) {
  const { username = "Player", score = "0" } = searchParams;
  return new ImageResponse(
    (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          background: "linear-gradient(180deg, #1E1E1E 0%, #000000 100%)",
          width: "100%",
          height: "100%",
          color: "white",
          fontFamily: "sans-serif",
        }}
      >
        <h1 style={{ fontSize: 64, color: "#FFD700" }}>Waffles Champion</h1>
        <p style={{ fontSize: 36 }}>{username}</p>
        <p style={{ fontSize: 28, color: "#BBB" }}>{score} pts</p>
      </div>
    ),
    { ...size }
  );
}

--- File: ./src/app/page.tsx ---
"use client";

import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function Home() {
  const router = useRouter();

  useEffect(() => {
    router.replace("/game");
  }, [router]);

  return null;
}

--- File: ./src/app/globals.css ---
@layer base, components, utilities;

@import "tailwindcss";
@import "tw-animate-css";

/* ------------------------------------------------------------
   GLOBAL BRAND + THEME TOKENS
   ------------------------------------------------------------ */
@custom-variant dark (&:is(.dark *));

:root {
  /* ── Brand Colors ───────────────────────────── */
  --brand-gold: oklch(0.83 0.17 95); /* #FFC931 */
  --brand-cyan: oklch(0.78 0.19 210); /* #00CFF2 */
  --brand-black: #1e1e1e;
  --brand-pink: oklch(0.73 0.22 342); /* #FB72FF */

  --brand-ink-950: oklch(0.12 0 0); /* Black */
  --brand-ink-900: oklch(0.19 0 0); /* Dark Gray */
  --brand-ink-800: oklch(0.24 0 0); /* Medium Gray */
  --brand-white: oklch(1 0 0); /* White */

  /* ── Alpha Utilities ────────────────────────── */
  --white-a07: #ffffff12;
  --white-a08: #ffffff14;
  --white-a10: #ffffff1a;
  --white-a13: #ffffff21;
  --white-a38: #ffffff61;

  /* ── Base Semantic Colors (light mode) ───────── */
  --surface-page: linear-gradient(180deg, var(--brand-ink-800) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-800) 90%, #000 10%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-800) 92%, #000 8%);
  --surface-tint: var(--white-a10);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.74 0 0); /* #99A0AE */

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a13);
  --accent-ring: var(--brand-gold);

  --success: #14b985;
  --danger: oklch(0.65 0.22 25);

  /* ── Sidebar Colors ─────────────────────────── */
  --sidebar-bg: var(--brand-white);
  --sidebar-fg: var(--brand-ink-900);
  --sidebar-primary: var(--brand-ink-800);
  --sidebar-primary-fg: var(--brand-white);
  --sidebar-accent: var(--white-a10);
  --sidebar-accent-fg: var(--brand-ink-900);
  --sidebar-border: #eaeaea;
  --sidebar-ring: #b5b5b5;

  /* ── Radii & Decorative BGs ─────────────────── */
  --radius-xs: 8px;
  --radius-sm: 12px;
  --radius-md: 16px;

  --gold-overlay: linear-gradient(
    189.66deg,
    rgba(0, 0, 0, 0) -6.71%,
    rgba(0, 0, 0, 0.8) 92.73%
  );
  --card-glint: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    color-mix(in oklch, var(--brand-gold) 25%, transparent) 100%
  );

  /* ── Noise Overlay ──────────────────────────── */
  --noise-opacity: 0.25;
  --noise-size: 200px;

  /* ── Dark Theme Defaults (fallbacks for base) ─ */
  --background: oklch(0.08 0 0);
  --foreground: oklch(0.98 0 0);
  --card: oklch(0.12 0 0);
  --card-foreground: oklch(0.98 0 0);
  --popover: oklch(0.1 0 0);
  --popover-foreground: oklch(0.98 0 0);
}

/* ------------------------------------------------------------
   DARK THEME OVERRIDES
   ------------------------------------------------------------ */
.dark {
  --surface-page: linear-gradient(180deg, var(--brand-ink-900) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-900) 95%, #000 5%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-900) 93%, #000 7%);
  --surface-tint: var(--white-a07);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.72 0 0);

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a10);
  --accent-ring: var(--brand-gold);
}

/* ------------------------------------------------------------
   TAILWIND THEME BRIDGE
   ------------------------------------------------------------ */
@theme inline {
  /* fonts */
  --font-display: var(--font-display);
  --font-body: var(--font-body);

  /* semantic colors */
  --color-background: var(--brand-black);
  --color-card: var(--surface-card);
  --color-popover: var(--surface-popover);
  --color-foreground: var(--text-primary);
  --color-muted: var(--text-muted);
  --color-primary: var(--accent-solid);
  --color-secondary: var(--brand-cyan);

  --color-border: var(--surface-stroke);
  --color-input: var(--surface-tint);
  --color-ring: var(--accent-ring);

  /* brand aliases */
  --color-waffle-gold: var(--brand-gold);
  --color-neon-cyan: var(--brand-cyan);
  --color-neon-pink: var(--brand-pink);
  --color-success: var(--success);
  --color-danger: var(--danger);

  /* radii */
  --radius-sm: var(--radius-xs);
  --radius-md: var(--radius-sm);
  --radius-lg: var(--radius-md);
}

/* ------------------------------------------------------------
   BASE LAYER
   ------------------------------------------------------------ */
@layer base {
  html,
  body {
    height: 100%;
  }
  body {
    @apply bg-background text-foreground antialiased;
    font-family: var(--font-body);
  }
}

/* ------------------------------------------------------------
   UTILITIES
   ------------------------------------------------------------ */

/* Page gradient background */
@utility app-background {
  background-color: var(--brand-black);
  background-attachment: fixed;
  background-repeat: no-repeat;
  background-size: cover;
}

/* Gold overlay card */
@utility bg-gold-overlay {
  background: var(--gold-overlay), var(--brand-gold);
  background-blend-mode: overlay, normal;
}

/* Card glint */
@utility bg-card-glint {
  background-image: var(--card-glint);
}

/* Subtle panel style */
@utility panel {
  background: var(--white-a10);
  border: 1px solid var(--surface-stroke);
  border-radius: var(--radius-md);
}

/* Noise overlay container */
@utility noise {
  position: relative;
  isolation: isolate;
}

.noise::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 1;
  opacity: var(--noise-opacity);
  mix-blend-mode: overlay;
  background-size: var(--noise-size) var(--noise-size);
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='1.4' numOctaves='4' stitchTiles='stitch'/></filter><rect width='100%' height='100%' filter='url(%23n)' fill='white'/></svg>");
}

/* Neon glow */
@utility neon {
  text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
}

/* Global transition curve */
@media (prefers-reduced-motion: no-preference) {
  * {
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }
}

/* ------------------------------------------------------------
   ANIMATIONS
   ------------------------------------------------------------ */
@keyframes glow-pulse {
  0%,
  100% {
    opacity: 1;
    filter: brightness(1);
  }
  50% {
    opacity: 0.85;
    filter: brightness(1.15);
  }
}

@keyframes slide-up {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes slide-in-x {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@utility animate-glow {
  animation: glow-pulse 2s ease-in-out infinite;
}
@utility animate-up {
  animation: slide-up 0.28s ease-out both;
}
@utility animate-in-right {
  animation: slide-in-x 0.28s ease-out both;
}

@utility pixel-corners {
  /* The precise polygon shape for the pixelated corners */
  clip-path: polygon(
    0px 12px,
    6px 12px,
    6px 6px,
    12px 6px,
    12px 0px,
    calc(100% - 12px) 0px,
    calc(100% - 12px) 6px,
    calc(100% - 6px) 6px,
    calc(100% - 6px) 12px,
    100% 12px,
    100% calc(100% - 12px),
    calc(100% - 6px) calc(100% - 12px),
    calc(100% - 6px) calc(100% - 6px),
    calc(100% - 12px) calc(100% - 6px),
    calc(100% - 12px) 100%,
    12px 100%,
    12px calc(100% - 6px),
    6px calc(100% - 6px),
    6px calc(100% - 12px),
    0% calc(100% - 12px)
  );
}

/* ───────────────────────── Base Interaction Animations ───────────────────────── */

/* Fade-in */
.fade-in {
  animation: fadeIn 0.6s ease forwards;
}
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Slide-up */
.slide-up {
  animation: slideUp 0.5s ease forwards;
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Subtle scale pop for tap feedback */
.tap-pop {
  transition: transform 0.12s ease;
}
.tap-pop:active {
  transform: scale(0.96);
}

--- File: ./src/state/lobby/LobbyContext.tsx ---
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useReducer,
} from "react";

interface Player {
  username: string;
  wallet: string;
  pfpUrl: string | null;
}

interface LobbyStats {
  totalTickets: number;
  totalPrize: number;
  players: Player[];
}

export interface Ticket {
  id?: number;
  gameId?: number;
  txHash?: string | null;
  code?: string;
  amountUSDC?: number;
  status?: string;
  purchasedAt?: string;
  usedAt?: string | null;
}

interface ReferralCode {
  code: string;
  inviterFarcasterId: string;
  inviteeId?: number;
}

interface InvitedBy {
  code: string;
  inviterFarcasterId: string | null;
  acceptedAt?: string | null;
}

interface LobbyState {
  stats: LobbyStats | null;
  statsLoading: boolean;
  ticket: Ticket | null;
  ticketLoading: boolean;
  myReferral: ReferralCode | null;
  invitedBy: InvitedBy | null;
  hasValidInvite: boolean;
  inviteStatusLoaded: boolean;
  lastError: string | null;
}

type LobbyAction =
  | { type: "SET_STATS"; stats: LobbyStats | null; loading?: boolean }
  | { type: "SET_TICKET"; ticket: Ticket | null; loading?: boolean }
  | { type: "SET_MY_REFERRAL"; referral: ReferralCode | null }
  | { type: "SET_INVITED_BY"; invitedBy: InvitedBy | null }
  | { type: "SET_HAS_INVITE"; value: boolean }
  | { type: "SET_INVITE_STATUS_LOADED"; value: boolean }
  | { type: "SET_ERROR"; error: string | null }
  | { type: "SET_TICKET_LOADING"; value: boolean }
  | { type: "SET_STATS_LOADING"; value: boolean };

const initialState: LobbyState = {
  stats: null,
  statsLoading: false,
  ticket: null,
  ticketLoading: false,
  myReferral: null,
  invitedBy: null,
  hasValidInvite: false,
  inviteStatusLoaded: false,
  lastError: null,
};

function lobbyReducer(state: LobbyState, action: LobbyAction): LobbyState {
  switch (action.type) {
    case "SET_STATS":
      return {
        ...state,
        stats: action.stats,
        statsLoading: action.loading ?? false,
      };
    case "SET_TICKET":
      return {
        ...state,
        ticket: action.ticket,
        ticketLoading: action.loading ?? false,
      };
    case "SET_MY_REFERRAL":
      return { ...state, myReferral: action.referral };
    case "SET_INVITED_BY":
      return { ...state, invitedBy: action.invitedBy };
    case "SET_HAS_INVITE":
      return { ...state, hasValidInvite: action.value };
    case "SET_INVITE_STATUS_LOADED":
      return { ...state, inviteStatusLoaded: action.value };
    case "SET_ERROR":
      return { ...state, lastError: action.error };
    case "SET_TICKET_LOADING":
      return { ...state, ticketLoading: action.value };
    case "SET_STATS_LOADING":
      return { ...state, statsLoading: action.value };
    default:
      return state;
  }
}

interface LobbyContextValue extends LobbyState {
  refreshStats: () => Promise<void>;
  fetchTicket: (farcasterId: string, gameId: number) => Promise<void>;
  purchaseTicket: (
    farcasterId: number,
    gameId: number,
    txHash?: string | null
  ) => Promise<Ticket | null>;
  validateReferral: (code: string, farcasterId: string) => Promise<boolean>;
  clearError: () => void;
}

const LobbyContext = createContext<LobbyContextValue | undefined>(undefined);

export function LobbyProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(lobbyReducer, initialState);

  const clearError = useCallback(() => {
    dispatch({ type: "SET_ERROR", error: null });
  }, []);

  const refreshStats = useCallback(async () => {
    dispatch({ type: "SET_STATS_LOADING", value: true });
    try {
      const res = await fetch("/api/lobby/stats");
      if (!res.ok) throw new Error("Failed to fetch lobby stats");
      const data = await res.json();
      dispatch({ type: "SET_STATS", stats: data });
    } catch (error) {
      console.error("refreshStats error:", error);
      dispatch({ type: "SET_ERROR", error: "Failed to load stats" });
      dispatch({ type: "SET_STATS", stats: null, loading: false });
    }
  }, []);

  const fetchTicket = useCallback(
    async (farcasterId: string, gameId: number) => {
      dispatch({ type: "SET_TICKET_LOADING", value: true });
      try {
        const res = await fetch("/api/tickets", {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            "x-farcaster-id": farcasterId,
          },
        });
        if (!res.ok) throw new Error("Failed to fetch tickets");
        const data: Ticket[] = await res.json();
        const found = Array.isArray(data)
          ? data.find((ticket) => ticket.gameId === gameId) ?? null
          : null;
        dispatch({
          type: "SET_TICKET",
          ticket: found,
          loading: false,
        });
      } catch (error) {
        console.error("fetchTicket error:", error);
        dispatch({ type: "SET_ERROR", error: "Failed to load ticket" });
        dispatch({ type: "SET_TICKET", ticket: null, loading: false });
      }
    },
    []
  );

  const purchaseTicket = useCallback(
    async (farcasterId: number, gameId: number, txHash?: string | null) => {
      dispatch({ type: "SET_TICKET_LOADING", value: true });
      try {
        const res = await fetch("/api/tickets/buy", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            farcasterId: farcasterId.toString(),
            gameId,
            txHash: txHash ?? null,
          }),
        });
        if (!res.ok) {
          const payload = await res.json().catch(() => ({}));
          throw new Error(payload.error || "Ticket purchase failed");
        }
        const ticket = (await res.json()) as Ticket;
        dispatch({ type: "SET_TICKET", ticket, loading: false });
        dispatch({ type: "SET_ERROR", error: null });
        await refreshStats();
        return ticket;
      } catch (error) {
        console.error("purchaseTicket error:", error);
        dispatch({
          type: "SET_ERROR",
          error:
            error instanceof Error ? error.message : "Ticket purchase failed",
        });
        dispatch({ type: "SET_TICKET_LOADING", value: false });
        return null;
      }
    },
    [refreshStats]
  );

  const validateReferral = useCallback(
    async (code: string, farcasterId: string) => {
      try {
        const res = await fetch("/api/referral/validate", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            code,
            fid: Number(farcasterId),
          }),
        });
        const data = await res.json();
        console.log("validateReferral response data:", data);
        if (!data.valid) {
          dispatch({ type: "SET_HAS_INVITE", value: false });
          dispatch({
            type: "SET_ERROR",
            error: data.error ?? "Invalid invite code",
          });
          return false;
        }

        dispatch({ type: "SET_HAS_INVITE", value: true });
        dispatch({
          type: "SET_INVITED_BY",
          invitedBy: {
            code: data.referral.code,
            inviterFarcasterId: data.referral.inviter?.farcasterId ?? null,
            acceptedAt: data.referral.acceptedAt ?? null,
          },
        });
        dispatch({ type: "SET_ERROR", error: null });
        return true;
      } catch (error) {
        console.error("validateReferral error", error);
        dispatch({
          type: "SET_ERROR",
          error:
            error instanceof Error ? error.message : "Failed to validate code",
        });
        return false;
      }
    },
    []
  );

  const value = useMemo<LobbyContextValue>(
    () => ({
      ...state,
      refreshStats,
      fetchTicket,
      purchaseTicket,
      validateReferral,
      clearError,
    }),
    [
      state,
      refreshStats,
      fetchTicket,
      purchaseTicket,
      validateReferral,
      clearError,
    ]
  );

  return (
    <LobbyContext.Provider value={value}>{children}</LobbyContext.Provider>
  );
}

export function useLobby() {
  const context = useContext(LobbyContext);
  if (!context) {
    throw new Error("useLobby must be used within a LobbyProvider");
  }
  return context;
}

--- File: ./src/state/leaderboard/LeaderboardContext.tsx ---
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useReducer,
} from "react";

export type TabKey = "current" | "allTime";

export interface Entry {
  rank: number;
  username: string;
  points: number;
  pfpUrl: string | null;
}

interface Slice {
  entries: Entry[];
  page: number;
  hasMore: boolean;
  isLoading: boolean;
  error?: string | null;
  scrollTop?: number;
}

interface LeaderboardState {
  activeTab: TabKey;
  slices: Record<TabKey, Slice>;
  me: Entry | null;
}

type LeaderboardAction =
  | { type: "SET_ACTIVE_TAB"; tab: TabKey }
  | { type: "SET_SLICE"; tab: TabKey; slice: Partial<Slice> }
  | { type: "MERGE_ENTRIES"; tab: TabKey; entries: Entry[]; append: boolean }
  | { type: "SET_ME"; entry: Entry | null }
  | { type: "RESET" };

const defaultSlice: Slice = {
  entries: [],
  page: 0,
  hasMore: true,
  isLoading: false,
  error: null,
  scrollTop: 0,
};

const initialState: LeaderboardState = {
  activeTab: "current",
  slices: {
    current: { ...defaultSlice },
    allTime: { ...defaultSlice },
  },
  me: null,
};

function mergeSlice(slice: Slice, patch: Partial<Slice>): Slice {
  return { ...slice, ...patch };
}

function leaderboardReducer(
  state: LeaderboardState,
  action: LeaderboardAction
): LeaderboardState {
  switch (action.type) {
    case "SET_ACTIVE_TAB":
      return { ...state, activeTab: action.tab };
    case "SET_SLICE":
      return {
        ...state,
        slices: {
          ...state.slices,
          [action.tab]: mergeSlice(state.slices[action.tab], action.slice),
        },
      };
    case "MERGE_ENTRIES": {
      const existing = state.slices[action.tab];
      const entries = action.append
        ? [...existing.entries, ...action.entries]
        : action.entries;
      return {
        ...state,
        slices: {
          ...state.slices,
          [action.tab]: {
            ...existing,
            entries,
            page: action.append ? existing.page + 1 : 1,
          },
        },
      };
    }
    case "SET_ME":
      return { ...state, me: action.entry };
    case "RESET":
      return initialState;
    default:
      return state;
  }
}

interface LeaderboardContextValue extends LeaderboardState {
  setActiveTab: (tab: TabKey) => void;
  rememberScroll: (tab: TabKey, scrollY: number) => void;
  fetchLeaderboard: (
    tab: TabKey,
    opts?: { replace?: boolean }
  ) => Promise<void>;
  reset: () => void;
}

const LeaderboardContext =
  createContext<LeaderboardContextValue | undefined>(undefined);

export function LeaderboardProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [state, dispatch] = useReducer(leaderboardReducer, initialState);

  const setActiveTab = useCallback((tab: TabKey) => {
    dispatch({ type: "SET_ACTIVE_TAB", tab });
  }, []);

  const rememberScroll = useCallback((tab: TabKey, scrollY: number) => {
    dispatch({
      type: "SET_SLICE",
      tab,
      slice: { scrollTop: scrollY },
    });
  }, []);

  const fetchLeaderboard = useCallback(
    async (tab: TabKey, opts?: { replace?: boolean }) => {
      const slice = state.slices[tab];
      if (!opts?.replace && (slice.isLoading || !slice.hasMore)) return;

      const targetPage = opts?.replace ? 0 : slice.page;

      dispatch({
        type: "SET_SLICE",
        tab,
        slice: {
          isLoading: true,
          error: null,
          ...(opts?.replace ? { entries: [], page: 0, hasMore: true } : {}),
        },
      });

      try {
        const res = await fetch(`/api/leaderboard?tab=${tab}&page=${targetPage}`);
        if (!res.ok) throw new Error(`Failed to fetch ${tab} leaderboard`);
        const data = await res.json();

        const newEntries: Entry[] = (data.users || []).map(
          (u: {
            rank: number;
            name: string;
            points: number;
            imageUrl: string | null;
          }) => ({
            rank: u.rank,
            username: u.name,
            points: u.points,
            pfpUrl: u.imageUrl || null,
          })
        );

        dispatch({
          type: "MERGE_ENTRIES",
          tab,
          entries: newEntries,
          append: !opts?.replace,
        });
        dispatch({
          type: "SET_SLICE",
          tab,
          slice: {
            hasMore: Boolean(data.hasMore),
            isLoading: false,
            error: null,
          },
        });

        if (data.me) {
          dispatch({
            type: "SET_ME",
            entry: {
              rank: data.me.rank,
              username: data.me.name,
              points: data.me.points,
              pfpUrl: data.me.imageUrl || null,
            },
          });
        }
      } catch (error) {
        console.error("fetchLeaderboard error:", error);
        dispatch({
          type: "SET_SLICE",
          tab,
          slice: {
            isLoading: false,
            error: error instanceof Error ? error.message : "Unknown error",
          },
        });
      }
    },
    [state.slices]
  );

  const reset = useCallback(() => {
    dispatch({ type: "RESET" });
  }, []);

  const value = useMemo<LeaderboardContextValue>(
    () => ({
      ...state,
      setActiveTab,
      rememberScroll,
      fetchLeaderboard,
      reset,
    }),
    [state, setActiveTab, rememberScroll, fetchLeaderboard, reset]
  );

  return (
    <LeaderboardContext.Provider value={value}>
      {children}
    </LeaderboardContext.Provider>
  );
}

export function useLeaderboard() {
  const context = useContext(LeaderboardContext);
  if (!context) {
    throw new Error("useLeaderboard must be used within a LeaderboardProvider");
  }
  return context;
}

--- File: ./src/state/game/GameContext.tsx ---
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
} from "react";
import SoundManager from "@/lib/SoundManager";
import { GameWithConfigAndQuestions } from "@/lib/server/game";
import { Prisma } from "@prisma/client";

export type ChatWithUser = Prisma.ChatGetPayload<{
  include: {
    user: {
      select: {
        name: true;
        imageUrl: true;
      };
    };
  };
}>;

export type GameStateType =
  | "WAITING"
  | "JOIN_GAME"
  | "FINAL_COUNTDOWN"
  // States for when the activeGame is live
  | "GAME_LIVE"
  | "GAME_LIVE_ANSWER_SELECTED"
  | "GAME_LIVE_ANSWER_SUBMITTED"
  | "GAME_LIVE_NEXT_QUESTION_COUNTDOWN"
  | "GAME_LIVE_ROUND_COUNTDOWN"
  | "CHAT"
  | "GAME_OVER";
interface GameState {
  status: "idle" | "loading" | "ready" | "error";
  error?: string | null;
  activeGame: GameWithConfigAndQuestions | null;
  questionIndex: number;
  round: number;
  state: GameStateType;
  selectedAnswer: string | null;
  messages: ChatWithUser[];
  roundBoundaries: number[];
}

type GameAction =
  | { type: "RESET" }
  | { type: "SET_LOADING" }
  | { type: "SET_ERROR"; error: string | null }
  | { type: "SET_GAME"; activeGame: GameWithConfigAndQuestions | null }
  | { type: "SET_STATE"; state: GameStateType }
  | { type: "SET_SELECTED"; answer: string | null }
  | { type: "SET_MESSAGES"; messages: ChatWithUser[] }
  | { type: "ADD_MESSAGE"; message: ChatWithUser }
  | { type: "ADVANCE_QUESTION" }
  | { type: "SET_ROUND_COUNTDOWN" }
  | { type: "SET_ROUND_ACTIVE" }
  | { type: "SET_ROUND"; round: number }
  | { type: "SET_QUESTION_INDEX"; index: number }
  | { type: "SET_ROUND_BOUNDARIES"; boundaries: number[] };

const initialState: GameState = {
  status: "idle",
  error: null,
  activeGame: null,
  questionIndex: 0,
  round: 1,
  state: "WAITING" as GameStateType,
  selectedAnswer: null,
  messages: [],
  roundBoundaries: [],
};

function computeRoundBoundaries(total: number): number[] {
  if (total <= 0) return [];
  const per = Math.ceil(total / 3);
  const r1End = Math.min(total - 1, per - 1);
  const r2End = Math.min(total - 1, r1End + per);
  const r3End = total - 1;
  return [r1End, r2End, r3End];
}

function gameReducer(state: GameState, action: GameAction): GameState {
  switch (action.type) {
    case "RESET":
      return { ...initialState };
    case "SET_LOADING":
      return { ...state, status: "loading", error: null };
    case "SET_ERROR":
      return {
        ...state,
        status: action.error ? "error" : state.status,
        error: action.error,
      };
    case "SET_GAME": {
      const activeGame = action.activeGame;
      const boundaries = computeRoundBoundaries(
        activeGame?.questions?.length ?? 0
      );
      return {
        ...state,
        status: activeGame ? "ready" : "idle",
        activeGame,
        questionIndex: 0,
        round: 1,
        state: "WAITING",
        selectedAnswer: null,
        roundBoundaries: boundaries,
        error: null,
      };
    }
    case "SET_STATE":
      return { ...state, state: action.state };
    case "SET_SELECTED":
      return { ...state, selectedAnswer: action.answer };
    case "SET_MESSAGES":
      return { ...state, messages: action.messages };
    case "ADD_MESSAGE":
      return { ...state, messages: [...state.messages, action.message] };
    case "SET_ROUND_BOUNDARIES":
      return { ...state, roundBoundaries: action.boundaries };
    case "SET_ROUND":
      return { ...state, round: action.round };
    case "SET_QUESTION_INDEX":
      return { ...state, questionIndex: action.index };
    case "SET_ROUND_COUNTDOWN":
      return { ...state, selectedAnswer: null };
    case "SET_ROUND_ACTIVE":
      return { ...state, selectedAnswer: null };
    case "ADVANCE_QUESTION": {
      const total = state.activeGame?.questions?.length ?? 0;
      const next = state.questionIndex + 1;
      const capped = Math.min(next, Math.max(total - 1, 0));
      return {
        ...state,
        questionIndex: next >= total ? state.questionIndex : capped,
        selectedAnswer: null,
      };
    }
    default:
      return state;
  }
}

interface GameContextValue extends GameState {
  loadActiveGame: () => Promise<void>;
  submitAnswer: (args: {
    farcasterId: number;
    selected: string;
    timeTaken: number;
  }) => Promise<void>;
  selectAnswer: (answer: string) => void;
  advanceToNextQuestion: () => void;
  setStateType: (state: GameStateType) => void;
  resetGame: () => void;
  fetchMessages: () => Promise<void>;
  setMessages: (messages: ChatWithUser[]) => void;
  sendMessage: (
    text: string,
    user: { fid: number; username: string; pfpUrl: string }
  ) => Promise<void>;
  gameOver: () => void;
}

const GameContext = createContext<GameContextValue | undefined>(undefined);

export function GameStateProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(gameReducer, initialState);
  /**
   * A ref storing the timeout ID for programmatically advancing
   * to the next question after a delay (e.g., after answer submission).
   *
   * This allows us to ensure that if the component unmounts or
   * the effect is cleaned up, we clear any pending automatic
   * "advance to next question" actions, preventing memory leaks
   * or state changes on unmounted components.
   */
  const advanceTimerRef = useRef<NodeJS.Timeout | null>(null);

  /**
   * Clears any scheduled "advance to next question" timer.
   * Used to prevent unintended advancement when the current round changes,
   * the component unmounts, or there is a navigation event.
   */
  const clearAdvanceTimer = useCallback(() => {
    if (advanceTimerRef.current) {
      clearTimeout(advanceTimerRef.current);
      advanceTimerRef.current = null;
    }
  }, []);

  // Ensure that when this provider unmounts (or re-renders with new clearAdvanceTimer),
  // any automatic "advance to next question" timeout is cleared to avoid side effects.
  useEffect(() => () => clearAdvanceTimer(), [clearAdvanceTimer]);

  const loadActiveGame = useCallback(async () => {
    dispatch({ type: "SET_LOADING" });
    try {
      const res = await fetch(`/api/game/active`);
      if (!res.ok) throw new Error("Failed to load active activeGame");
      const data = (await res.json()) as GameWithConfigAndQuestions;
      dispatch({ type: "SET_GAME", activeGame: data });
      dispatch({
        type: "SET_ROUND_BOUNDARIES",
        boundaries: computeRoundBoundaries(data?.questions?.length ?? 0),
      });
    } catch (error) {
      console.error("loadActiveGame error", error);
      dispatch({
        type: "SET_ERROR",
        error:
          error instanceof Error ? error.message : "Failed to load activeGame",
      });
      dispatch({ type: "SET_GAME", activeGame: null });
      throw error;
    }
  }, []);

  const submitAnswer = useCallback(
    async ({
      farcasterId,
      selected,
      timeTaken,
    }: {
      farcasterId: number;
      selected: string;
      timeTaken: number;
    }) => {
      const activeGame = state.activeGame;
      if (!activeGame?.id) return null;
      const question = activeGame.questions?.[state.questionIndex];
      if (!question) return null;

      try {
        const res = await fetch(`/api/game/answer`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            farcasterId,
            gameId: activeGame.id,
            questionId: question.id,
            selected,
            timeTaken,
          }),
        });
        if (!res.ok) throw new Error("Failed to submit answer");

        return await res.json();
      } catch (error) {
        console.error("submitAnswer error", error);
        dispatch({
          type: "SET_ERROR",
          error:
            error instanceof Error ? error.message : "Failed to submit answer",
        });
        return null;
      }
    },
    [state.activeGame, state.questionIndex]
  );

  const determineRoundForIndex = useCallback(
    (index: number) => {
      const boundaries = state.roundBoundaries;
      if (!boundaries.length) return 1;
      for (let i = 0; i < boundaries.length; i += 1) {
        if (index <= boundaries[i]) {
          return i + 1;
        }
      }
      return boundaries.length;
    },
    [state.roundBoundaries]
  );

  const gameOver = useCallback(() => {
    dispatch({ type: "SET_STATE", state: "GAME_OVER" });
    if (state.activeGame?.config?.soundEnabled) {
      SoundManager.play("gameOver");
    }
    clearAdvanceTimer();
  }, [state.activeGame?.config?.soundEnabled, clearAdvanceTimer]);

  const advanceToNextQuestion = useCallback(() => {
    const total = state.activeGame?.questions?.length ?? 0;
    if (!total) return;
    const nextIndex = state.questionIndex + 1;
    if (nextIndex >= total) {
      gameOver();
      return;
    }

    const previousRound = determineRoundForIndex(state.questionIndex);
    const nextRound = determineRoundForIndex(nextIndex);

    dispatch({ type: "SET_QUESTION_INDEX", index: nextIndex });
    dispatch({ type: "SET_SELECTED", answer: null });
    dispatch({ type: "SET_ROUND", round: nextRound });
    if (state.activeGame?.config?.soundEnabled) {
      SoundManager.play("nextQuestion");
    }
    if (nextRound > previousRound) {
      dispatch({ type: "SET_ROUND_COUNTDOWN" });
    } else {
      dispatch({ type: "SET_ROUND_ACTIVE" });
    }
  }, [
    determineRoundForIndex,
    gameOver,
    state.activeGame?.config?.soundEnabled,
    state.activeGame?.questions?.length,
    state.questionIndex,
  ]);

  const selectAnswer = useCallback(
    (answer: string) => {
      dispatch({ type: "SET_STATE", state: "GAME_LIVE_ANSWER_SELECTED" });
      dispatch({ type: "SET_SELECTED", answer });
      clearAdvanceTimer();

      if (state.activeGame?.config?.soundEnabled) {
        SoundManager.play("click");
      }
    },
    [state.activeGame?.config?.soundEnabled, clearAdvanceTimer]
  );

  const setStateType = useCallback((state: GameStateType) => {
    dispatch({ type: "SET_STATE", state });
  }, []);

  const resetGame = useCallback(() => {
    clearAdvanceTimer();
    SoundManager.stopAll();
    dispatch({ type: "RESET" });
  }, [clearAdvanceTimer]);

  const fetchMessages = useCallback(async () => {
    const activeGame = state.activeGame;
    if (!activeGame?.id) return;
    try {
      const res = await fetch(`/api/chat?gameId=${activeGame.id}`);
      if (!res.ok) throw new Error("Failed to fetch chat");
      const data: ChatWithUser[] = await res.json();
      dispatch({ type: "SET_MESSAGES", messages: data });
    } catch (error) {
      console.error("fetchMessages error:", error);
      dispatch({ type: "SET_MESSAGES", messages: [] });
    }
  }, [state.activeGame]);

  const setMessages = useCallback((messages: ChatWithUser[]) => {
    dispatch({ type: "SET_MESSAGES", messages });
  }, []);

  const sendMessage = useCallback(
    async (
      text: string,
      user: { fid: number; username: string; pfpUrl: string }
    ) => {
      const activeGame = state.activeGame;
      if (!activeGame?.id) return;

      const optimistic: ChatWithUser = {
        id: Date.now(),
        gameId: activeGame.id,
        userId: 0,
        user: {
          name: user.username || "You",
          imageUrl: user.pfpUrl || null,
        },
        message: text,
        createdAt: new Date(),
      };

      dispatch({ type: "ADD_MESSAGE", message: optimistic });

      if (!user.fid) return;
      try {
        await fetch(`/api/chat`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-farcaster-id": String(user.fid),
          },
          body: JSON.stringify({
            gameId: activeGame.id,
            message: text,
          }),
        });
      } catch (error) {
        console.error("sendMessage error:", error);
      }
    },
    [state.activeGame]
  );

  const value = useMemo<GameContextValue>(
    () => ({
      ...state,
      loadActiveGame,
      submitAnswer,
      selectAnswer,
      advanceToNextQuestion,
      setStateType,
      resetGame,
      fetchMessages,
      setMessages,
      sendMessage,
      gameOver,
    }),
    [
      state,
      loadActiveGame,
      submitAnswer,
      selectAnswer,
      advanceToNextQuestion,
      setStateType,
      resetGame,
      fetchMessages,
      setMessages,
      sendMessage,
      gameOver,
    ]
  );

  return <GameContext.Provider value={value}>{children}</GameContext.Provider>;
}

export function useGame() {
  const context = useContext(GameContext);
  if (!context) {
    throw new Error("useGame must be used within a GameStateProvider");
  }
  return context;
}

--- File: ./src/state/game/constants.ts ---
export const NEXT_QUESTION_DELAY_SECONDS = 3;

--- File: ./src/state/AppStateProvider.tsx ---
"use client";

import { GameStateProvider } from "./game/GameContext";
import { LobbyProvider } from "./lobby/LobbyContext";
import { LeaderboardProvider } from "./leaderboard/LeaderboardContext";
import { ProfileProvider } from "./profile/ProfileContext";

export function AppStateProvider({ children }: { children: React.ReactNode }) {
  return (
    <GameStateProvider>
      <LobbyProvider>
        <ProfileProvider>
          <LeaderboardProvider>{children}</LeaderboardProvider>
        </ProfileProvider>
      </LobbyProvider>
    </GameStateProvider>
  );
}

--- File: ./src/state/profile/ProfileContext.tsx ---
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useReducer,
} from "react";

export interface GameHistory {
  id: number | string;
  name: string;
  score: number;
  winnings: number;
  winningsColor?: "green" | "gray";
}

export interface AllTimeStats {
  totalGames: number;
  wins: number;
  winRate: string;
  totalWon: string;
  highestScore: number;
  averageScore: number;
  currentStreak: number;
  bestRank: number | string;
}

interface ProfileState {
  id: number | null;
  username: string;
  wallet: string;
  imageUrl: string;
  streak: number;
  stats: { games: number; wins: number; winnings: number };
  gameHistory: GameHistory[];
  allTimeStats: AllTimeStats;
  loading: boolean;
  error: string | null;
  currentFarcasterId: string | null;
  hasLoaded: boolean;
}

type ProfileAction =
  | { type: "SET_LOADING"; value: boolean }
  | { type: "SET_ERROR"; error: string | null }
  | { type: "SET_PROFILE"; payload: Partial<ProfileState> }
  | { type: "SET_CURRENT_FID"; fid: string | null }
  | { type: "RESET" };

const initialState: ProfileState = {
  id: null,
  username: "",
  wallet: "",
  imageUrl: "",
  streak: 0,
  stats: { games: 0, wins: 0, winnings: 0 },
  gameHistory: [],
  allTimeStats: {
    totalGames: 0,
    wins: 0,
    winRate: "0%",
    totalWon: "$0",
    highestScore: 0,
    averageScore: 0,
    currentStreak: 0,
    bestRank: "-",
  },
  loading: false,
  error: null,
  currentFarcasterId: null,
  hasLoaded: false,
};

function profileReducer(
  state: ProfileState,
  action: ProfileAction
): ProfileState {
  switch (action.type) {
    case "SET_LOADING":
      return { ...state, loading: action.value };
    case "SET_ERROR":
      return { ...state, error: action.error };
    case "SET_PROFILE":
      return { ...state, ...action.payload };
    case "SET_CURRENT_FID":
      return { ...state, currentFarcasterId: action.fid };
    case "RESET":
      return initialState;
    default:
      return state;
  }
}

interface ProfileContextValue extends ProfileState {
  fetchProfile: (
    farcasterId: string,
    opts?: { force?: boolean }
  ) => Promise<void>;
  updateProfile: (
    farcasterId: string,
    payload: Partial<{ name: string; wallet: string; imageUrl: string }>
  ) => Promise<void>;
  resetProfile: () => void;
}

const ProfileContext =
  createContext<ProfileContextValue | undefined>(undefined);

export function ProfileProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(profileReducer, initialState);

  const fetchProfile = useCallback(
    async (farcasterId: string, opts?: { force?: boolean }) => {
      if (!farcasterId) return;
      if (
        !opts?.force &&
        state.currentFarcasterId === farcasterId &&
        state.hasLoaded &&
        !state.loading
      ) {
        return;
      }

      dispatch({ type: "SET_LOADING", value: true });
      dispatch({ type: "SET_ERROR", error: null });
      dispatch({ type: "SET_CURRENT_FID", fid: farcasterId });

      try {
        const [profileRes, statsRes, historyRes] = await Promise.all([
          fetch("/api/profile", {
            headers: { "x-farcaster-id": farcasterId },
          }),
          fetch("/api/profile/stats", {
            headers: { "x-farcaster-id": farcasterId },
          }),
          fetch("/api/profile/history", {
            headers: { "x-farcaster-id": farcasterId },
          }),
        ]);

        if (!profileRes.ok) throw new Error("Profile fetch failed");
        if (!statsRes.ok) throw new Error("Stats fetch failed");
        if (!historyRes.ok) throw new Error("History fetch failed");

        const profile = await profileRes.json();
        const stats = await statsRes.json();
        const history = (await historyRes.json()) as GameHistory[];

        const winRateStr = `${Math.round(stats.winRate || 0)}%`;
        const totalWonStr = `$${Number(stats.totalWon || 0).toFixed(2)}`;

        dispatch({
          type: "SET_PROFILE",
          payload: {
            id: profile.id,
            username: profile.name || "Anonymous",
            wallet: profile.wallet || "",
            imageUrl: profile.imageUrl || "/images/avatars/a.png",
            streak: stats.currentStreak || 0,
            stats: {
              games: stats.totalGames || 0,
              wins: stats.wins || 0,
              winnings: stats.totalWon || 0,
            },
            allTimeStats: {
              totalGames: stats.totalGames,
              wins: stats.wins,
              winRate: winRateStr,
              totalWon: totalWonStr,
              highestScore: stats.highestScore,
              averageScore: stats.avgScore,
              currentStreak: stats.currentStreak,
              bestRank: stats.bestRank,
            },
            gameHistory: history,
            loading: false,
            hasLoaded: true,
          },
        });
      } catch (error) {
        console.error("fetchProfile error:", error);
        dispatch({
          type: "SET_ERROR",
          error:
            error instanceof Error ? error.message : "Failed to load profile",
        });
        dispatch({ type: "SET_LOADING", value: false });
        dispatch({ type: "SET_PROFILE", payload: { hasLoaded: false } });
      }
    },
    [state.currentFarcasterId, state.hasLoaded, state.loading]
  );

  const updateProfile = useCallback(
    async (
      farcasterId: string,
      payload: Partial<{ name: string; wallet: string; imageUrl: string }>
    ) => {
      if (!farcasterId) return;
      try {
        const res = await fetch("/api/profile", {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            "x-farcaster-id": farcasterId,
          },
          body: JSON.stringify(payload),
        });
        if (!res.ok) throw new Error("Failed to update profile");
        const updated = await res.json();
        dispatch({
          type: "SET_PROFILE",
          payload: {
            username: updated.name ?? state.username,
            wallet: updated.wallet ?? state.wallet,
            imageUrl: updated.imageUrl ?? state.imageUrl,
          },
        });
      } catch (error) {
        console.error("updateProfile error:", error);
        dispatch({
          type: "SET_ERROR",
          error:
            error instanceof Error ? error.message : "Failed to update profile",
        });
      }
    },
    [state.imageUrl, state.username, state.wallet]
  );

  const resetProfile = useCallback(() => {
    dispatch({ type: "RESET" });
  }, []);

  const value = useMemo<ProfileContextValue>(
    () => ({
      ...state,
      fetchProfile,
      updateProfile,
      resetProfile,
    }),
    [state, fetchProfile, updateProfile, resetProfile]
  );

  return (
    <ProfileContext.Provider value={value}>{children}</ProfileContext.Provider>
  );
}

export function useProfile() {
  const context = useContext(ProfileContext);
  if (!context) {
    throw new Error("useProfile must be used within a ProfileProvider");
  }
  return context;
}

--- File: ./src/state/index.ts ---
export { AppStateProvider } from "./AppStateProvider";
export { useGame } from "./game/GameContext";
export { useLobby } from "./lobby/LobbyContext";
export { useLeaderboard } from "./leaderboard/LeaderboardContext";
export type {
  TabKey as LeaderboardTabKey,
  Entry as LeaderboardEntry,
} from "./leaderboard/LeaderboardContext";
export { useProfile } from "./profile/ProfileContext";
export type { GameHistory, AllTimeStats } from "./profile/ProfileContext";

--- File: ./src/components/ui/ChatBox.tsx ---
"use client";

import { useState, useEffect, useRef } from "react";

interface Message {
  user: string;
  text: string;
  time: string;
}

export default function ChatBox() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    ref.current?.scrollTo(0, ref.current.scrollHeight);
  }, [messages]);

  const sendMessage = async () => {
    if (!input.trim()) return;
    const msg: Message = {
      user: "You",
      text: input,
      time: new Date().toLocaleTimeString(),
    };
    setMessages((prev) => [...prev, msg]);
    setInput("");
    await fetch("/api/chat/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: msg.text }),
    });
  };

  return (
    <div className="flex flex-col h-64 w-full max-w-md bg-zinc-900 rounded-xl overflow-hidden">
      <div ref={ref} className="flex-1 overflow-y-auto p-3 space-y-2">
        {messages.map((m, i) => (
          <div key={i} className="text-sm text-gray-300">
            <span className="font-semibold text-purple-400">{m.user}:</span>{" "}
            {m.text}
          </div>
        ))}
      </div>
      <div className="flex p-2 border-t border-zinc-800">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          className="flex-1 bg-transparent outline-none px-2"
          placeholder="Type a message..."
        />
        <button onClick={sendMessage} className="text-purple-500 font-semibold">
          Send
        </button>
      </div>
    </div>
  );
}

--- File: ./src/components/ui/SplashScreen.tsx ---
"use client";

import Image from "next/image";

const crewImages = [
  "/images/splash/crew-1.png",
  "/images/splash/crew-2.png",
  "/images/splash/crew-3.png",
  "/images/splash/crew-4.png",
  "/images/splash/crew-5.png",
  "/images/splash/crew-6.png",
  "/images/splash/crew-7.png",
  "/images/splash/crew-8.png",
];

export function SplashScreen() {
  return (
    <div className="fixed inset-0 z-999 flex items-center justify-center bg-linear-to-b from-[#1E1E1E] to-black text-white">
      <div className="absolute inset-0 bg-[url('/images/noise.png')] opacity-10" />
      <div className="relative flex h-full w-full max-w-sm flex-col items-center justify-center px-6">
        <div className="flex flex-col items-center gap-3 text-center">
          <div className="relative h-24 w-24 drop-shadow-[0_20px_40px_rgba(0,0,0,0.45)]">
            <Image src="/logo.png" alt="Waffles Logo" fill priority />
          </div>
          <p className="font-body text-4xl tracking-tight">WAFFLES</p>
        </div>

        <div className="pointer-events-none absolute inset-x-0 bottom-0 flex h-32 items-end justify-center gap-2 px-3 pb-4">
          {crewImages.map((src, index) => (
            <Image
              key={src}
              src={src}
              alt=""
              width={90}
              height={90}
              className={`h-[clamp(70px,10vw,90px)] w-auto opacity-95 drop-shadow-[0_12px_25px_rgba(0,0,0,0.45)] ${
                index % 2 === 0 ? "-rotate-2" : "rotate-2"
              }`}
              priority
            />
          ))}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/components/ui/Toaster.tsx ---
"use client";
import { Toaster, toast } from "sonner";

export const notify = {
  success: (msg: string) => toast.success(msg),
  error: (msg: string) => toast.error(msg),
  info: (msg: string) => toast(msg),
};

export default function GlobalToaster() {
  return <Toaster position="bottom-center" theme="dark" />;
}

--- File: ./src/components/ui/sonner.tsx ---
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

--- File: ./src/components/buttons/FancyBorderButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

interface FancyBorderButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  fullWidth?: boolean;
  ref?: React.RefObject<HTMLButtonElement>;
}

export function FancyBorderButton({
  ref,
  children,
  fullWidth = true,
  className,
  ...props
}: FancyBorderButtonProps) {
  return (
    <button
      ref={ref}
      className={cn(
        "relative flex items-center justify-center h-[54px] px-6 bg-white text-[#191919] font-[var(--font-pixel)] text-sm uppercase tracking-wider max-w-sm mx-auto",
        "rounded-[12px] border-[5px] border-t-0 border-l-0 border-[#00CFF2]",
        fullWidth && "w-full",
        "transition-all active:translate-y-[1px]",
        "disabled:cursor-not-allowed disabled:opacity-50 ",
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
}

--- File: ./src/components/buttons/PixelButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils"; // Assuming a utility like tailwind-merge

interface PixelButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  asChild?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
  borderWidth?: number; // Border width in pixels
}

const PixelButton = React.forwardRef<HTMLButtonElement, PixelButtonProps>(
  (
    {
      className,
      children,
      backgroundColor = "#000000",
      borderColor = "#FFC931",
      textColor = "#FFD972",
      borderWidth = 4, // Default to a 4px border
      ...props
    },
    ref
  ) => {
    const containerStyle = {
      backgroundColor: borderColor,
      padding: `${borderWidth}px`,
    };

    const buttonStyle = {
      backgroundColor: backgroundColor,
      color: textColor,
    };

    return (
      <div
        style={containerStyle}
        className={cn(
          // This is now a full-width block by default to fill its container
          "pixel-corners w-full transition-transform duration-100 ease-in-out",
          // Apply hover/active states to the container to move the whole unit
          "hover:-translate-y-0.5 active:translate-y-0"
        )}
      >
        <button
          style={buttonStyle}
          className={cn(
            "pixel-corners flex h-full w-full items-center justify-center px-6 py-3 font-mono text-sm uppercase tracking-wider",
            "disabled:cursor-not-allowed disabled:opacity-60",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </button>
      </div>
    );
  }
);

PixelButton.displayName = "PixelButton";

export { PixelButton };

--- File: ./src/components/DeviceGate.tsx ---
"use client";

import { useIsMobile } from "@/hooks/useIsMobile";
import Image from "next/image";
import { useEffect } from "react";

type Props = {
  children: React.ReactNode;
  /** show a tiny bypass for QA in non-prod */
  continueAnyway?: boolean;
  /** optional store/deeplink helpers */
  appLinks?: {
    ios?: string;
    android?: string;
    webFallback?: string;
  };
  /** optional QR image path in /public (or remote) */
  qrSrc?: string;
};

export default function DeviceGate({
  children,
  continueAnyway = false,
  appLinks,
  qrSrc = "/qr-mobile.png",
}: Props) {
  const isMobile = useIsMobile();

  // lock background scroll when blocked
  useEffect(() => {
    if (!isMobile) {
      const prev = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      return () => {
        document.body.style.overflow = prev;
      };
    }
  }, [isMobile]);

  if (isMobile) return <>{children}</>;

  return (
    <div className="relative min-h-dvh w-full app-background text-foreground noise">
      {/* subtle radial glow */}
      <div className="pointer-events-none absolute inset-0 -z-10 bg-[radial-gradient(ellipse_at_top,rgba(255,255,255,0.06),transparent_60%)]" />

      <div className="mx-auto flex min-h-dvh max-w-screen-md items-center px-4 sm:px-6">
        <section
          role="dialog"
          aria-labelledby="dg-title"
          aria-describedby="dg-desc"
          className="w-full rounded-[var(--radius-md)] border border-[var(--surface-stroke)] bg-[var(--surface-card)]/95 backdrop-blur p-6 sm:p-8 animate-up"
        >
          <header className="flex items-center justify-between gap-4">
            <h1
              id="dg-title"
              className="text-xl sm:text-2xl font-semibold tracking-tight"
            >
              Open on your phone
            </h1>
            {/* badge */}
            <span className="hidden sm:inline-flex items-center rounded-full bg-[var(--white-a10)] px-3 py-1 text-xs text-[color:var(--text-muted)]">
              Mobile only
            </span>
          </header>

          <p
            id="dg-desc"
            className="mt-3 text-sm sm:text-base leading-6 text-[color:var(--text-muted)]"
          >
            This experience is optimized for mobile. Please scan the code or
            open the link on your phone.
          </p>

          <div className="mt-6 grid gap-4 sm:grid-cols-2">
            {/* QR / preview */}
            <div className="flex items-center justify-center rounded-[var(--radius-md)] border border-[var(--surface-stroke)] bg-black/40 p-4">
              {/* Replace with your QR; or remove block */}
              <Image
                src={qrSrc}
                alt="Open on mobile"
                width={160}
                height={160}
                className="rounded-md"
              />
            </div>

            <div className="flex flex-col justify-center gap-3">
              {appLinks?.ios && (
                <a
                  href={appLinks.ios}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Download on the App Store
                </a>
              )}
              {appLinks?.android && (
                <a
                  href={appLinks.android}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Get it on Google Play
                </a>
              )}
              {appLinks?.webFallback && (
                <a
                  href={appLinks.webFallback}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Send link to my phone
                </a>
              )}

              {continueAnyway && (
                <button
                  onClick={() => {
                    sessionStorage.setItem("forceDesktop", "1");
                    location.reload();
                  }}
                  className="mt-1 self-start text-xs text-[color:var(--text-muted)] underline underline-offset-4 hover:text-foreground"
                >
                  Continue on desktop (not supported)
                </button>
              )}
            </div>
          </div>

          <footer className="mt-6 text-center text-xs text-[color:var(--text-muted)]">
            If you’re already on mobile and still see this, disable desktop mode
            or try rotating your device.
          </footer>
        </section>
      </div>
    </div>
  );
}

--- File: ./src/components/BottomNav.tsx ---
"use client";

import { usePathname, useRouter } from "next/navigation";
import { cn } from "@/lib/utils";
import { HomeIcon, LeaderboardIcon, ProfileIcon } from "./icons";

const navItems = [
  { icon: HomeIcon, label: "Lobby", href: "/lobby" },
  { icon: LeaderboardIcon, label: "Leaderboard", href: "/leaderboard" },
  { icon: ProfileIcon, label: "Profile", href: "/profile" },
];

export function BottomNav() {
  const pathname = usePathname();
  const router = useRouter();

  return (
    <nav className="fixed bottom-0 left-0 right-0 app-background noise border-t-2 border-border z-50">
      <div className="flex items-center justify-around max-w-2xl mx-auto">
        {navItems.map((item) => {
          const Icon = item.icon;
          // Active if path starts with href as a segment (e.g. '/lobby' matches '/lobby/buy')
          const isActive =
            pathname === item.href || pathname.startsWith(item.href + "/");

          return (
            <button
              key={item.href}
              onClick={() => router.push(item.href)}
              className={cn(
                "flex flex-col items-center gap-1 py-3 px-6 transition-colors flex-1 ",
                isActive
                  ? "text-secondary-foreground"
                  : "text-muted-foreground hover:text-foreground"
              )}
            >
              <Icon
                className={cn(
                  "h-5 w-5 text-muted-foreground",
                  isActive && "animate-pulse-glow text-primary"
                )}
              />
              <span className="text-xs font-medium font-display">
                {item.label}
              </span>
            </button>
          );
        })}
      </div>
    </nav>
  );
}

--- File: ./src/components/providers/index.tsx ---
"use client";

import { useEffect } from "react";
import { MinikitProvider } from "./MinikitProvider";
import GlobalToaster from "../ui/Toaster";
import { OnboardingGate } from "../onboarding/onboarding-gate";
import { useGame, useLobby } from "@/state";
import { useSyncUser } from "@/hooks/useSyncUser";
import { FlowGuard } from "./FlowGuard";

function AppBootstrap({ children }: { children: React.ReactNode }) {
  const { loadActiveGame } = useGame();
  const { refreshStats } = useLobby();
  useSyncUser();

  useEffect(() => {
    loadActiveGame().catch((error) =>
      console.error("Failed to preload game", error)
    );
    refreshStats().catch((error) =>
      console.error("Failed to preload lobby stats", error)
    );
  }, [loadActiveGame, refreshStats]);

  return <>{children}</>;
}

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <MinikitProvider>
      <OnboardingGate>
        <AppBootstrap>
          <FlowGuard>
            {children}
            <GlobalToaster />
          </FlowGuard>
        </AppBootstrap>
      </OnboardingGate>
    </MinikitProvider>
  );
}

--- File: ./src/components/providers/FlowGuard.tsx ---
"use client";

import { useCallback, useEffect, useState } from "react";
import { usePathname, useRouter } from "next/navigation";
import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useGame, useLobby } from "@/state";
import { useMiniUser } from "@/hooks/useMiniUser";
import { SplashScreen } from "../ui/SplashScreen";

const ALLOW_LIST_WITHOUT_INVITE = new Set(["/lobby/invite-code"]);

export function FlowGuard({ children }: { children: React.ReactNode }) {
  const router = useRouter();
  const pathname = usePathname();
  const { isFrameReady } = useMiniKit();
  const [frameAcknowledged, setFrameAcknowledged] = useState(false);
  const { fid } = useMiniUser();
  const { activeGame } = useGame();
  const { inviteStatusLoaded, hasValidInvite, ticket } = useLobby();

  useEffect(() => {
    if (!isFrameReady) {
      const timer = setTimeout(() => setFrameAcknowledged(true), 3000); // 3 seconds
      return () => clearTimeout(timer);
    }
    // setFrameAcknowledged(true);
  }, [isFrameReady]);

  const redirect = useCallback(
    (target: string) => {
      if (pathname === target) return;
      router.replace(target);
    },
    [pathname, router]
  );

  useEffect(() => {
    if (!fid || !inviteStatusLoaded || !frameAcknowledged) return;

    if (!hasValidInvite) {
      if (!ALLOW_LIST_WITHOUT_INVITE.has(pathname)) {
        redirect("/lobby/invite-code");
      }
      return;
    }

    if (pathname === "/lobby/invite-code") {
      redirect("/lobby/buy");
      return;
    }
    // if active game and no ticket, redirect to buy else redirect to game waitlist
    if (!ticket) {
      if (pathname === "/game") {
        redirect("/lobby/buy");
        return;
      }
      if (pathname === "/") {
        redirect("/lobby/buy");
        return;
      }
    } else {
      if (
        pathname === "/" ||
        pathname === "/lobby" ||
        pathname === "/lobby/buy"
      ) {
        redirect("/game");
        return;
      }
    }
  }, [
    fid,
    inviteStatusLoaded,
    hasValidInvite,
    ticket,
    pathname,
    redirect,
    frameAcknowledged,
    activeGame,
  ]);

  if (!frameAcknowledged) {
    return <SplashScreen />;
  }

  const blockingInvite =
    inviteStatusLoaded &&
    !hasValidInvite &&
    !ALLOW_LIST_WITHOUT_INVITE.has(pathname);
  const blockingTicket = hasValidInvite && !ticket && pathname === "/game";

  if (blockingInvite || blockingTicket) {
    return null;
  }

  return <>{children}</>;
}

--- File: ./src/components/providers/MinikitProvider.tsx ---
"use client";

import { OnchainKitProvider } from "@coinbase/onchainkit";
import { baseSepolia } from "wagmi/chains";
import { env } from "@/lib/env";
import { useMiniKit } from "@coinbase/onchainkit/minikit";

import { useEffect } from "react";

interface Props {
  children: React.ReactNode;
}

export function MinikitProvider({ children }: Props) {
  return (
    <OnchainKitProvider
      apiKey={env.nextPublicOnchainkitApiKey}
      chain={baseSepolia}
      config={{
        appearance: {
          mode: "auto",
        },
        wallet: {
          display: "modal",
          preference: "all",
        },
      }}
      miniKit={{
        enabled: true,
        autoConnect: true,
        notificationProxyUrl: undefined,
      }}
    >
      <IsMiniAppReady>{children}</IsMiniAppReady>
    </OnchainKitProvider>
  );
}

function IsMiniAppReady({ children }: { children: React.ReactNode }) {
  const { isFrameReady, setFrameReady } = useMiniKit();
  // Initialize the  miniapp
  useEffect(() => {
    if (!isFrameReady) {
      setFrameReady();
    }
  }, [setFrameReady, isFrameReady]);

  return <>{children}</>;
}

--- File: ./src/components/logo/Logo.tsx ---
import React from "react";

import Image from "next/image";

export default function Logo(props: React.ComponentProps<"div">) {
  return (
    <div {...props}>
      <Image src="/logo.png" alt="Logo" width={40} height={40} priority />
    </div>
  );
}

--- File: ./src/components/logo/LogoIcon.tsx ---
import React from "react";

// Use next/image for optimal .png rendering in Next.js apps.
import Image from "next/image";

// You must provide the image file at the given path in your project.
export default function LogoIcon(props: React.ComponentProps<"div">) {
  return (
    <div {...props}>
      <Image src="/logo-icon.png" alt="Logo" width={100} height={40} priority />
    </div>
  );
}

--- File: ./src/components/icons.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";
import * as React from "react";

export function HomeIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.58 2H10.58V4H8.58002V6H6.58002V8H4.58002V10H2.58002V12H4.58002V22H11.58V16H13.58V22H20.58V12H22.58V10H20.58V8H18.58V6H16.58V4H14.58V2ZM14.58 4V6H16.58V8H18.58V10H20.58V12H18.58V20H15.58V14H9.58002V20H6.58002V12H4.58002V10H6.58002V8H8.58002V6H10.58V4H14.58Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function LeaderboardIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M12.5 1H14.5V9H22.5V13H20.5V11H12.5V5H10.5V3H12.5V1ZM8.5 7V5H10.5V7H8.5ZM6.5 9V7H8.5V9H6.5ZM4.5 11V9H6.5V11H4.5ZM14.5 19V21H12.5V23H10.5V15H2.5V11H4.5V13H12.5V19H14.5ZM16.5 17V19H14.5V17H16.5ZM18.5 15V17H16.5V15H18.5ZM18.5 15H20.5V13H18.5V15Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function ProfileIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.41998 3H21.42V21H3.41998V3ZM19.42 19V5H5.41998V19H19.42ZM14.42 7H10.42V11H14.42V7ZM15.42 13H9.41998V15H7.41998V17H9.41998V15H15.42V17H17.42V15H15.42V13Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function WalletIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M2 6.19998H13.4C13.5591 6.19998 13.7117 6.26319 13.8243 6.37571C13.9368 6.48823 14 6.64085 14 6.79998V12.8C14 12.9591 13.9368 13.1117 13.8243 13.2242C13.7117 13.3368 13.5591 13.4 13.4 13.4H2.6C2.44087 13.4 2.28826 13.3368 2.17574 13.2242C2.06321 13.1117 2 12.9591 2 12.8V6.19998ZM2.6 2.59998H11.6V4.99998H2V3.19998C2 3.04085 2.06321 2.88823 2.17574 2.77571C2.28826 2.66319 2.44087 2.59998 2.6 2.59998ZM9.8 9.19998V10.4H11.6V9.19998H9.8Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function InviteIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={21}
      height={21}
      viewBox="0 0 21 21"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M15.5 2.16663H10.5V3.83329H8.83331V8.83329H10.5V3.83329H15.5V2.16663ZM15.5 8.83329H10.5V10.5H15.5V8.83329ZM15.5 3.83329H17.1666V8.83329H15.5V3.83329ZM6.33331 13.8333H7.99998V12.1666H18V13.8333H7.99998V17.1666H18V13.8333H19.6666V18.8333H6.33331V13.8333ZM2.99998 7.16663H4.66665V8.83329H6.33331V10.5H4.66665V12.1666H2.99998V10.5H1.33331V8.83329H2.99998V7.16663Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function InviteFriendsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M13.5 1.5H9V3H7.5V7.5H9V3H13.5V1.5ZM13.5 7.5H9V9H13.5V7.5ZM13.5 3H15V7.5H13.5V3ZM5.25 12H6.75V10.5H15.75V12H6.75V15H15.75V12H17.25V16.5H5.25V12ZM2.25 6H3.75V7.5H5.25V9H3.75V10.5H2.25V9H0.75V7.5H2.25V6Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function UploadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.25 3.75V2.25H9.75V3.75H11.25V5.25H12.75V6.75H11.25V5.25H9.75V12.75H8.25V5.25H6.75V6.75H5.25V5.25H6.75V3.75H8.25ZM2.25 11.25V15.75H15.75V11.25H14.25V14.25H3.75V11.25H2.25Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function ArrowRightIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3 8.25V9.75H12V11.25H13.5V9.75H15V8.25H13.5V6.75H12V8.25H3ZM10.5 5.25H12V6.75H10.5V5.25ZM10.5 5.25H9V3.75H10.5V5.25ZM10.5 12.75H12V11.25H10.5V12.75ZM10.5 12.75H9V14.25H10.5V12.75Z"
        fill="currentColor"
      />
    </svg>
  );
}

export const ArrowLeftIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="18"
    height="18"
    viewBox="0 0 18 18"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      d="M15 8.25V9.75H6V11.25H4.5V9.75H3V8.25H4.5V6.75H6V8.25H15ZM7.5 5.25H6V6.75H7.5V5.25ZM7.5 5.25H9V3.75H7.5V5.25ZM7.5 12.75H6V11.25H7.5V12.75ZM7.5 12.75H9V14.25H7.5V12.75Z"
      fill="white"
    />
  </svg>
);

export function GamePadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.33334 3.3335H14.6667V12.6668H1.33334V3.3335ZM13.3333 11.3335V4.66683H2.66668V11.3335H13.3333ZM5.33334 6.00016H6.66668V7.3335H8.00001V8.66683H6.66668V10.0002H5.33334V8.66683H4.00001V7.3335H5.33334V6.00016ZM9.33334 6.00016H10.6667V7.3335H9.33334V6.00016ZM12 8.66683H10.6667V10.0002H12V8.66683Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M4.00001 1.3335H10.6667V2.66683H4.00001V1.3335ZM2.66668 4.00016V2.66683H4.00001V4.00016H2.66668ZM2.66668 12.0002H1.33334V4.00016H2.66668V12.0002ZM4.00001 13.3335H2.66668V12.0002H4.00001V13.3335ZM12 13.3335H4.00001V14.6668H12V13.3335ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 12.0002H14.6667V5.3335H13.3333V12.0002ZM8.00001 4.00016H5.33334V5.3335H4.00001V10.6668H5.33334V12.0002H10.6667V10.6668H12V8.00016H10.6667V10.6668H5.33334V5.3335H8.00001V4.00016ZM9.33334 9.3335V6.66683H10.6667V5.3335H12V4.00016H14.6667V2.66683H13.3333V1.3335H12V4.00016H10.6667V5.3335H9.33334V6.66683H6.66668V9.3335H9.33334Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinningsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.99999 1.3335H12V2.66683H3.99999V1.3335ZM2.66666 4.00016V2.66683H3.99999V4.00016H2.66666ZM2.66666 12.0002V4.00016H1.33333V12.0002H2.66666ZM3.99999 13.3335V12.0002H2.66666V13.3335H3.99999ZM12 13.3335V14.6668H3.99999V13.3335H12ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 4.00016H14.6667V12.0002H13.3333V4.00016ZM13.3333 4.00016V2.66683H12V4.00016H13.3333ZM7.33333 3.3335H8.66666V4.66683H10.6667V6.00016H6.66666V7.3335H10.6667V11.3335H8.66666V12.6668H7.33333V11.3335H5.33333V10.0002H9.33333V8.66683H5.33333V4.66683H7.33333V3.3335Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function ZapIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.00001 0.666504H9.33334V5.99984H14.6667V8.6665H13.3333V7.33317H8.00001V3.33317H6.66668V1.99984H8.00001V0.666504ZM5.33334 4.6665V3.33317H6.66668V4.6665H5.33334ZM4.00001 5.99984V4.6665H5.33334V5.99984H4.00001ZM2.66668 7.33317V5.99984H4.00001V7.33317H2.66668ZM9.33334 12.6665V13.9998H8.00001V15.3332H6.66668V9.99984H1.33334V7.33317H2.66668V8.6665H8.00001V12.6665H9.33334ZM10.6667 11.3332V12.6665H9.33334V11.3332H10.6667ZM12 9.99984V11.3332H10.6667V9.99984H12ZM12 9.99984H13.3333V8.6665H12V9.99984Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WaffleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="13"
      viewBox="0 0 16 13"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.04242 2.73877H3.72203V11.3731H1.04242V2.73877Z"
        fill="#FFC931"
      />
      <path
        d="M13.1901 0.0595703H15.8697L15.8548 8.64922L13.1901 8.69388V0.0595703Z"
        fill="#FFC931"
      />
      <path
        d="M1.04242 11.3735V8.69385H6.40164V11.3735H1.04242Z"
        fill="#FFC931"
      />
      <path
        d="M10.5104 11.3735V8.69385H13.19V11.3735H10.5104Z"
        fill="#FFC931"
      />
      <path
        d="M3.72208 2.73918V0.0595703H15.8696V2.73918H3.72208Z"
        fill="#FFC931"
      />
      <path
        d="M9.66196 9.51262L10.4807 8.69385H12.2522V9.55728L9.66196 9.51262Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 9.5275L3.72208 8.69385L6.32726 8.72362L5.56804 9.5275H2.88843Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 3.72168H3.69231V8.69385L2.88843 9.49773V3.72168Z"
        fill="#00CFF2"
      />
      <path
        d="M15.8995 2.76894H15.8948L15.8846 8.64926V8.67847L15.8555 8.67898L13.2199 8.72313V11.4032H10.4808V9.5564L9.66138 9.54241L9.59133 9.54121L10.4685 8.66409H13.1604V2.76894H3.75195V8.66409H6.43156V11.4032H1.01279V2.7094H3.6924V0.0297852H15.8995V2.76894Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M0.149292 3.63184H2.8289V12.2661H0.149292V3.63184Z"
        fill="#FFC931"
      />
      <path
        d="M12.2969 0.952637H14.9765V9.58694H12.2969V0.952637Z"
        fill="#FFC931"
      />
      <path
        d="M0.149292 12.2665V9.58691H5.50852V12.2665H0.149292Z"
        fill="#FFC931"
      />
      <path
        d="M9.61728 12.2665V9.58691H12.2969V12.2665H9.61728Z"
        fill="#FFC931"
      />
      <path
        d="M2.82895 3.63225V3.58759V2.73904V0.952637H14.9765V3.63225H2.82895Z"
        fill="#FFC931"
      />
      <path
        d="M5.57784 7.97606V7.09321H4.61276V6.34748H5.57784V5.35498H6.27972V6.34748H7.25027V7.09321H6.27972V7.97606H5.57784Z"
        fill="#FB72FF"
      />
      <path
        d="M11.2249 6.6694C11.2249 7.40936 10.625 8.0092 9.88509 8.0092C9.14513 8.0092 8.54529 7.40936 8.54529 6.6694C8.54529 5.92944 9.14513 5.32959 9.88509 5.32959C10.625 5.32959 11.2249 5.92944 11.2249 6.6694Z"
        fill="#00CFF2"
      />
      <path
        d="M14.9764 0.952536V3.63215V9.58684L15.8547 8.67875V0.0742188L14.9764 0.952536Z"
        fill="#00CFF2"
      />
      <path
        d="M12.2969 0.952774H14.9765L15.8548 0.074457L3.67749 0.0595703L2.82895 0.952774H12.2969Z"
        fill="#FB72FF"
      />
      <path
        d="M2.8289 2.73877H1.0425L0.149292 3.58731H2.8289V2.73877Z"
        fill="#FB72FF"
      />
      <path
        d="M13.1901 11.3589L12.4085 12.2522C12.3904 12.2727 12.3564 12.2599 12.3564 12.2325V9.64697H13.1901V11.3589Z"
        fill="#00CFF2"
      />
      <path
        d="M9.88512 5.29972C10.6417 5.29972 11.2547 5.9129 11.2547 6.6693C11.2547 7.42569 10.6417 8.03888 9.88512 8.03888C9.12873 8.03888 8.51554 7.42569 8.51554 6.6693C8.51554 5.9129 9.12873 5.29972 9.88512 5.29972ZM6.30936 5.32544V6.31794H7.27994V7.12322H6.30936V8.00607H5.54796V7.12322H4.58288V6.31794H5.54796V5.32544H6.30936ZM15.8845 8.69103L15.8761 8.6997L14.9978 9.60794L14.9889 9.61687H13.2197V11.3699L13.2123 11.3783L12.4308 12.2715C12.3947 12.3129 12.3265 12.2873 12.3265 12.2322V12.2965H9.58739V9.55732H12.267V3.66218H2.85858V9.55732H5.5382V12.2965H0.119425V3.61752H0.0746155L0.128714 3.56616L1.02192 2.71761L1.03052 2.70943H2.79904V0.940913L2.80723 0.932308L3.65577 0.0391039L3.66458 0.0297852L3.67738 0.0298142L15.8547 0.044701L15.8845 0.04473V8.69103Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M6.36393 8.70556C6.38463 8.68931 6.41666 8.70369 6.41666 8.73156V11.37L6.40943 11.3783L5.61406 12.2992C5.57779 12.3415 5.50884 12.3153 5.50943 12.2599L5.53834 9.60201L5.53846 9.5904L5.54635 9.58206L6.35997 8.70923L6.36393 8.70556Z"
        fill="#00CFF2"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
    </svg>
  );
}

export function LeaveGameIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.5228 15.9831V14.531H13.0686V15.9831H14.5228Z"
        fill="#331A39"
      />
      <path
        d="M13.0685 15.9999V14.5479H11.6165V15.9999H13.0685Z"
        fill="#331A39"
      />
      <path
        d="M11.6166 15.9662V14.5142H10.1646V15.9662H11.6166Z"
        fill="#331A39"
      />
      <path
        d="M10.1645 15.9662V14.5142H8.7124V15.9662H10.1645Z"
        fill="#331A39"
      />
      <path
        d="M8.71232 15.9662V14.5142H7.26025V15.9662H8.71232Z"
        fill="#331A39"
      />
      <path
        d="M7.26031 15.9662V14.5142L5.81665 14.531V15.983L7.26031 15.9662Z"
        fill="#331A39"
      />
      <path
        d="M5.79142 15.9662V14.5142H4.33936V15.9662H5.79142Z"
        fill="#331A39"
      />
      <path
        d="M4.33927 15.9662V14.5142H2.88721V15.9662H4.33927Z"
        fill="#331A39"
      />
      <path d="M14.506 15.9662V14.5142H1.4353V15.9662H14.506Z" fill="#331A39" />
      <path
        d="M14.5396 14.5142H15.9916V13.0601H14.5396V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 14.5311H14.5311V13.0769H13.0769V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 14.5079H13.0771V13.0537H11.625V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 14.5079H11.6249V13.0537H10.1729V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 14.5079H10.1728V13.0537H8.7207V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 14.5079H8.72086V13.0537H7.2688V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 14.5079H7.26871V13.0537H5.81665V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 14.5079H5.81657V13.0537H4.3645V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9126 14.5311H4.36466V13.0769H2.9126V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 14.5311H2.91471V13.0769H1.46265V14.5311Z"
        fill="#EA7EBD"
      />
      <path d="M0 14.5311H1.45206V13.0769H0V14.5311Z" fill="#331A39" />
      <path d="M14.5396 13.06H15.9916V11.6079H14.5396V13.06Z" fill="#331A39" />
      <path
        d="M13.0769 13.0768H14.5311V11.6248H13.0769V13.0768Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 13.0539H11.6249V11.6018H10.1729V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 13.0539H10.1728V11.6018H8.7207V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 13.0539H8.72086V11.6018H7.2688V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 13.0539H7.26871V11.6018H5.81665V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 13.0539H5.81657V11.6018H4.3645V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 13.0768H2.91471V11.6248H1.46265V13.0768Z"
        fill="#EA7EBD"
      />
      <path d="M0 13.0768H1.45206V11.6248H0V13.0768Z" fill="#331A39" />
      <path
        d="M14.5396 11.608H15.9916V10.1538H14.5396V11.608Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 11.6248H14.5311V10.1707H13.0769V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 11.6016H13.0771V10.1475H11.625V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 11.6016H10.1728V10.1475H8.7207V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 11.6016H8.72086V10.1475H7.2688V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 11.6016H7.26871V10.1475H5.81665V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 11.6248H4.36661V10.1707H2.91455V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 11.6248H2.91471V10.1707H1.46265V11.6248Z"
        fill="#EA7EBD"
      />
      <path d="M0 11.6248H1.45206V10.1707H0V11.6248Z" fill="#331A39" />
      <path
        d="M14.5396 10.1537H15.9916V8.70166H14.5396V10.1537Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 10.1706H14.5311V8.71851H13.0769V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 10.1475H13.0771V8.69336H11.625V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 10.1475H11.6249V8.69336H10.1729V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 10.1475H8.72086V8.69336H7.2688V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 10.1706H5.81657V8.71851H4.3645V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 10.1706H4.36661V8.71851H2.91455V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 10.1706H2.91471V8.71851H1.46265V10.1706Z"
        fill="#EA7EBD"
      />
      <path d="M0 10.1706H1.45206V8.71851H0V10.1706Z" fill="#331A39" />
      <path
        d="M14.5059 8.70172H15.9579V7.24756H14.5059V8.70172Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 8.71857H14.5311V7.2644H13.0769V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 8.69327H13.0771V7.24121H11.625V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 8.69327H11.6249V7.24121H10.1729V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 8.69327H10.1728V7.24121H8.7207V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 8.71857H7.26871V7.2644H5.81665V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 8.71857H5.81657V7.2644H4.3645V8.71857Z" fill="#EA7EBD" />
      <path
        d="M2.91455 8.71857H4.36661V7.2644H2.91455V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 8.71857H2.91471V7.2644H1.46265V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M0 8.71857H1.45206V7.2644H0V8.71857Z" fill="#331A39" />
      <path
        d="M14.5059 7.24772H15.9579V5.79565H14.5059V7.24772Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 7.26432H14.5311V5.81226H13.0769V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 7.24127H13.0771V5.78711H11.625V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 7.24127H11.6249V5.78711H10.1729V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 7.24127H8.72086V5.78711H7.2688V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 7.26432H5.81657V5.81226H4.3645V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9147 7.26432H4.36676L4.36466 5.81226H2.9126L2.9147 7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 7.26432H2.91471V5.81226H1.46265V7.26432Z"
        fill="#EA7EBD"
      />
      <path d="M0 7.26432H1.45206V5.81226H0V7.26432Z" fill="#331A39" />
      <path
        d="M14.5059 5.79547H15.9579V4.34131H14.5059V5.79547Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 5.81232H14.5311V4.35815H13.0769V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 5.78702H13.0771V4.33496H11.625V5.78702Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 5.81232H10.1728V4.35815H8.7207V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 5.81232H8.72086V4.35815H7.2688V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.83984 5.81232H7.29191V4.35815H5.83984V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 5.81232H4.36661V4.35815H2.91455V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 5.81232H2.91471V4.35815H1.46265V5.81232Z"
        fill="#EA7EBD"
      />
      <path d="M0 5.81232H1.45206V4.35815H0V5.81232Z" fill="#331A39" />
      <path
        d="M14.5059 4.34147H15.9579V2.8894H14.5059V4.34147Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 4.35831H14.5311V2.90625H13.0769V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 4.35831H11.6249V2.90625H10.1729V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 4.35831H10.1728V2.90625H8.7207V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 4.35831H8.72086V2.90625H7.2688V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 4.35831H7.26871V2.90625H5.81665V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 4.35831H5.81657V2.90625H4.3645V4.35831Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 13.0768H13.0771V11.6248H11.625V13.0768Z" fill="white" />
      <path d="M2.9126 13.0768H4.36466V11.6248H2.9126V13.0768Z" fill="white" />
      <path
        d="M10.1729 11.6248H11.6249V10.1707H10.1729V11.6248Z"
        fill="white"
      />
      <path
        d="M4.36475 11.6248H5.81681V10.1707H4.36475V11.6248Z"
        fill="white"
      />
      <path d="M8.72095 10.1706H10.173V8.71851H8.72095V10.1706Z" fill="white" />
      <path
        d="M5.81665 10.1706H7.26871V8.71851H5.81665V10.1706Z"
        fill="white"
      />
      <path d="M7.2688 8.71857H8.72086V7.2644H7.2688V8.71857Z" fill="white" />
      <path d="M8.72095 7.26456H10.173V5.8125H8.72095V7.26456Z" fill="white" />
      <path d="M5.81665 7.26456H7.26871V5.8125H5.81665V7.26456Z" fill="white" />
      <path
        d="M10.1729 5.81232H11.6249V4.35815H10.1729V5.81232Z"
        fill="white"
      />
      <path
        d="M4.36475 5.81232H5.81681V4.35815H4.36475V5.81232Z"
        fill="white"
      />
      <path d="M11.625 4.35831H13.0771V2.90625H11.625V4.35831Z" fill="white" />
      <path d="M2.9126 4.35831H4.36466V2.90625H2.9126V4.35831Z" fill="white" />
      <path
        d="M1.46265 4.35831H2.91471V2.90625H1.46265V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 4.35831H1.46036V2.90625H0.00830078V4.35831Z"
        fill="#331A39"
      />
      <path
        d="M14.5312 14.5142H15.9833V1.4519H14.5312V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 2.90607H14.5311V1.4519H13.0769V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 2.90607H13.0771V1.4519H11.625V2.90607Z" fill="#E97BBB" />
      <path
        d="M10.1729 2.90607H11.6249V1.4519H10.1729V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M8.7207 2.90607H10.1728V1.4519H8.7207V2.90607Z" fill="#EA7EBD" />
      <path d="M7.2688 2.90607H8.72086V1.4519H7.2688V2.90607Z" fill="#EA7EBD" />
      <path
        d="M5.81665 2.90607H7.26871V1.4519H5.81665V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 2.90607H5.81657V1.4519H4.3645V2.90607Z" fill="#EA7EBD" />
      <path d="M2.9126 2.90607H4.36466V1.4519H2.9126V2.90607Z" fill="#EA7EBD" />
      <path
        d="M1.46265 2.90607H2.91471V1.4519H1.46265V2.90607Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 2.90607H1.46036V1.4519H0.00830078V2.90607Z"
        fill="#331A39"
      />
      <path d="M13.0769 0V1.45206H14.5311V0H13.0769Z" fill="#331A39" />
      <path d="M11.625 0V1.45206H13.0771V0H11.625Z" fill="#331A39" />
      <path d="M10.1729 0V1.45206H11.6249V0H10.1729Z" fill="#331A39" />
      <path d="M8.7207 0V1.45206H10.1728V0H8.7207Z" fill="#331A39" />
      <path
        d="M7.26245 0.00634766V1.45841H8.71451V0.00634766H7.26245Z"
        fill="#331A39"
      />
      <path
        d="M5.81665 0V1.45206L7.26241 1.45837V0.00630392L5.81665 0Z"
        fill="#331A39"
      />
      <path
        d="M4.3645 0V1.45206L5.81026 1.45837V0.00630392L4.3645 0Z"
        fill="#331A39"
      />
      <path d="M2.9126 0V1.45206H4.36466V0H2.9126Z" fill="#331A39" />
      <path d="M1.46265 0V1.45206H14.5396V0H1.46265Z" fill="#331A39" />
    </svg>
  );
}

export function Clock({
  className = "",
  style,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) {
  return (
    <span className={cn("w-20 h-20", className)} style={style} {...props}>
      <Image
        src="/images/icons/clock.svg"
        alt="Clock"
        fill
        style={{ objectFit: "contain" }}
        className="!relative w-full h-full"
        draggable={false}
        priority={false}
      />
    </span>
  );
}

export function ForwardMessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M14 5H12V9H6V11H4V17H6V15H12V19H14V17H16V15H18V13H20V11H18V9H16V7H14V5Z"
        fill="white"
      />
    </svg>
  );
}

export function MessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M22 2H2V16H4V4H20V16H12V18H10V20H8V16H2V18H6V22H10V20H12V18H22V2Z"
        fill="#1B8FF5"
      />
    </svg>
  );
}

export function CopyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M17.5 14.9998H5.83333V1.6665H12.5V3.33317H14.1667V4.99984H12.5V6.6665H14.1667V4.99984H15.8333V6.6665H17.5V14.9998ZM7.5 3.33317V13.3332H15.8333V8.33317H10.8333V3.33317H7.5ZM2.5 4.99984H4.16667V16.6665H14.1667V18.3332H2.5V4.99984Z"
        fill="#00CFF2"
      />
    </svg>
  );
}

export function TrophyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M10.75 13.7035V15.25H14.5V16.75H5.5V15.25H9.25V13.7035C7.80002 13.5207 6.46661 12.8149 5.5 11.7188C4.53339 10.6227 4.00002 9.21146 4 7.75V3.25H16V7.75C16 9.21146 15.4666 10.6227 14.5 11.7188C13.5334 12.8149 12.2 13.5207 10.75 13.7035ZM1.75 4.75H3.25V7.75H1.75V4.75ZM16.75 4.75H18.25V7.75H16.75V4.75Z"
        fill={props.color || "#34C759"}
      />
    </svg>
  );
}

export function UsdcIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="16"
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <g clipPath="url(#clip0_268_39833)">
        <path
          d="M7.87865 15.5198C12.0512 15.5198 15.4081 12.1629 15.4081 7.99035C15.4081 3.81778 12.0512 0.460938 7.87865 0.460938C3.70608 0.460938 0.349243 3.81778 0.349243 7.99035C0.349243 12.1629 3.70608 15.5198 7.87865 15.5198Z"
          fill="#2775CA"
        />
        <path
          d="M9.94932 9.1832C9.94932 8.08518 9.29051 7.70871 7.97288 7.55187C7.03172 7.42635 6.84348 7.1754 6.84348 6.73613C6.84348 6.29686 7.15723 6.01458 7.78465 6.01458C8.34934 6.01458 8.66309 6.20282 8.81993 6.67341C8.85132 6.76753 8.94544 6.83025 9.03956 6.83025H9.54146C9.66697 6.83025 9.76109 6.73613 9.76109 6.61069V6.57929C9.63558 5.88907 9.07088 5.35576 8.34934 5.29304V4.54009C8.34934 4.41458 8.25523 4.32046 8.09839 4.28906H7.62781C7.5023 4.28906 7.40818 4.38318 7.37678 4.54009V5.26164C6.43562 5.38716 5.8396 6.01458 5.8396 6.79893C5.8396 7.83422 6.46702 8.24202 7.78465 8.39893C8.66309 8.55577 8.94544 8.74401 8.94544 9.246C8.94544 9.74798 8.50618 10.0931 7.91016 10.0931C7.09443 10.0931 6.81209 9.74791 6.71797 9.27732C6.68665 9.15188 6.59253 9.08908 6.49841 9.08908H5.96504C5.8396 9.08908 5.74548 9.1832 5.74548 9.30872V9.34011C5.87092 10.1244 6.3729 10.6891 7.40818 10.846V11.5989C7.40818 11.7244 7.5023 11.8185 7.65913 11.8499H8.12971C8.25523 11.8499 8.34934 11.7558 8.38074 11.5989V10.846C9.32191 10.6891 9.94932 10.0303 9.94932 9.1832Z"
          fill="white"
        />
        <path
          d="M6.27942 12.4778C3.83236 11.5994 2.57743 8.86997 3.48729 6.45423C3.95787 5.13658 4.99317 4.13269 6.27942 3.6621C6.40493 3.59938 6.46765 3.50526 6.46765 3.34835V2.90916C6.46765 2.78364 6.40493 2.68953 6.27942 2.6582C6.24802 2.6582 6.1853 2.6582 6.1539 2.68953C3.17354 3.6307 1.54214 6.79938 2.48331 9.77975C3.04802 11.5366 4.39706 12.8856 6.1539 13.4503C6.27942 13.5131 6.40493 13.4503 6.43626 13.3248C6.46765 13.2935 6.46765 13.2621 6.46765 13.1994V12.7601C6.46765 12.666 6.37354 12.5406 6.27942 12.4778ZM9.60493 2.68953C9.47942 2.62681 9.3539 2.68953 9.32258 2.81504C9.29118 2.84644 9.29118 2.87776 9.29118 2.94056V3.37975C9.29118 3.50526 9.3853 3.6307 9.47942 3.6935C11.9265 4.57188 13.1814 7.30129 12.2715 9.71703C11.801 11.0347 10.7657 12.0386 9.47942 12.5092C9.3539 12.5719 9.29118 12.666 9.29118 12.8229V13.2621C9.29118 13.3876 9.3539 13.4817 9.47942 13.5131C9.51082 13.5131 9.57354 13.5131 9.60493 13.4817C12.5853 12.5406 14.2167 9.37188 13.2755 6.39151C12.7108 4.60328 11.3304 3.25423 9.60493 2.68953Z"
          fill="white"
        />
      </g>
      <defs>
        <clipPath id="clip0_268_39833">
          <rect width="16" height="16" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
}

--- File: ./src/components/CardStack.tsx ---
"use client";

import { useMemo, useRef } from "react";
import Image from "next/image";
import {
  motion,
  useMotionValue,
  useTransform,
  useMotionTemplate,
} from "framer-motion";

interface CardStackProps {
  images: { src: string; alt?: string }[];
  /** Can be number (px) or CSS string: 'clamp()', '5vw', '3rem', etc */
  size?: number | string; // default 'clamp(32px, 6vw, 48px)'
  borderColor?: string; // default '#FFFFFF'
  rotations?: number[]; // default figure-like: [-9, 6, -4, 7]
  interactive?: boolean;
  maxCards?: number;
  ariaLabel?: string;
}

export function CardStack({
  images,
  size = "clamp(32px, 6vw, 48px)",
  borderColor = "#FFFFFF",
  rotations = [-9, 6, -4, 7],
  interactive = false,
  maxCards = 4,
  ariaLabel = "image cards stack",
}: CardStackProps) {
  const x = useMotionValue(0);
  const tilt = useTransform(x, [-200, 200], [-4, 4]);
  const containerRef = useRef<HTMLDivElement>(null);

  const handleMove: React.PointerEventHandler<HTMLDivElement> = (e) => {
    if (!interactive || !containerRef.current) return;
    const rect = containerRef.current.getBoundingClientRect();
    x.set(e.clientX - (rect.left + rect.width / 2));
  };
  const handleLeave = () => interactive && x.set(0);

  const cards = useMemo(() => images.slice(0, maxCards), [images, maxCards]);

  return (
    <motion.div
      ref={containerRef}
      onPointerMove={handleMove}
      onPointerLeave={handleLeave}
      aria-label={ariaLabel}
      className="relative flex items-center"
      style={{ gap: 0 }}
    >
      {cards.map((img, i) => {
        // --- Responsive CSS variables derived from size ---
        const base = `var(--card-size)`;
        const border = `calc(${base} * 0.07)`; // ~7%
        const radius = `calc(${base} * 0.14)`; // ~14%
        const overlap = `calc(${base} * 0.52)`; // ~52%

        const staticRotation = rotations[i % rotations.length] ?? 0;
        const motionRotation = interactive
          ? useMotionTemplate`${tilt}deg`
          : undefined;

        return (
          <motion.div
            key={img.src + i}
            style={{
              // 🎯 set CSS variable so everything scales from `size`
              ["--card-size" as keyof React.CSSProperties]:
                typeof size === "number" ? `${size}px` : size,
              width: base,
              height: base,
              marginLeft: i === 0 ? 0 : `calc(-1 * ${overlap})`,
              borderColor,
              borderWidth: border,
              borderRadius: radius,
              rotate: interactive ? undefined : `${staticRotation}deg`,
              zIndex: 10 + i,
            }}
            className="shrink-0 border bg-[#F0F3F4] overflow-hidden"
            whileHover={interactive ? { y: -1 } : undefined}
            transition={{ type: "spring", stiffness: 320, damping: 22 }}
          >
            <motion.div
              style={{
                width: "100%",
                height: "100%",
                rotate: interactive ? motionRotation : 0,
              }}
              className="w-full h-full"
            >
              <Image
                src={img.src}
                alt={img.alt ?? "image card"}
                fill
                className="object-cover"
              />
            </motion.div>
          </motion.div>
        );
      })}
    </motion.div>
  );
}

--- File: ./src/components/onboarding/onboarding-carousel.tsx ---
"use client";

import { useState } from "react";
import { OnboardingSlide } from "./onboarding-slide";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

interface Slide {
  icon: string;
  title: string;
  description: string;
}

const slides: Slide[] = [
  {
    icon: "/images/illustrations/waffle-ticket.png",
    title: "Buy a Waffle",
    description:
      "Buy your ticket, play the game, and share in the prize pool with other winners",
  },
  {
    icon: "/images/illustrations/money-bag.png",
    title: "Win Big",
    description: "The faster you connect the dots, the bigger your share",
  },
  {
    icon: "/images/illustrations/crown.png",
    title: "Take Your",
    description: "Recognize the images, climb the leaderboard. EZ",
  },
];

interface OnboardingCarouselProps {
  onComplete: () => void;
}

export function OnboardingCarousel({ onComplete }: OnboardingCarouselProps) {
  const [currentSlide, setCurrentSlide] = useState(0);

  const handleNext = () => {
    if (currentSlide < slides.length - 1) {
      setCurrentSlide(currentSlide + 1);
    } else {
      onComplete();
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 flex items-center justify-center">
        <OnboardingSlide
          key={currentSlide}
          icon={slides[currentSlide].icon}
          title={slides[currentSlide].title}
          description={slides[currentSlide].description}
        />
      </div>

      <div className="p-6 space-y-3 mb-10">
        <FancyBorderButton onClick={handleNext} className="w-full">
          {currentSlide === 0 ? "Next" : "Let's Go"}
        </FancyBorderButton>
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/onboarding-overlay.tsx ---
"use client";

import Image from "next/image";
import { OnboardingCarousel } from "./onboarding-carousel";

interface OnboardingOverlayProps {
  onComplete: () => void;
}

/**
 * Full-screen onboarding overlay that reuses the existing onboarding UI.
 * Renders above the app and blocks interaction until completion.
 */
export function OnboardingOverlay({ onComplete }: OnboardingOverlayProps) {
  return (
    <div className="fixed inset-0 z-50 app-background noise flex flex-col">
      <div className="p-8 flex items-center justify-center">
        <Image
          src="/logo-icon.png"
          alt="Logo"
          width={150}
          height={80}
          priority
        />
      </div>
      <div className="flex-1">
        <OnboardingCarousel onComplete={onComplete} />
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/onboarding-gate.tsx ---
"use client";

import { useOnboarding } from "@/hooks/useOnboarding";
import { OnboardingOverlay } from "./onboarding-overlay";

interface Props {
  children: React.ReactNode;
}

/**
 * Wraps the app to present the onboarding overlay to first-time users.
 * Blocks interaction until onboarding is completed to ensure key concepts are seen.
 */
export function OnboardingGate({ children }: Props) {
  const { isReady, shouldShowOnboarding, completeOnboarding } = useOnboarding();

  if (!isReady) return null;

  return (
    <>
      {children}
      {shouldShowOnboarding && (
        <OnboardingOverlay onComplete={completeOnboarding} />
      )}
    </>
  );
}

--- File: ./src/components/onboarding/onboarding-slide.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";

interface OnboardingSlideProps {
  icon: string;
  title: string;
  description: string;
  className?: string;
}

export function OnboardingSlide({
  icon,
  title,
  description,
  className,
}: OnboardingSlideProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center px-8 py-12",
        className
      )}
    >
      <div className="mb-8 animate-in-right relative w-48 h-48">
        <Image src={icon} alt={title} fill className="object-contain" />
      </div>
      <h2 className="text-3xl font-bold mb-4 text-balance animate-in-right uppercase tracking-wider">
        {title}
      </h2>
      <p className="text-lg text-center font-display text-muted max-w-md text-pretty animate-in-right">
        {description}
      </p>
    </div>
  );
}

--- File: ./src/components/inputs/PixelInput.tsx ---
import type { InputHTMLAttributes } from "react";
import { cn } from "@/lib/utils";

interface PixelInputProps extends InputHTMLAttributes<HTMLInputElement> {
  className?: string;
}

export function PixelInput({ className, ...props }: PixelInputProps) {
  return (
    <input
      type="text"
      className={cn(
        "w-full h-14 bg-[#2a2a2a] border-none text-[#a0a0a0] placeholder:text-[#5a5a5a]",
        "text-center font-input text-xl tracking-wider rounded-lg",
        "focus-visible:ring-[#00cff2] focus-visible:ring-2",
        className
      )}
      {...props}
    />
  );
}

--- File: ./src/hooks/useMiniUser.ts ---
"use client";

import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useAccount } from "wagmi";

/**
 * Merges Farcaster + wallet identity into one consistent hook.
 */
export function useMiniUser() {
  const { context, isMiniAppReady } = useMiniKit();
  const { address, isConnected } = useAccount();

  const user = {
    fid: context?.user?.fid ?? null,
    username: context?.user?.username ?? "",
    pfpUrl: context?.user?.pfpUrl ?? "",
    wallet: address ?? "",
    isConnected,
    isMiniAppReady,
  };

  const mockUser = {
    fid: 755074,
    username: "chukwukauba",
    pfpUrl:
      "https://imagedelivery.net/BXluQx4ige9GuW0Ia56BHw/3d4b3ff7-3ed7-4522-125a-9419a85ada00/original",
    wallet: "",
    isConnected: true,
    isMiniAppReady: true,
  };

  return user.fid ? user : mockUser;
}

--- File: ./src/hooks/useVibration.ts ---
export function useVibration() {
  const vibrate = (pattern: number | number[] = 80) => {
    if (typeof window !== "undefined" && "vibrate" in navigator)
      navigator.vibrate(pattern);
  };
  return { vibrate };
}

--- File: ./src/hooks/useOnboarding.ts ---
"use client";

import { useCallback, useEffect, useState } from "react";
import { useMiniUser } from "./useMiniUser";

const ONBOARDING_STORAGE_KEY = "waffles:onboarded:v1.3";

/**
 * Manages first-time user onboarding state with safe, persistent storage.
 * We intentionally scope persistence to the device (localStorage) to avoid
 * leaking cross-account state and to keep UX snappy without server roundtrips.
 */
export function useOnboarding() {
  const [isOnboarded, setIsOnboarded] = useState<boolean>(true);
  const [isReady, setIsReady] = useState<boolean>(false);
  const { fid, username, pfpUrl, wallet } = useMiniUser();

  useEffect(() => {
    try {
      const stored =
        typeof window !== "undefined"
          ? window.localStorage.getItem(ONBOARDING_STORAGE_KEY)
          : null;
      setIsOnboarded(stored === "true");
    } catch (_err) {
      console.log(_err);
      // If storage is blocked, default to showing onboarding once
      setIsOnboarded(false);
    } finally {
      setIsReady(true);
    }
  }, []);

  const completeOnboarding = useCallback(async () => {
    try {
      if (typeof window !== "undefined") {
        window.localStorage.setItem(ONBOARDING_STORAGE_KEY, "true");
      }
      if (fid && username) {
        console.log("syncing user", { fid, username, pfpUrl, wallet });
        const res = await fetch("/api/user/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ fid, username, pfpUrl, wallet }),
        });
        if (!res.ok) {
          throw new Error("Failed to sync user");
        }
        const data = await res.json();
        if (!data.success) {
          throw new Error("Failed to sync user");
        }
      }
    } catch (_err) {
      console.error("Failed to sync user", _err);
      // Non-fatal: proceed even if storage fails
    }
    setIsOnboarded(true);
  }, [fid, username, pfpUrl, wallet]);

  return {
    isReady,
    isOnboarded,
    shouldShowOnboarding: isReady && !isOnboarded,
    // for testing
    // shouldShowOnboarding: true,
    completeOnboarding,
  };
}

--- File: ./src/hooks/useSyncUser.ts ---
"use client";

import { useEffect, useRef } from "react";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useLobby } from "@/state";

export function useSyncUser() {
  const { fid, username, pfpUrl, wallet } = useMiniUser();
  const { registerReferralCode, fetchReferralStatus } = useLobby();
  const lastSyncRef = useRef<{
    fid: number;
    username: string;
    pfpUrl?: string | null;
    wallet?: string | null;
  } | null>(null);

  useEffect(() => {
    if (!fid || !username) return;

    const last = lastSyncRef.current;
    if (
      last &&
      last.fid === fid &&
      last.username === username &&
      last.pfpUrl === pfpUrl &&
      last.wallet === wallet
    ) {
      return;
    }

    lastSyncRef.current = { fid, username, pfpUrl, wallet };

    const syncUser = async () => {
      console.log("syncing user", { fid, username, pfpUrl, wallet });
      try {
        const res = await fetch("/api/user/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            fid,
            username,
            pfpUrl,
            wallet,
          }),
        });
        if (!res.ok) {
          throw new Error(`Sync failed with status ${res.status}`);
        }
        const data = await res.json();
        if (data?.referralCode) {
          registerReferralCode({
            code: data.referralCode,
            inviterFarcasterId: String(fid),
            inviteeId: data.referral?.inviteeId,
          });
        }

        await fetchReferralStatus(String(fid));
      } catch (err) {
        console.error("Failed to sync user:", err);
      }
    };

    syncUser();
  }, [
    fid,
    wallet,
    username,
    pfpUrl,
    registerReferralCode,
    fetchReferralStatus,
  ]);
}

--- File: ./src/hooks/useSound.ts ---
export function useSound() {
  const play = (src: string, volume = 0.6) => {
    const audio = new Audio(src);
    audio.volume = volume;
    audio.play().catch(() => {});
  };
  return { play };
}

--- File: ./src/hooks/useCountdown.ts ---
"use client";

import { useCallback, useEffect, useMemo, useRef, useState } from "react";

interface UseCountdownOptions {
  // Total duration in seconds (mutually exclusive with target)
  durationSeconds?: number;
  // Absolute wall-clock target for countdown end
  target?: Date | number; // epoch ms
  // Autostart countdown on mount (default: true)
  autoStart?: boolean;
  // Tick interval (default: 1000ms)
  intervalMs?: number;
  // Optional callbacks
  onTick?: (millisecondsLeft: number) => void;
  onComplete?: () => void;
}

interface UseCountdownResult {
  millisecondsLeft: number;
  secondsLeft: number;
  isRunning: boolean;
  start: () => void;
  pause: () => void;
  reset: (opts?: { durationSeconds?: number; target?: Date | number }) => void;
  setTarget: (target: Date | number) => void;
}

/**
 * High-accuracy countdown hook.
 * - Uses a fixed end timestamp to avoid drift across ticks.
 * - Supports either relative duration or absolute target time.
 */
export function useCountdown(
  options: UseCountdownOptions = {}
): UseCountdownResult {
  const {
    durationSeconds,
    target,
    autoStart = true,
    intervalMs = 1000,
    onTick,
    onComplete,
  } = options;

  const [endAt, setEndAt] = useState<number>(() => {
    if (typeof target !== "undefined") {
      return target instanceof Date ? target.getTime() : target;
    }
    if (typeof durationSeconds === "number") {
      return Date.now() + Math.max(0, durationSeconds) * 1000;
    }
    return 0; // inactive until started
  });

  const [isRunning, setIsRunning] = useState<boolean>(
    Boolean(autoStart && (durationSeconds || target))
  );
  const intervalRef = useRef<number | null>(null);
  // Track the current clock time to drive re-renders each tick
  const [now, setNow] = useState<number>(Date.now());

  const millisecondsLeft = useMemo(
    () => Math.max(0, endAt - now),
    [endAt, now]
  );
  const secondsLeft = Math.ceil(millisecondsLeft / 1000);

  const clearTimer = useCallback(() => {
    if (intervalRef.current !== null) {
      window.clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  const tick = useCallback(() => {
    const ms = Math.max(0, endAt - Date.now());
    // Advance the clock to force consumers to re-render
    setNow(Date.now());
    if (onTick) onTick(ms);
    if (ms <= 0) {
      clearTimer();
      setIsRunning(false);
      onComplete?.();
    }
  }, [endAt, onTick, onComplete, clearTimer]);

  const start = useCallback(() => {
    if (!endAt || endAt <= Date.now()) return; // nothing to start
    if (intervalRef.current !== null) return;
    setIsRunning(true);
    // Immediate tick to sync consumers before first interval fires
    tick();
    intervalRef.current = window.setInterval(tick, Math.max(16, intervalMs));
  }, [endAt, intervalMs, tick]);

  const pause = useCallback(() => {
    clearTimer();
    setIsRunning(false);
    // Convert remaining time into a new endAt relative to pause moment
    const remaining = Math.max(0, endAt - Date.now());
    setEndAt(Date.now() + remaining);
  }, [clearTimer, endAt]);

  const reset = useCallback(
    (opts?: { durationSeconds?: number; target?: Date | number }) => {
      clearTimer();
      const nextTarget = opts?.target ?? target;
      const nextDuration =
        typeof opts?.durationSeconds === "number"
          ? opts.durationSeconds
          : durationSeconds;

      if (typeof nextTarget !== "undefined") {
        const ts =
          nextTarget instanceof Date ? nextTarget.getTime() : nextTarget;
        setEndAt(ts);
        setIsRunning(Boolean(autoStart));
        if (autoStart) {
          // Sync once immediately, then start ticking
          tick();
          intervalRef.current = window.setInterval(
            tick,
            Math.max(16, intervalMs)
          );
        }
        return;
      }
      if (typeof nextDuration === "number") {
        const ts = Date.now() + Math.max(0, nextDuration) * 1000;
        setEndAt(ts);
        setIsRunning(Boolean(autoStart));
        if (autoStart) {
          // Sync once immediately, then start ticking
          tick();
          intervalRef.current = window.setInterval(
            tick,
            Math.max(16, intervalMs)
          );
        }
        return;
      }
      // No inputs -> stop and clear
      setEndAt(0);
      setIsRunning(false);
    },
    [autoStart, clearTimer, durationSeconds, intervalMs, target, tick]
  );

  const setTarget = useCallback(
    (t: Date | number) => {
      clearTimer();
      const ts = t instanceof Date ? t.getTime() : t;
      setEndAt(ts);
      setIsRunning(Boolean(autoStart));
      if (autoStart) {
        // Sync once immediately, then start ticking
        tick();
        intervalRef.current = window.setInterval(
          tick,
          Math.max(16, intervalMs)
        );
      }
    },
    [autoStart, clearTimer, intervalMs, tick]
  );

  // Manage lifecycle
  useEffect(() => {
    if (autoStart && (durationSeconds || target)) {
      start();
    }
    return clearTimer;
  }, [autoStart, durationSeconds, target, start, clearTimer]);

  return {
    millisecondsLeft,
    secondsLeft,
    isRunning,
    start,
    pause,
    reset,
    setTarget,
  };
}

--- File: ./src/hooks/useTimer.ts ---
"use client";

import { useCallback, useEffect, useRef, useState } from "react";

interface UseTimerOptions {
  /** Total duration of the timer (in ms) */
  duration: number;

  /** Auto start on mount */
  autoStart?: boolean;

  /** Called exactly once when timer completes */
  onComplete?: () => void;
}

export function useTimer({
  duration,
  autoStart = false,
  onComplete,
}: UseTimerOptions) {
  const [isRunning, setIsRunning] = useState(autoStart);
  const [elapsed, setElapsed] = useState(0); // ms elapsed
  const startRef = useRef<number | null>(null);
  const rafRef = useRef<number | null>(null);
  const completedRef = useRef(false);

  const _tick = useCallback(() => {
    if (!isRunning) return;

    const now = performance.now();
    if (startRef.current === null) startRef.current = now;

    const newElapsed = elapsed + (now - startRef.current);
    const clampedElapsed = Math.min(newElapsed, duration);

    setElapsed(clampedElapsed);
    startRef.current = now;

    if (clampedElapsed >= duration && !completedRef.current) {
      completedRef.current = true;
      setIsRunning(false);
      onComplete?.();
      return;
    }

    rafRef.current = requestAnimationFrame(_tick);
  }, [elapsed, duration, isRunning, onComplete]);

  const start = useCallback(() => {
    if (isRunning) return;
    completedRef.current = false;
    startRef.current = null;
    setIsRunning(true);
  }, [isRunning]);

  const pause = useCallback(() => {
    if (!isRunning) return;
    setIsRunning(false);
  }, [isRunning]);

  const resume = useCallback(() => {
    if (isRunning || elapsed >= duration) return;
    setIsRunning(true);
    startRef.current = null;
  }, [isRunning, elapsed, duration]);

  const reset = useCallback(() => {
    setIsRunning(false);
    setElapsed(0);
    startRef.current = null;
    completedRef.current = false;
  }, []);

  useEffect(() => {
    if (!isRunning) {
      if (rafRef.current !== null) {
        cancelAnimationFrame(rafRef.current);
      }
      return undefined; // IMPORTANT
    }

    rafRef.current = requestAnimationFrame(_tick);

    return () => {
      if (rafRef.current !== null) {
        cancelAnimationFrame(rafRef.current);
      }
    };
  }, [isRunning, _tick]);

  // -- Derived values --
  const remaining = Math.max(duration - elapsed, 0);
  const percent = Math.min(elapsed / duration, 1);

  const formatted = new Date(remaining).toISOString().substr(14, 5); // mm:ss

  return {
    isRunning,
    elapsed,
    remaining,
    percent,
    formatted,
    start,
    pause,
    resume,
    reset,
  };
}

--- File: ./src/hooks/useIsMobile.ts ---
"use client";

import { useEffect, useMemo, useState } from "react";

const UA_MOBILE_REGEX =
  /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop|Mobile/i;

export function useIsMobile() {
  const [vw, setVw] = useState<number | null>(null);
  const [ua, setUa] = useState<string>("");

  useEffect(() => {
    // viewport width
    const update = () => setVw(window.innerWidth);
    update();
    window.addEventListener("resize", update);
    return () => window.removeEventListener("resize", update);
  }, []);

  useEffect(() => {
    setUa(navigator.userAgent || "");
  }, []);

  // heuristics: UA OR small viewport
  return useMemo(() => {
    const uaLooksMobile = UA_MOBILE_REGEX.test(ua);
    const viewportLooksMobile = (vw ?? 0) <= 900; // tweak threshold as you like
    return uaLooksMobile || viewportLooksMobile;
  }, [ua, vw]);
}

--- File: ./src/actions/game.ts ---
[File is empty]

--- File: ./src/lib/supabaseClient.ts ---
// src/lib/supabaseClient.ts
import { createClient } from "@supabase/supabase-js";
import { env } from "./env";

export const supabase = createClient(
  env.nextPublicSupabaseUrl,
  env.nextPublicSupabaseAnonKey,
  {
    realtime: { params: { eventsPerSecond: 1 } },
  }
);

--- File: ./src/lib/utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- File: ./src/lib/server/game.ts ---
// ───────────────────────── src/lib/server/fetchInitialGame.ts ─────────────────────────
import { prisma } from "@/lib/db";
import { Prisma } from "@prisma/client";
export type GameWithConfigAndQuestions = Prisma.GameGetPayload<{
  include: {
    config: true;
    questions: true;
  };
}>;

export async function fetchInitialGame(gameId: number) {
  const game = await prisma.game.findUnique({
    where: { id: gameId },
    include: {
      config: true,
      questions: true,
    },
  });

  if (!game) throw new Error("Game not found");

  return {
    id: game.id,
    name: game.name,
    description: game.description,
    config: {
      ticketPrice: game.config?.ticketPrice ?? 50,
      roundTimeLimit: game.config?.roundTimeLimit ?? 15,
      questionsPerGame: game.config?.questionsPerGame ?? game.questions.length,
      scoreMultiplier: game.config?.scoreMultiplier ?? 1,
      scorePenalty: game.config?.scorePenalty,
      maxPlayers: game.config?.maxPlayers ?? 100,
      soundEnabled: game.config?.soundEnabled ?? true,
    },
    questions: game.questions.map((q) => ({
      id: q.id,
      text: q.text,
      imageUrl: q.imageUrl,
      options: q.options,
      correctAnswer: q.correctAnswer,
    })),
  };
}

/**
 * Fetches the most recent active game with its configuration and questions.
 * A game is considered "active" if:
 *  - It has a startTime <= now
 *  - It has no endTime, or endTime > now
 * If none match, it falls back to the most recently created game.
 */
export async function fetchActiveGame(): Promise<GameWithConfigAndQuestions | null> {
  const now = new Date();

  // Try to find an active game
  const active = await prisma.game.findFirst({
    where: {
      OR: [
        {
          startTime: { lte: now },
          endTime: { gt: now },
        },
        {
          startTime: { lte: now },
          endTime: null,
        },
      ],
    },
    include: {
      config: true,
      questions: true,
    },
    orderBy: { startTime: "desc" },
  });

  // Fallback to most recent created game if no active game found
  const game = active
    ? active
    : await prisma.game.findFirst({
        include: { config: true, questions: true },
        orderBy: { createdAt: "desc" },
      });

  if (!game) return null;

  return game;
}

--- File: ./src/lib/scoring.ts ---
export function calculateScore(timeTaken: number, maxTime: number): number {
  if (!Number.isFinite(maxTime) || maxTime <= 0) return 0;
  const clampedTime = Math.min(Math.max(0, timeTaken), maxTime);
  const speedRatio = (maxTime - clampedTime) / maxTime;
  const basePoints = 300 + speedRatio * 2700; // between 300–3000
  return Math.max(0, Math.round(basePoints));
}

export function isMatch(choiceId: number, targetId: number): boolean {
  // In real version: compare identifiers for correct pair
  return choiceId === targetId;
}

--- File: ./src/lib/SoundManager.ts ---
const SOUND_FILES = {
  click: "/sounds/click_001.ogg",
  countdown: "/sounds/dice-shake-1.ogg",
  correct: "/sounds/dice-shake-1.ogg",
  wrong: "/sounds/dice-shake-1.ogg",
  nextQuestion: "/sounds/dice-shake-1.ogg",
  questionStart: "/sounds/dice-shake-1.ogg",
  gameOver: "/sounds/dice-shake-1.ogg",
} as const;

export type SoundName = keyof typeof SOUND_FILES;

type PlayOptions = {
  loop?: boolean;
  volume?: number;
};

type SoundManagerAPI = {
  init(): Promise<void>;
  play(name: SoundName, options?: PlayOptions): void;
  stop(name: SoundName): void;
  stopAll(): void;
};

const isBrowser =
  typeof window !== "undefined" && typeof window.Audio !== "undefined";

class BrowserSoundManager implements SoundManagerAPI {
  private static instance: BrowserSoundManager;
  private audioContext?: AudioContext;
  private sounds: Map<SoundName, HTMLAudioElement> = new Map();
  private looping: Map<SoundName, HTMLAudioElement> = new Map();

  private constructor() {
    if (!isBrowser) return;

    (Object.entries(SOUND_FILES) as [SoundName, string][]).forEach(
      ([name, url]) => {
        const base = new window.Audio(url);
        base.preload = "auto";
        base.load();
        this.sounds.set(name, base);
      }
    );
  }

  public static getInstance(): BrowserSoundManager {
    if (!BrowserSoundManager.instance) {
      BrowserSoundManager.instance = new BrowserSoundManager();
    }
    return BrowserSoundManager.instance;
  }

  public async init(): Promise<void> {
    if (this.audioContext || !isBrowser) return;
    const Ctor =
      window.AudioContext ||
      (window as unknown as { webkitAudioContext?: AudioContext })
        .webkitAudioContext;
    if (!Ctor) return;

    this.audioContext = new Ctor();
    try {
      await this.audioContext.resume();
    } catch (error) {
      console.warn("Failed to resume audio context", error);
    }
  }

  public play(name: SoundName, options: PlayOptions = {}): void {
    const base = this.sounds.get(name);
    if (!base) return;

    const { loop = false, volume } = options;
    const instance = loop
      ? this.getLoopInstance(name, base)
      : this.createOneShot(base);

    instance.loop = loop;
    if (typeof volume === "number") {
      instance.volume = Math.min(1, Math.max(0, volume));
    }

    if (!loop) {
      instance.currentTime = 0;
    }

    instance.play().catch((error) => {
      console.debug(`Failed to play sound "${name}"`, error);
    });

    if (!loop) {
      instance.addEventListener(
        "ended",
        () => {
          instance.remove();
        },
        { once: true }
      );
    }
  }

  public stop(name: SoundName): void {
    const loopingInstance = this.looping.get(name);
    if (!loopingInstance) return;
    loopingInstance.pause();
    loopingInstance.currentTime = 0;
    loopingInstance.loop = false;
    this.looping.delete(name);
  }

  public stopAll(): void {
    this.looping.forEach((instance) => {
      instance.pause();
      instance.currentTime = 0;
      instance.loop = false;
    });
    this.looping.clear();
  }

  private getLoopInstance(
    name: SoundName,
    base: HTMLAudioElement
  ): HTMLAudioElement {
    const existing = this.looping.get(name);
    if (existing) {
      existing.currentTime = 0;
      return existing;
    }
    const instance = this.createOneShot(base);
    instance.currentTime = 0;
    this.looping.set(name, instance);
    return instance;
  }

  private createOneShot(base: HTMLAudioElement): HTMLAudioElement {
    const instance = new window.Audio(base.src);
    instance.preload = "auto";
    return instance;
  }
}

const SoundManager: SoundManagerAPI = isBrowser
  ? BrowserSoundManager.getInstance()
  : {
      async init() {
        return Promise.resolve();
      },
      play() {
        // noop on server
      },
      stop() {
        // noop on server
      },
      stopAll() {
        // noop on server
      },
    };

export default SoundManager;

--- File: ./src/lib/env.ts ---
const resolveRootUrl = (): string => {
  const explicit =
    process.env.NEXT_PUBLIC_URL ?? process.env.NEXT_PUBLIC_APP_URL ?? null;

  const vercelProject = process.env.VERCEL_PROJECT_PRODUCTION_URL
    ? `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`
    : null;

  const vercelUrl = process.env.VERCEL_URL
    ? `https://${process.env.VERCEL_URL}`
    : null;

  return explicit || vercelProject || vercelUrl || "http://localhost:3000";
};

export const env = {
  rootUrl: resolveRootUrl(),

  // server keys
  neynarApiKey: process.env.NEYNAR_API_KEY!,

  // client keys
  nextPublicOnchainkitApiKey: process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY!,
  waffleMainAddress: process.env
    .NEXT_PUBLIC_WAFFLE_MAIN_ADDRESS as `0x${string}`,
  nextPublicUsdcAddress: process.env.NEXT_PUBLIC_USDC_ADDRESS! as `0x${string}`, // Base USDC token address
  nextPublicSupabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  nextPublicSupabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  nextPublicLeaderboardPageSize:
    Number.parseInt(
      process.env.NEXT_PUBLIC_LEADERBOARD_PAGE_SIZE ??
        process.env.LEADERBOARD_PAGE_SIZE ??
        "25",
      10
    ) || 25,
};

--- File: ./src/lib/neynarClient.ts ---
import { env } from "@/lib/env";
import { NeynarAPIClient } from "@neynar/nodejs-sdk";

export const neynar = new NeynarAPIClient({
  apiKey: env.neynarApiKey,
});

--- File: ./src/lib/fonts/ndot47_bd.woff2 ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/index.ts ---
import localFont from "next/font/local";

export const fontDisplay = localFont({
  src: [
    {
      path: "./brockmann_bd.otf",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-display",
});

export const fontBody = localFont({
  src: [
    {
      path: "./editundo_bd.ttf",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-body",
});

export const fontInput = localFont({
  src: [
    {
      path: "./ndot47_bd.woff2",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-input",
});

--- File: ./src/lib/fonts/brockmann_bd.otf ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/editundo_bd.ttf ---
[Content not included: Binary file]

--- File: ./src/lib/db.ts ---
// /src/server/db.ts
import { PrismaClient } from "@prisma/client";

declare global {
  // Prevent multiple instances of PrismaClient in development
  // (prevents exhausting database connections on hot-reload)
  var prisma: PrismaClient | undefined;
}

export const prisma: PrismaClient =
  global.prisma ||
  new PrismaClient({
    // log: ["query"], // optional: log queries for debugging
  });

if (process.env.NODE_ENV !== "production") {
  global.prisma = prisma;
}

--- File: ./src/lib/time.ts ---
export function formatCountdown(target: Date): string {
  const diff = target.getTime() - Date.now();
  if (diff <= 0) return "00:00";

  const minutes = Math.floor(diff / 60000);
  const seconds = Math.floor((diff % 60000) / 1000);
  return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
    2,
    "0"
  )}`;
}

--- File: ./src/lib/wagmiConfig.ts ---
import { createConfig, http } from "wagmi";
import { base } from "wagmi/chains";
import { injected } from "wagmi/connectors";

export const wagmiConfig = createConfig({
  chains: [base],
  transports: {
    [base.id]: http(),
  },
  connectors: [injected()],
  ssr: true,
});

--- File: ./src/lib/streaks.ts ---
export function calculateStreak(gameDates: Date[]): number {
  if (gameDates.length === 0) return 0;

  const sorted = gameDates.sort((a, b) => b.getTime() - a.getTime());
  let streak = 1;
  for (let i = 1; i < sorted.length; i++) {
    const diff =
      (sorted[i - 1].getTime() - sorted[i].getTime()) / (1000 * 60 * 60 * 24);
    if (diff <= 1.1) streak++;
    else break;
  }
  return streak;
}

