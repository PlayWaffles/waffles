--- File: ./.next/package.json ---
{"type": "commonjs"}
--- File: ./package.json ---
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build --turbopack",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@coinbase/onchainkit": "^1.1.1",
    "@farcaster/miniapp-sdk": "^0.2.1",
    "@farcaster/quick-auth": "^0.0.8",
    "@neynar/nodejs-sdk": "^3.34.0",
    "@prisma/client": "6.18.0",
    "@radix-ui/react-dialog": "^1.1.15",
    "@supabase/supabase-js": "^2.76.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "framer-motion": "^12.23.24",
    "lucide-react": "^0.546.0",
    "next": "15.5.6",
    "next-themes": "^0.4.6",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.3.1",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.4.0",
    "viem": "^2.38.3",
    "wagmi": "^2.18.2",
    "zod": "^4.1.12",
    "zustand": "^5.0.8"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.6",
    "prisma": "6.18.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

--- File: ./.env ---
# Environment variables declared in this file are NOT automatically loaded by Prisma.
# Please add `import "dotenv/config";` to your `prisma.config.ts` file, or use the Prisma CLI with Bun
# to load environment variables from .env files: https://pris.ly/prisma-config-env-vars.

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# The following `prisma+postgres` URL is similar to the URL produced by running a local Prisma Postgres 
# server with the `prisma dev` CLI command, when not choosing any non-default ports or settings. The API key, unlike the 
# one found in a remote Prisma Postgres URL, does not contain any sensitive information.

DATABASE_URL="prisma+postgres://localhost:51213/?api_key=eyJkYXRhYmFzZVVybCI6InBvc3RncmVzOi8vcG9zdGdyZXM6cG9zdGdyZXNAbG9jYWxob3N0OjUxMjE0L3RlbXBsYXRlMT9zc2xtb2RlPWRpc2FibGUmY29ubmVjdGlvbl9saW1pdD0xJmNvbm5lY3RfdGltZW91dD0wJm1heF9pZGxlX2Nvbm5lY3Rpb25fbGlmZXRpbWU9MCZwb29sX3RpbWVvdXQ9MCZzaW5nbGVfdXNlX2Nvbm5lY3Rpb25zPXRydWUmc29ja2V0X3RpbWVvdXQ9MCIsIm5hbWUiOiJkZWZhdWx0Iiwic2hhZG93RGF0YWJhc2VVcmwiOiJwb3N0Z3JlczovL3Bvc3RncmVzOnBvc3RncmVzQGxvY2FsaG9zdDo1MTIxNS90ZW1wbGF0ZTE_c3NsbW9kZT1kaXNhYmxlJmNvbm5lY3Rpb25fbGltaXQ9MSZjb25uZWN0X3RpbWVvdXQ9MCZtYXhfaWRsZV9jb25uZWN0aW9uX2xpZmV0aW1lPTAmcG9vbF90aW1lb3V0PTAmc2luZ2xlX3VzZV9jb25uZWN0aW9ucz10cnVlJnNvY2tldF90aW1lb3V0PTAifQ"
NEYNAR_API_KEY=

NEXT_PUBLIC_ONCHAINKIT_API_KEY=jrY4mos7-wh-8MFia-Am2Bii7mGStOxx
NEXT_PUBLIC_URL=

# 

# Connect to Supabase via connection pooling
# DATABASE_URL="postgresql://postgres.fuoqnzdloxjgbmqcvuqs:vjvKrnek7Kip6qhO@aws-1-eu-west-1.pooler.supabase.com:6543/postgres?pgbouncer=true"

# Direct connection to the database. Used for migrations
# DIRECT_URL="postgresql://postgres.fuoqnzdloxjgbmqcvuqs:vjvKrnek7Kip6qhO@aws-1-eu-west-1.pooler.supabase.com:5432/postgres"

NEXT_PUBLIC_SUPABASE_URL=https://fuoqnzdloxjgbmqcvuqs.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZ1b3FuemRsb3hqZ2JtcWN2dXFzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEyMTM1MDEsImV4cCI6MjA3Njc4OTUwMX0.trxful3F7TAu5Y0NDt7xGOh46EO5wLImLs8vuTMH__Q

--- File: ./next.config.ts ---
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;

--- File: ./src/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/favicon.ico ---
[Content not included: Binary file]

--- File: ./src/app/.DS_Store ---
[Content not included: Binary file]

--- File: ./src/app/.well-known/farcaster.json/route.ts ---
import { withValidManifest } from "@coinbase/onchainkit/minikit";
import { minikitConfig } from "../../../../minikit.config";

export async function GET() {
  return Response.json(withValidManifest(minikitConfig));
}

--- File: ./src/app/(authenticated)/lobby/invite-code/page.tsx ---
// src/app/(authenticated)/lobby/invite-code/page.tsx
// If a valid invite code is already present, skip this page.

"use client";
import LogoIcon from "@/components/logo/LogoIcon";
import React, { useEffect, useState } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { useLobbyStore } from "@/stores/lobbyStore";
import { PixelInput } from "@/components/inputs/PixelInput";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { PixelButton } from "@/components/buttons/PixelButton";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function InviteCodePage() {
  const router = useRouter();
  const {
    referralCode,
    validateReferral,
    referralData,
    referralStatus: status,
    ticket, // added to check if ticket already exists
  } = useLobbyStore();
  const user = useMiniUser();
  // If invite code is already valid, skip to Buy or directly into the game
  useEffect(() => {
    if (status === "success") {
      if (ticket) {
        // already have ticket: go straight into the game
        router.replace("/game");
      } else {
        // have code but no ticket: go to buy page
        router.replace("/lobby/buy");
      }
    }
  }, [status, ticket, router]);

  const [inputCode, setInputCode] = useState(referralCode || "");
  const [error, setError] = useState<string | null>(null);

  // Debounced code validation as user types
  useEffect(() => {
    if (inputCode.trim().length < 4 || !user.fid) {
      setError(null);
      return;
    }
    const timer = setTimeout(async () => {
      try {
        if (!user.fid) {
          console.error("User FID is null");
          return;
        }
        await validateReferral(inputCode, user.fid);
      } catch (err) {
        console.log(err);
        setError("Validation failed");
      }
    }, 500);
    return () => clearTimeout(timer);
  }, [inputCode, validateReferral, user.fid]);

  // On form submit: if code is valid, go to buy page
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!inputCode.trim() || inputCode.trim().length !== 4) return;
    if (!user.fid) {
      console.error("User FID is null");
      return;
    }
    if (status !== "success") {
      if (!user.fid) {
        console.error("User FID is null");
        return;
      }
      await validateReferral(inputCode, user.fid);
      if (useLobbyStore.getState().referralStatus !== "success") {
        setError("Invalid code");
        return;
      }
    }
    router.push("/lobby/buy");
  };

  return (
    <div className="min-h-screen max-w-screen-sm mx-auto px-8 flex flex-col">
      <div
        className={
          "p-4 flex items-center justify-center border-y border-border bg-figmaYay-gradient"
        }
      >
        <LogoIcon />
      </div>
      <div className="flex flex-col items-center justify-center py-16">
        {/* ICON */}
        <div className="mb-6">
          <Image
            src="/images/illustration/invite-key.png"
            alt="Invite Key"
            width={105}
            height={105}
            style={{ imageRendering: "pixelated" }}
          />
        </div>

        {/* TITLE */}
        <h2 className="mb-8 text-center text-3xl leading-tight font-bold uppercase tracking-wider">
          <span className="block">ENTER YOUR</span>
          <span className="block">INVITE CODE</span>
        </h2>

        {/* FORM */}
        <form
          onSubmit={handleSubmit}
          className="w-full max-w-md flex flex-col items-center gap-6"
          autoComplete="off"
        >
          <label htmlFor="inviteCodeInput" className="sr-only">
            Invite Code
          </label>

          <PixelInput
            id="inviteCodeInput"
            type="text"
            value={inputCode}
            onChange={(e) => setInputCode(e.target.value.toUpperCase())}
            placeholder="INVITE CODE"
            maxLength={4}
            autoFocus
          />

          <FancyBorderButton disabled={inputCode.trim().length !== 4}>
            GET IN
          </FancyBorderButton>

          {/* STATUS MESSAGES */}
          {status === "validating" && (
            <p
              className="text-xs mt-2"
              style={{
                color: "#a0a0a0",
                fontFamily: "'Press Start 2P', 'Geist Mono', monospace",
                letterSpacing: "0.04em",
              }}
            >
              Validating...
            </p>
          )}

          {status === "failed" && (
            <PixelButton
              className="flex items-center gap-2 font-body"
              backgroundColor="#FF5252"
              borderColor="#FF5252"
              textColor="#FFFFFF"
              onClick={() => setError(null)}
            >
              <Image
                src="/images/icons/icon-invalid.png"
                alt="Invalid Invite Code"
                width={20}
                height={20}
              />
              <span>{error || "Invalid"}</span>
            </PixelButton>
          )}

          {status === "success" && referralData && (
            <PixelButton
              className="flex items-center gap-2 font-body"
              backgroundColor="#14B985"
              borderColor="#14B985"
              textColor="#FFFFFF"
              onClick={() => router.push("/lobby/buy")}
            >
              <Image
                src="/images/icons/icon-valid.png"
                alt="Valid Invite Code"
                width={20}
                height={20}
              />
              <span>Valid</span>
            </PixelButton>
          )}
        </form>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/confirm/page.tsx ---
// ───────────────────────── src/app/lobby/confirm/_components/ConfirmScreen.tsx ─────────────────────────
"use client";

import React, { useEffect, useRef } from "react";
import Image from "next/image";
import { useRouter } from "next/navigation";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { useLobbyStore } from "@/stores/lobbyStore";

export default function ConfirmPage() {
  const router = useRouter();
  const { ticket, purchaseStatus } = useLobbyStore();
  const shareButtonRef = useRef<HTMLButtonElement | null>(null);

  // Redirect if no ticket
  useEffect(() => {
    if (!ticket || purchaseStatus !== "confirmed") {
      router.replace("/lobby/buy");
    }
  }, [ticket, purchaseStatus, router]);

  // Autofocus share
  useEffect(() => {
    shareButtonRef.current?.focus();
  }, []);

  const handleShare = async () => {
    if (!ticket) return;
    const shareData = {
      title: "Waffle Secured!",
      text: "I just grabbed my Waffle ticket for the next on-chain game. See you Friday!",
      url:
        typeof window !== "undefined" ? window.location.origin + "/lobby" : "",
    };

    try {
      if (navigator.share) {
        await navigator.share(shareData);
      } else {
        await navigator.clipboard.writeText(shareData.url);
        alert("Link copied to clipboard!");
      }
      router.replace("/game"); // ✅ Must share before returning
    } catch (err) {
      console.error("Share failed:", err);
      alert("Please share to continue!");
    }
  };

  if (!ticket) return null;

  return (
    <div className="bg-figmaYay noise min-h-[100svh] w-full px-5 py-8">
      {/* HERO */}
      <div className="mx-auto flex max-w-md flex-col items-center gap-3 animate-up">
        <Image
          src="/images/illustration/waffle-ticket.png"
          alt="Waffle"
          width={220}
          height={140}
          priority
          style={{ imageRendering: "pixelated" }}
        />
        <h1 className="text-center font-[var(--font-body)] text-4xl tracking-tight uppercase">
          WAFFLE SECURED!
        </h1>
        <p className="text-center text-[13px] text-muted">
          You&apos;re in. See you Friday.
        </p>
      </div>

      {/* TICKET CARD */}
      <div
        className="mx-auto mt-6 w-full max-w-md rounded-[16px] border border-[color:var(--color-waffle-gold)] bg-[color:var(--white-a10)] p-4 animate-up"
        style={{ animationDelay: "60ms" }}
      >
        <div className="mb-4 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <Image
              src="/images/avatars/a.png"
              alt="Avatar"
              width={48}
              height={48}
              className="rounded-full"
            />
            <span className="font-[var(--font-body)] text-lg">POTAT0X</span>
          </div>
          <div className="pixel-corners bg-[color:var(--color-waffle-gold)] px-3 py-2">
            <span className="font-[var(--font-body)] text-[12px] text-black uppercase">
              TICKET #{ticket.id}
            </span>
          </div>
        </div>

        <div className="grid grid-cols-2 gap-4">
          <div className="flex items-center gap-2">
            <Image
              src="/images/icons/icon-prizepool-cash.png"
              alt="Prize pool"
              width={24}
              height={24}
            />
            <div className="flex flex-col">
              <span className="text-[11px] text-muted">Prize pool</span>
              <span className="font-[var(--font-body)]">$12,500</span>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Image
              src="/images/icons/icon-theme-football.png"
              alt="Theme"
              width={24}
              height={24}
            />
            <div className="flex flex-col">
              <span className="text-[11px] text-muted">Theme</span>
              <span className="font-[var(--font-body)]">Football</span>
            </div>
          </div>
        </div>
      </div>

      {/* MANDATORY SHARE CTA */}
      <div className="mx-auto mt-6 max-w-md">
        <FancyBorderButton
          ref={shareButtonRef as React.RefObject<HTMLButtonElement>}
          aria-label="Share Ticket"
          onClick={handleShare}
          className="h-[64px] bg-white text-[color:var(--color-neon-pink)]"
        >
          <span className="font-[var(--font-body)] text-2xl">SHARE TICKET</span>
        </FancyBorderButton>
      </div>

      {/* Back Button — now hidden until share */}
      <div className="mx-auto mt-4 flex max-w-md justify-center opacity-40 select-none pointer-events-none">
        <button className="text-[color:var(--color-neon-cyan)] font-[var(--font-body)] text-base uppercase">
          BACK TO HOME
        </button>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/page.tsx ---
// src/app/(authenticated)/lobby/page.tsx
// If user already has code and ticket, skip to gameplay (the /game page).

"use client";

import React, { useEffect } from "react";
import Image from "next/image";
import { useLobbyStore } from "@/stores/lobbyStore";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { SpotsLeft } from "./buy/_components/SpotsLeft";
import { useRouter } from "next/navigation";
import LogoIcon from "@/components/logo/LogoIcon";
import { cn } from "@/lib/utils";
import { WalletIcon } from "@/components/icons";
import { BottomNav } from "@/components/BottomNav";

export default function LobbyPage() {
  const router = useRouter();
  const {
    stats,
    countdown,
    fetchStats,
    startCountdown,
    stopCountdown,
    referralStatus,
    ticket, // added to check if user already progressed
  } = useLobbyStore();

  // If invite code is valid AND ticket exists, go directly into the game
  useEffect(() => {
    if (referralStatus === "success" && ticket) {
      router.replace("/game");
    }
  }, [referralStatus, ticket, router]);

  // Fetch stats and start countdown normally if not redirected
  useEffect(() => {
    fetchStats();
    // Mock game start: 5 minutes from now
    const startTime = new Date(Date.now() + 5 * 60 * 1000);
    startCountdown(startTime);

    return () => stopCountdown();
  }, [fetchStats, startCountdown, stopCountdown]);

  return (
    <div className="h-screen flex flex-col bg-figmaYay noise relative font-body">
      {/* HEADER */}
      <div
        className={cn(
          "p-4 flex items-center justify-between border-b border-border bg-figmaYay"
        )}
      >
        <LogoIcon />
        <div className="flex items-center gap-1.5 bg-figmaYay rounded-full px-3 py-1.5">
          <WalletIcon className="w-4 h-4 text-foreground" />
          <span className="text-xs text-foreground">$983.23</span>
        </div>
      </div>

      {/* MAIN */}
      <main className="flex-1 flex flex-col items-center justify-center gap-6 text-center">
        {/* Title */}
        <h1 className="text-3xl font-bold uppercase tracking-wide">
          GAME LOBBY
        </h1>

        {/* Countdown */}
        <div className="flex flex-col items-center gap-1">
          <span className="text-sm text-muted">Next round starts in</span>
          <span className="text-5xl font-display tracking-tight text-[#00CFF2]">
            {countdown}
          </span>
        </div>

        {/* Prize Pool */}
        <div className="flex flex-col items-center">
          <span className="text-[13px] text-muted uppercase tracking-wide">
            Total Prize Pool
          </span>
          <span className="text-3xl font-display text-white">
            ${stats?.totalPrize ?? "0"}
          </span>
        </div>

        {/* Players */}
        <SpotsLeft
          current={stats?.totalTickets ?? 0}
          total={300}
          avatars={(stats?.players ?? [])
            .slice(0, 4)
            .map((p) => p.pfpUrl || "/images/avatars/a.png")}
        />

        {/* CTA */}
        <div className="mt-8 w-full max-w-[300px] px-4">
          <FancyBorderButton onClick={() => router.push("/game")}>
            ENTER GAME
          </FancyBorderButton>
        </div>

        {/* Leaderboard Preview */}
        <div className="mt-8 w-full max-w-sm">
          <h3 className="text-lg font-semibold mb-3 text-white/80">
            Top Players
          </h3>
          <ul className="flex flex-col gap-2 items-center">
            {(stats?.players ?? []).slice(0, 5).map((p, i) => (
              <li
                key={i}
                className="flex items-center justify-between w-full bg-white/5 rounded-lg px-4 py-2"
              >
                <div className="flex items-center gap-3">
                  <Image
                    src={p.pfpUrl || "/images/avatars/a.png"}
                    alt={p.username || "player"}
                    width={28}
                    height={28}
                    className="rounded-full"
                  />
                  <span className="text-white text-sm">{p.username}</span>
                </div>
                <span className="text-xs text-[#00CFF2] uppercase font-semibold">
                  Joined
                </span>
              </li>
            ))}
          </ul>
        </div>
      </main>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/buy/_components/SpotsLeft.tsx ---
import * as React from "react";

type SpotsLeftProps = {
  current: number; // e.g. 23
  total: number; // e.g. 100
  subtitle?: string; // default: "spots left"
  avatars: string[]; // 1–4 avatar URLs (shown left→right, overlapped)
  className?: string; // optional wrapper overrides
};

/**
 * Matches the Figma specs:
 * - Container: 228px wide, gap: 12px, centered
 * - Avatars: 42.11px, 3.0078px white border, 6.0156px radius, overlap -22.0571px
 * - Rotations: [-8.71, 5.85, -3.57, 7.56] deg
 * - Count: 32px size, letter-spacing -0.02em, line-height 115%, color #00CFF2
 * - Subtitle: 16px, weight 500, letter-spacing -0.03em, color #99A0AE
 *
 * Notes:
 * - I kept the exact decimals (rounded visually identical in browsers).
 * - If you use custom fonts (“Edit Undo BRK”, “Brockmann”), set them on body or replace the inline fontFamily below.
 */
export function SpotsLeft({
  current,
  total,
  subtitle = "spots left",
  avatars,
  className = "",
}: SpotsLeftProps) {
  // Limit to 4 items (per your mock). Provide rotation per index.
  const ROTATIONS = [-8.71, 5.85, -3.57, 7.56];

  // Clamp/format
  const clamped = Math.max(0, Math.min(current, total));

  return (
    <div
      className={`flex flex-col items-center gap-[12px] w-[228px] ${className}`}
      aria-label={`${clamped}/${total} ${subtitle}`}
    >
      {/* Avatars row */}
      <div className="flex items-center h-[48px] w-[119.94px]">
        {avatars.slice(0, 4).map((src, i) => (
          <div
            key={i}
            className={[
              "box-border w-[42.11px] h-[42.11px] rounded-[6.0156px] border-[3.0078px] border-white",
              // Figma shows a light gray fallback under the image
              "bg-[#F0F3F4] bg-cover bg-center",
              // overlap spacing
              i !== 0 ? "ml-[-22.0571px]" : "",
              // lift above previous slightly so borders look right
              "relative z-[1]",
              // little shadow helps match the “stacked card” look (optional)
              "shadow-[0_0_0_0_rgba(0,0,0,0)]",
            ].join(" ")}
            style={{
              transform: `rotate(${ROTATIONS[i] ?? 0}deg)`,
              backgroundImage: `url("${src}")`,
            }}
            aria-hidden="true"
          />
        ))}
      </div>

      {/* Text block */}
      <div className="flex flex-col items-center w-[228px] h-[58px]">
        <div className="flex items-end justify-center text-sm text-foreground font-display">
          {clamped}/{total}
        </div>
        <div className="w-[228px] h-[21px] text-center tracking-[-0.03em] leading-[130%] text-[16px] font-medium font-display">
          {subtitle}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/lobby/buy/page.tsx ---
// src/app/(authenticated)/lobby/buy/page.tsx
// If a ticket was already purchased, skip buying and go to confirmation.

"use client";

import React, { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import LogoIcon from "@/components/logo/LogoIcon";
import { cn } from "@/lib/utils";
import { InviteIcon, WalletIcon } from "@/components/icons";
import { BottomNav } from "@/components/BottomNav";
import Image from "next/image";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";
import { SpotsLeft } from "./_components/SpotsLeft";
import { useLobbyStore } from "@/stores/lobbyStore";

// ───────────────────────── CONSTANTS ─────────────────────────
const TICKET_PRICE = 50;
const GAME_ID = 1;

export default function BuyWafflePage() {
  const router = useRouter();
  const { buyTicket, purchaseStatus, ticket } = useLobbyStore();
  const [isPurchasing, setIsPurchasing] = useState(false);

  // If already have a ticket, redirect to confirmation
  useEffect(() => {
    if (ticket && purchaseStatus === "confirmed") {
      router.replace("/lobby/confirm");
    }
  }, [ticket, purchaseStatus, router]);

  // Placeholder stats
  const playerCount = 250;

  // ───────────────────────── HANDLER ─────────────────────────
  const handlePurchase = async () => {
    if (isPurchasing) return;
    setIsPurchasing(true);
    await buyTicket(1, GAME_ID, TICKET_PRICE); // userId=1 placeholder
    setIsPurchasing(false);

    if (useLobbyStore.getState().purchaseStatus === "confirmed") {
      router.push("/lobby/confirm");
    }
  };

  return (
    <div className="h-screen flex flex-col bg-figmaYay noise relative font-body">
      {/* HEADER */}
      <div
        className={cn(
          "p-4 flex items-center justify-between border-b border-border bg-figmaYay"
        )}
      >
        <LogoIcon />
        <div className="flex items-center gap-1.5 bg-figmaYay rounded-full px-3 py-1.5">
          <WalletIcon className="w-4 h-4 text-foreground" />
          <span className="text-xs text-foreground">{`$983.23`}</span>
        </div>
      </div>

      {/* MAIN CONTENT */}
      <div className="flex-1 flex flex-col items-center gap-6 justify-center overflow-y-auto">
        <div className="mb-6">
          <Image
            src="/images/illustration/waffle-ticket.png"
            alt="Waffle Ticket"
            width={152}
            height={93}
            className="mx-auto"
            style={{ imageRendering: "pixelated" }}
            priority
          />
        </div>

        <h1 className="text-foreground text-3xl text-center leading-tight">
          <span className="block">GET YOUR</span>
          <span className="block">WAFFLE</span>
        </h1>

        {/* BUY BUTTON */}
        <div className="w-full max-w-[400px] px-4">
          <FancyBorderButton onClick={handlePurchase} disabled={isPurchasing}>
            {isPurchasing || purchaseStatus === "pending"
              ? "PROCESSING..."
              : "BUY WAFFLE"}
          </FancyBorderButton>
        </div>

        {/* INVITE */}
        <button
          className="mt-5 flex items-center gap-1 text-xs font-bold text-[#00CFF2] hover:underline focus:outline-none"
          tabIndex={0}
        >
          <InviteIcon />
          INVITE FRIENDS{" "}
          <span className="text-xs font-bold ml-1">(20% BOOST!)</span>
        </button>

        <SpotsLeft
          current={playerCount}
          total={300}
          avatars={[
            "/images/avatars/a.png",
            "/images/avatars/b.png",
            "/images/avatars/c.png",
            "/images/avatars/d.png",
          ]}
        />
      </div>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/useInfiniteLoader.ts ---
"use client";

import { useEffect, useRef } from "react";

export function useInfiniteLoader(
  onHit: () => void,
  deps: unknown[] = []
): [React.RefObject<HTMLDivElement>] {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const el = ref.current;
    if (!el) return;

    const io = new IntersectionObserver(
      ([e]) => {
        if (e.isIntersecting) onHit();
      },
      { root: null, rootMargin: "400px 0px 800px 0px", threshold: 0 }
    );

    io.observe(el);
    return () => io.disconnect();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return [ref as React.RefObject<HTMLDivElement>];
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Tabs.tsx ---
"use client";
import type { TabKey } from "@/stores/leaderboardStore";
import { PixelButton } from "@/components/buttons/PixelButton";

export function Tabs({
  active,
  onChange,
}: {
  active: TabKey;
  onChange: (t: TabKey) => void;
}) {
  return (
    <div className="inline-flex items-center gap-2" role="tablist">
      {(["current", "allTime"] as const).map((k) => {
        const selected = active === k;
        return (
          <PixelButton
            key={k}
            role="tab"
            aria-selected={selected}
            backgroundColor={selected ? "white" : ""}
            textColor={selected ? "black" : "var(--color-waffle-gold)"}
            borderColor={"var(--color-waffle-gold)"}
            onClick={() => onChange(k)}
            borderWidth={4}
            className={[
              // Responsive paddings and text size
              "px-4 py-2 text-xs sm:px-6 sm:py-2 sm:text-sm",
              selected ? "font-bold" : "opacity-80 hover:opacity-100",
              selected ? "noise" : "bg-figmaYay noise",
              "transition",
            ].join(" ")}
            tabIndex={selected ? 0 : -1}
          >
            {k === "current" ? "Current game" : "All time"}
          </PixelButton>
        );
      })}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Row.tsx ---
import { Entry } from "@/stores/leaderboardStore";
import { UsdcIcon } from "@/components/icons";
import Image from "next/image";

export function Row({ entry }: { entry: Entry }) {
  return (
    <div className="panel flex h-12 items-center justify-between rounded-xl px-4">
      <div className="flex items-center gap-2">
        <div className="grid h-7 w-7 place-items-center rounded-full bg-white/10">
          <span className="text-xs leading-tight">{entry.rank}</span>
        </div>
        <div className="flex items-center gap-2">
          {entry.pfpUrl && (
            <Image
              src={entry.pfpUrl}
              alt={entry.username}
              width={30}
              height={30}
              className="rounded-full bg-[#F0F3F4] object-cover"
              draggable={false}
            />
          )}
          {!entry.pfpUrl && (
            <div className="grid h-7 w-7 place-items-center rounded-full bg-white/10">
              <span className="text-xs leading-tight">{entry.rank}</span>
            </div>
          )}
          <div className="text-sm leading-tight">{entry.username}</div>
        </div>
      </div>
      <div className="flex items-center gap-2">
        <UsdcIcon className="h-4 w-4" />
        <div className="font-display font-medium text-base tracking-tight">
          {entry.points.toLocaleString(undefined, {
            minimumFractionDigits: 2,
            maximumFractionDigits: 2,
          })}
        </div>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/_components/Top3.tsx ---
import { Entry } from "@/stores/leaderboardStore";
import { TrophyIcon, UsdcIcon } from "@/components/icons";

/** Top3: fixed single row (no wrap), fully responsive, no overflow */
export function Top3({ entries }: { entries: Entry[] }) {
  if (!entries?.length) return null;

  const cardStyles = [
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(52,199,89,0.12)]",
      trophy: "#34C759",
    },
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(25,171,211,0.12)]",
      trophy: "#19ABD3",
    },
    {
      bg: "bg-gradient-to-r from-transparent to-[rgba(211,77,25,0.12)]",
      trophy: "#D34D19",
    },
  ];

  return (
    <div
      className="
        flex w-full flex-nowrap items-stretch
        /* gap collapses on tiny screens, grows on wide */
        gap-[var(--gap)]
      "
      style={
        {
          // tune spacing & padding with CSS vars (works with Tailwind arbitrary values)
          ["--gap"]: "clamp(0.25rem, 2.2vw, 1rem)",
          ["--pad"]: "clamp(0.5rem, 2.2vw, 1rem)",
          ["--radius"]: "clamp(0.75rem, 2vw, 1rem)",
        } as React.CSSProperties
      }
    >
      {entries.slice(0, 3).map((entry, i) => (
        <article
          key={entry.rank}
          className={[
            "basis-1/3 min-w-0 flex-1",
            "rounded-[var(--radius)] border border-white/10",
            "p-[var(--pad)] bg-clip-padding",
            "flex flex-col gap-[calc(var(--pad)*1)]",
            "transition-shadow hover:shadow-lg",
            cardStyles[i]?.bg ?? "",
          ].join(" ")}
        >
          {/* trophy */}
          <TrophyIcon
            color={cardStyles[i]?.trophy}
            className="flex-shrink-0"
            style={{
              width: "clamp(14px, 2.8vw, 20px)",
              height: "clamp(14px, 2.8vw, 20px)",
            }}
            aria-label={`Place ${i + 1}`}
          />

          {/* avatar + name */}
          <div className="flex min-w-0 items-center gap-[calc(var(--pad)*0.5)]">
            {/* eslint-disable-next-line @next/next/no-img-element */}
            <img
              src={entry.pfpUrl || "/avatar.png"}
              alt={entry.username}
              draggable={false}
              className="rounded-full bg-[#F0F3F4] object-cover flex-shrink-0"
              style={{
                width: "clamp(18px, 3vw, 24px)",
                height: "clamp(18px, 3vw, 24px)",
              }}
            />
            <span
              title={entry.username}
              className="
                min-w-0 truncate text-white font-body font-normal leading-tight
              "
              style={{ fontSize: "clamp(0.7rem, 2.3vw, 0.95rem)" }}
            >
              {entry.username}
            </span>
          </div>

          {/* score */}
          <div className="mt-auto flex items-center gap-[calc(var(--pad)*0.5)]">
            <UsdcIcon
              className="flex-shrink-0"
              style={{
                width: "clamp(14px, 2.8vw, 20px)",
                height: "clamp(14px, 2.8vw, 20px)",
              }}
            />
            <span
              className="font-display font-medium tracking-tight leading-[1.1]"
              style={{ fontSize: "clamp(0.85rem, 2.6vw, 1rem)" }}
            >
              {entry.points.toLocaleString(undefined, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              })}
            </span>
          </div>
        </article>
      ))}
    </div>
  );
}

--- File: ./src/app/(authenticated)/leaderboard/page.tsx ---
"use client";

import Image from "next/image";
import { useEffect, useMemo, useRef } from "react";
import { Tabs } from "./_components/Tabs";
import { useLeaderboardStore, Entry } from "@/stores/leaderboardStore";
import { Top3 } from "./_components/Top3";
import { Row } from "./_components/Row";
import { WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";

export default function LeaderboardPage() {
  const { activeTab, slices, setActiveTab, fetchLeaderboard, rememberScroll } =
    useLeaderboardStore();

  const slice = slices[activeTab];

  // ───────────────────────── DATA PREP ─────────────────────────
  const top3 = useMemo<Entry[]>(
    () => slice.entries.slice(0, 3),
    [slice.entries]
  );
  const rest = useMemo<Entry[]>(() => slice.entries.slice(3), [slice.entries]);

  // ───────────────────────── HERO ANIMATION ─────────────────────────
  const crownRef = useRef<HTMLDivElement>(null);
  useEffect(() => {
    const el = crownRef.current;
    if (!el) return;
    const io = new IntersectionObserver(
      ([e]) => {
        const ratio = 1 - e.intersectionRatio;
        document.documentElement.style.setProperty(
          "--lb-progress",
          `${Math.min(Math.max(ratio, 0), 1)}`
        );
      },
      { threshold: Array.from({ length: 21 }, (_, i) => i / 20) }
    );
    io.observe(el);
    return () => io.disconnect();
  }, []);

  // ───────────────────────── SCROLL PERSISTENCE ─────────────────────────
  useEffect(() => setActiveTab(activeTab), [activeTab, setActiveTab]);

  useEffect(() => {
    const onScroll = () => rememberScroll(activeTab, window.scrollY);
    window.addEventListener("scroll", onScroll, { passive: true });
    return () => window.removeEventListener("scroll", onScroll);
  }, [activeTab, rememberScroll]);

  useEffect(() => {
    requestAnimationFrame(() =>
      window.scrollTo({
        top: slices[activeTab].scrollTop ?? 0,
        behavior: "instant" as const,
      })
    );
  }, [activeTab, slices]);

  // ───────────────────────── FETCHING ─────────────────────────
  useEffect(() => {
    const s = slices[activeTab];
    if (!s.entries.length && !s.isLoading) {
      fetchLeaderboard(activeTab).catch(console.error);
    }
  }, [activeTab, slices, fetchLeaderboard]);

  const loadMore = () => {
    const s = slices[activeTab];
    if (!s.isLoading && s.hasMore) {
      fetchLeaderboard(activeTab).catch(console.error);
    }
  };

  // ───────────────────────── OPTIONAL AUTO-REFRESH ─────────────────────────
  // 💡 Toggle ON/OFF easily by commenting this block ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
  useEffect(() => {
    if (activeTab !== "current") return; // refresh only for current game
    const interval = setInterval(() => {
      fetchLeaderboard("current").catch(console.error);
    }, 15000); // every 15 seconds
    return () => clearInterval(interval);
  }, [activeTab, fetchLeaderboard]);
  // 💡 End of auto-refresh block ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

  // ───────────────────────── RENDER ─────────────────────────
  return (
    <main className="min-h-[100dvh] bg-transparent">
      {/* HEADER */}
      <header className="sticky top-0 z-20 w-full border-b border-white/20 px-4 py-3 bg-figmaYay">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between ">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center"
                style={{ fontSize: "clamp(0.95rem, 1.9vw, 1rem)" }}
              >
                $983.23
              </span>
            </div>
          </div>
        </div>
      </header>

      {/* HERO + TABS */}
      <section className="mx-auto max-w-screen-sm px-4 pt-6 md:pt-10 relative">
        <div ref={crownRef} className="relative grid place-items-center">
          <Image
            src="/images/chest-crown.png"
            alt=""
            width={320}
            height={260}
            priority
            className="h-[180px] w-auto md:h-[220px] will-change-transform transition-[opacity,transform] duration-300"
            style={{
              opacity: `calc(1 - var(--lb-progress, 0))`,
              transform: `translateY(calc(-8px * var(--lb-progress, 0))) scale(calc(1 - 0.05 * var(--lb-progress, 0)))`,
            }}
          />
        </div>

        <div className="sticky top-14 z-10 -mx-4 px-4 pb-2 pt-1 bg-transparent">
          <h1 className="text-center font-body text-2xl md:text-3xl tracking-wide">
            LEADERBOARD
          </h1>

          <div className="mt-5 flex items-center justify-center gap-6">
            <Tabs active={activeTab} onChange={setActiveTab} />
          </div>

          <p className="mt-4 text-center text-muted font-display">
            {activeTab === "current"
              ? "Real-time standings from the current game"
              : "The greatest of all time"}
          </p>
        </div>
      </section>

      {/* LIST */}
      <section className="mx-auto max-w-screen-sm px-4 pb-24 pt-4 space-y-4">
        <Top3 entries={top3} />

        <div className="space-y-3">
          {rest.map((e) => (
            <Row key={e.rank} entry={e} />
          ))}

          {slice.isLoading && (
            <div className="h-11 rounded-2xl panel animate-pulse" />
          )}
          {slice.error && (
            <div className="panel px-4 py-3 text-sm text-danger">
              {slice.error}
            </div>
          )}
          {!slice.isLoading && !slice.entries.length && !slice.error && (
            <div className="panel px-4 py-6 text-center text-sm text-muted">
              Nothing here yet.
            </div>
          )}

          <button
            onFocus={loadMore}
            onMouseEnter={loadMore}
            onClick={loadMore}
            disabled={slice.isLoading}
            className="mx-auto block h-10 w-full max-w-[220px] rounded-xl border border-white/10 bg-white/5 text-sm transition disabled:opacity-50"
          >
            {slice.hasMore
              ? slice.isLoading
                ? "Loading…"
                : "Load more"
              : "End"}
          </button>
        </div>
      </section>

      <BottomNav />
    </main>
  );
}

--- File: ./src/app/(authenticated)/game/_components/GradientMask.tsx ---
"use client";

import Image from "next/image";
import clsx from "clsx";

/**
 * Bottom fade overlay that masks an image (or uses a solid fill if no src).
 *
 * - Sits on top of content (pointer-events: none)
 * - Width is responsive: clamps to container, not fixed Figma px
 * - Height is configurable (defaults to ~136px from the comp)
 *
 * Example:
 * <GradientMask className="bottom-24" src="/noise-bottom.png" />
 */
export default function GradientMask({
  className,
  height = 136,
  src,
  alt = "",
}: {
  className?: string;
  height?: number;
  /** Optional image to “fade”; if omitted we just fade a solid. */
  src?: string;
  alt?: string;
}) {
  return (
    <div
      aria-hidden
      className={clsx(
        "pointer-events-none absolute left-1/2 -translate-x-1/2 w-[min(94vw,40rem)]", // ~377px max but responsive
        className
      )}
      style={{ height }}
    >
      {src ? (
        <div className="relative h-full w-full">
          <Image
            src={src}
            alt={alt}
            fill
            sizes="(max-width: 768px) 94vw, 40rem"
            className={clsx(
              "object-cover",
              // Mask the image so it fades in (transparent → opaque) towards the bottom.
              "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
              "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]"
            )}
            priority
          />
        </div>
      ) : (
        // Fallback: just fade a solid surface to the page background.
        <div
          className={clsx(
            "h-full w-full",
            "[mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "[-webkit-mask-image:linear-gradient(to_bottom,rgba(0,0,0,0)_0%,rgba(0,0,0,0)_6%,rgba(0,0,0,1)_100%)]",
            "bg-background"
          )}
        />
      )}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/ChatTickerOverlay.tsx ---
import { useEffect, useMemo, useRef } from "react";
import Image from "next/image";
import clsx from "clsx";
import { useGameStore } from "@/stores/gameStore";

export default function ChatTickerOverlay({
  className,
  maxItems = 4,
}: {
  className?: string;
  maxItems?: number;
}) {
  const messages = useGameStore((s) => s.messages);
  const containerRef = useRef<HTMLDivElement>(null);

  const items = useMemo(() => {
    const trimmed = messages.slice(-maxItems);
    return trimmed.map((m, i) => ({
      id: `${i}-${m.username}-${m.message.slice(0, 6)}`,
      username: m.username ?? "anon",
      message: m.message ?? "",
      avatar: m.avatarUrl as string | undefined,
    }));
  }, [messages, maxItems]);

  useEffect(() => {
    const el = containerRef.current;
    if (el) el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
  }, [items.length]);

  return (
    <div
      aria-hidden
      className={clsx(
        "pointer-events-none absolute z-20 left-1/2 -translate-x-1/2 w-[min(94vw,40rem)] font-display",
        className
      )}
    >
      <div
        ref={containerRef}
        className="max-h-[7.5rem] overflow-hidden px-2 text-white/60"
        style={{
          WebkitMaskImage:
            "linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.1) 10%, rgba(0,0,0,1) 25%, rgba(0,0,0,1) 100%)",
          maskImage:
            "linear-gradient(to bottom, transparent 0%, rgba(0,0,0,0.1) 10%, rgba(0,0,0,1) 25%, rgba(0,0,0,1) 100%)",
        }}
      >
        <ul className="space-y-1.5">
          {items.map((m) => (
            <li
              key={m.id}
              className="flex items-start gap-2 text-xs sm:text-sm leading-relaxed"
            >
              <AvatarCircle src={m.avatar} name={m.username} />
              <div className="mt-[1px]">
                <span className="font-medium text-white/70">{m.username}</span>{" "}
                <span className="text-white/60">{m.message}</span>
              </div>
            </li>
          ))}
          <li className="h-2" />
        </ul>
      </div>
    </div>
  );
}

function AvatarCircle({ src, name }: { src?: string; name: string }) {
  const initial = name?.trim()?.charAt(0)?.toUpperCase() || "•";
  return src ? (
    <div className="relative mt-[2px] size-5 shrink-0 overflow-hidden rounded-full ring-1 ring-white/5">
      <Image src={src} alt={name} fill className="object-cover" />
    </div>
  ) : (
    <div className="grid size-5 shrink-0 place-items-center rounded-full bg-white/10 text-[.65rem] text-white/70 ring-1 ring-white/5">
      {initial}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/GameOverView.tsx ---
"use client";

import { useGameStore } from "@/stores/gameStore";
import { PixelButton } from "@/components/buttons/PixelButton";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function GameOverView() {
  const { score, resetGame, fetchQuestions, gameId } = useGameStore();
  const user = useMiniUser();
  return (
    <main className="flex flex-col items-center justify-center min-h-[100dvh] bg-figmaYay text-center space-y-6 px-6">
      {/* ───────────────────────── HEADER ───────────────────────── */}
      <h1 className="font-body text-3xl md:text-4xl text-white font-bold tracking-wide">
        GAME&nbsp;OVER
      </h1>

      {/* ───────────────────────── SCORE PANEL ───────────────────────── */}
      <div className="panel px-8 py-6 rounded-2xl bg-white/10 border border-white/20">
        <p className="text-white/80 text-lg font-body mb-2">Your total score</p>
        <p className="text-5xl font-display text-[color:var(--color-waffle-gold)]">
          {score}
        </p>
      </div>

      {/* ───────────────────────── ACTION BUTTONS ───────────────────────── */}
      <div className="flex flex-col sm:flex-row gap-4 mt-4">
        <PixelButton
          backgroundColor="#FFE8BA"
          borderColor="#FFC931"
          textColor="#151515"
          onClick={() => {
            if (gameId && user.fid && user.username && user.pfpUrl) {
              fetchQuestions(gameId, {
                fid: user.fid,
                username: user.username,
                pfpUrl: user.pfpUrl,
              });
            } else {
              console.error("No user found");
            }
          }}
        >
          Play Again
        </PixelButton>

        <PixelButton
          backgroundColor="#EFD6FF"
          borderColor="#B45CFF"
          textColor="#151515"
          onClick={resetGame}
        >
          Back to Lobby
        </PixelButton>
      </div>
    </main>
  );
}

--- File: ./src/app/(authenticated)/game/_components/QuestionTop.tsx ---
"use client";

import { useMemo } from "react";
import { useGameStore } from "@/stores/gameStore";

function mmss(total: number) {
  const m = Math.max(0, Math.floor(total / 60));
  const s = Math.max(0, total % 60);
  return `${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
}

/**
 * Top strip used inside QuestionView:
 *  - Left: Q index (01/20)
 *  - Right: two timers (round & question)
 *  - Row 2: Centered title (e.g., "WHO IS THIS?")
 */
export default function QuestionTop() {
  const currentQuestionIndex = useGameStore((s) => s.currentQuestionIndex);
  const totalQuestions = useGameStore((s) => s.totalQuestions);
  const roundTimer = useGameStore((s) => s.timeLeft);
  const questionTimer = useGameStore((s) => s.timeLeft);
  const currentQuestion = useGameStore((s) => s.currentQuestion);

  const qCount = useMemo(() => {
    const now = Math.max(0, currentQuestionIndex + 1);
    return `${String(now).padStart(2, "0")}/${String(totalQuestions).padStart(
      2,
      "0"
    )}`;
  }, [currentQuestionIndex, totalQuestions]);

  const tRound = useMemo(() => mmss(roundTimer), [roundTimer]);
  const tQuestion = useMemo(() => mmss(questionTimer), [questionTimer]);

  return (
    <div className="w-full max-w-md sm:max-w-lg mx-auto mt-14">
      {/* Row 1: counters */}
      <div className="flex items-center justify-between px-2 xs:px-3 sm:px-4 py-1.5">
        <span className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight">
          {qCount}
        </span>

        <div className="flex items-center gap-3 sm:gap-4">
          <span
            aria-label="Round timer"
            className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight"
          >
            {tRound}
          </span>
          <span
            aria-label="Question timer"
            className="font-edit-undo text-white text-sm sm:text-base leading-[0.92] tracking-tight"
          >
            {tQuestion}
          </span>
        </div>
      </div>

      {/* Row 2: title */}
      <div className="flex flex-col items-center gap-0.5">
        <h1 className="font-edit-undo text-white text-3xl sm:text-4xl md:text-5xl leading-[0.92] tracking-tight text-center">
          {currentQuestion?.questionText ?? "—"}
        </h1>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/QuestionView.tsx ---
"use client";

import * as React from "react";
import Image from "next/image";
import { cn } from "@/lib/utils";
import { PixelButton } from "@/components/buttons/PixelButton";
import { useGameStore, type AnswerOption } from "@/stores/gameStore";

/** Shared cap so the image and buttons are exactly the same width */
const CONTENT_CAP = "max-w-[560px]";

/** Answer row palettes (gold, purple, blue, green) */
const PALETTES = [
  { bg: "#FFE8BA", border: "#FFC931", text: "#151515" },
  { bg: "#EFD6FF", border: "#B45CFF", text: "#151515" },
  { bg: "#D7EBFF", border: "#2E7DFF", text: "#151515" },
  { bg: "#D8FFF1", border: "#18DCA5", text: "#151515" },
] as const;

/** Keyboard shortcuts: 1..9 choose option (disabled when locked) */
function useOptionHotkeys(
  options: AnswerOption[] | undefined,
  onPick: (id: string) => void,
  locked: boolean
) {
  React.useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (locked || !options?.length) return;
      const n = Number(e.key);
      if (!Number.isNaN(n) && n >= 1 && n <= options.length) {
        onPick(options[n - 1].id);
      }
    }
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [options, onPick, locked]);
}

export default function QuestionView() {
  // ── Store selectors
  const currentQuestion = useGameStore((s) => s.currentQuestion);
  const currentQuestionIndex = useGameStore((s) => s.currentQuestionIndex);
  const totalQuestions = useGameStore((s) => s.totalQuestions);
  const questionTimer = useGameStore((s) => s.questionTimer);
  const selectedAnswer = useGameStore((s) => s.selectedAnswer);
  const selectAnswer = useGameStore((s) => s.selectAnswer);
  const gameState = useGameStore((s) => s.gameState);
  const roundTimer = useGameStore((s) => s.roundTimer);

  const locked = gameState !== "QUESTION_ACTIVE";
  const onPick = React.useCallback(
    (id: string) => {
      if (!locked) selectAnswer(id);
    },
    [locked, selectAnswer]
  );

  // Hotkeys must be unconditional
  useOptionHotkeys(currentQuestion?.options, onPick, locked);

  if (!currentQuestion) return null;

  // ── HUD bits for the lower UI
  const maxTime = 10; // store uses 10s per question
  const time =
    gameState === "QUESTION_ACTIVE"
      ? Math.max(0, questionTimer)
      : Math.max(0, roundTimer);
  const progress = Math.max(
    0,
    Math.min(1, (gameState === "QUESTION_ACTIVE" ? questionTimer : 0) / maxTime)
  );

  return (
    <section
      className="mx-auto w-full max-w-screen-sm px-4 pb-24 pt-6 animate-up"
      aria-live="polite"
    >
      {/* ───────── HUD (from your lower code) ───────── */}
      <div className="mb-3 flex items-center justify-between text-white">
        <div className="font-[family-name:var(--font-display)] text-sm tracking-wide">
          {String(currentQuestionIndex + 1).padStart(2, "0")}/
          {String(totalQuestions).padStart(2, "0")}
        </div>

        <div className="flex items-center gap-3">
          <div className="font-[family-name:var(--font-display)] text-sm tabular-nums">
            00:{String(time).padStart(2, "0")}
          </div>
          <div
            className="relative h-3 w-28 overflow-hidden rounded-full border border-black/40 bg-white/20"
            role="progressbar"
            aria-valuemin={0}
            aria-valuemax={maxTime}
            aria-valuenow={gameState === "QUESTION_ACTIVE" ? questionTimer : 0}
          >
            <div
              className="absolute inset-y-0 left-0 rounded-full"
              style={{
                width: `${progress * 100}%`,
                background: "linear-gradient(90deg,#FF7A3D 0%,#FFB36B 100%)",
              }}
            />
          </div>
        </div>
      </div>

      {/* Question text */}
      <h1 className="mb-5 text-center font-[family-name:var(--font-display)] text-4xl md:text-5xl">
        {currentQuestion.questionText}
      </h1>

      {/* Question image (defines width for buttons as well) */}
      <figure
        className={cn(
          "mx-auto mb-6 w-full overflow-hidden rounded-[18px] border border-white/10 bg-black/30",
          CONTENT_CAP
        )}
      >
        <Image
          src={currentQuestion.imageUrl}
          alt="Question image"
          width={1120}
          height={1120}
          className="h-auto w-full object-cover"
          priority
        />
      </figure>

      {/* Answers — EXACT same width as image via CONTENT_CAP */}
      <ul className={cn("mx-auto flex w-full flex-col gap-4", CONTENT_CAP)}>
        {currentQuestion.options.map((opt, idx) => {
          const isChosen = selectedAnswer === opt.id;
          const isCorrect =
            locked && opt.id === currentQuestion.correctAnswerId;

          const palette = PALETTES[idx] ?? PALETTES[PALETTES.length - 1];

          // Visual states:
          // - Before selection: enabled, normal thickness (4px)
          // - After selection: all disabled; chosen keeps full opacity + thicker pixel frame (6px)
          const borderWidth = isChosen ? 6 : 4;

          return (
            <li key={opt.id} className="min-w-0">
              <PixelButton
                backgroundColor={palette.bg}
                borderColor={palette.border}
                textColor={palette.text}
                borderWidth={borderWidth}
                disabled={locked}
                aria-pressed={isChosen}
                onClick={() => onPick(opt.id)}
                className={cn(
                  "w-full rounded-xl px-4 py-3 text-base sm:px-6 sm:py-4 sm:text-lg",
                  // chosen remains vivid even when disabled
                  isChosen && "disabled:opacity-100",
                  // optional correctness rings (no layout shift)
                  isCorrect && "ring-2 ring-[--color-success]",
                  isChosen && !isCorrect && "ring-2 ring-[--color-waffle-gold]"
                )}
              >
                <span className="truncate">{opt.text}</span>
              </PixelButton>
            </li>
          );
        })}
      </ul>

      {/* Submitted message */}
      <div
        className={cn(
          "mx-auto mt-6 text-center text-sm text-muted transition-opacity md:text-base",
          CONTENT_CAP,
          gameState === "ANSWER_SUBMITTED" ? "opacity-100" : "opacity-0"
        )}
        aria-live="polite"
      >
        Answer submitted! Wait for the next question…
      </div>
    </section>
  );
}

--- File: ./src/app/(authenticated)/game/_components/AvatarDiamond.tsx ---
import * as React from "react";
import Image from "next/image";

type Avatar = {
  id: string | number;
  src: string;
  alt?: string;
  // optional per-tile opacity (e.g. 0.2 / 0.6 / 0.7 like in the mock)
  opacity?: number;
};

type Props = {
  avatars: Avatar[]; // supply as many as you have; we’ll clip to capacity
  // visual controls
  cellMin?: number; // min outer square size
  cellMax?: number; // max outer square size
  gap?: number; // gap between squares
  className?: string;
};

/**
 * Renders a fixed “diamond” pattern:
 * rows: 5  | cols: 7
 * counts per row: 3,4,3,4,3 at columns [2,4,6] / [1,3,5,7] repeating.
 */
export function AvatarDiamond({
  avatars,
  cellMin = 32,
  cellMax = 54,
  gap = 8,
  className = "",
}: Props) {
  // where tiles live (1-based columns)
  const pattern: number[][] = [
    [2, 4, 6],
    [1, 3, 5, 7],
    [2, 4, 6],
    [1, 3, 5, 7],
    [2, 4, 6],
  ];
  const capacity = pattern.reduce((n, row) => n + row.length, 0);
  const data = avatars.slice(0, capacity); // clamp to visible capacity

  // compute per-slot metadata (row, col, avatar)
  const slots: { row: number; col: number; avatar?: Avatar }[] = [];
  let i = 0;
  pattern.forEach((cols, r) => {
    cols.forEach((c) => {
      slots.push({ row: r + 1, col: c, avatar: data[i++] });
    });
  });

  // CSS variables (responsive size)
  const style = {
    // outer cell size (34px in Figma -> responsive here)
    ["--cell" as keyof React.CSSProperties]: `clamp(${cellMin}px, 7.5vw, ${cellMax}px)`,
    // inner image size (30px in Figma)
    ["--tile" as keyof React.CSSProperties]: "calc(var(--cell) - 4px)",
    // gap
    ["--gap" as keyof React.CSSProperties]: `${gap}px`,
  };

  return (
    <div
      className={[
        "relative",
        // 7 equal columns, fixed 5 rows, with gaps
        "grid [grid-template-columns:repeat(7,var(--cell))] [grid-auto-rows:var(--cell)]",
        "gap-[var(--gap)]",
        className,
      ].join(" ")}
      style={style}
      aria-label="Avatar grid"
      role="grid"
    >
      {slots.map((slot) => (
        <div
          key={`${slot.row}-${slot.col}`}
          role="gridcell"
          // place item in the right row/column (1-based)
          className="relative"
          style={{
            gridColumnStart: slot.col,
            gridRowStart: slot.row,
            opacity: slot.avatar?.opacity ?? 1,
          }}
          aria-hidden={!slot.avatar}
        >
          <Tile avatar={slot.avatar} />
        </div>
      ))}
    </div>
  );
}

function Tile({ avatar }: { avatar?: Avatar }) {
  // empty slots are simply transparent (keeps the shape)
  if (!avatar) return <div className="w-[var(--cell)] h-[var(--cell)]" />;

  return (
    <div className="relative w-[var(--cell)] h-[var(--cell)]">
      {/* 30px image + 1px border on a 34px cell in the design */}
      <Image
        src={avatar.src}
        alt={avatar.alt ?? ""}
        width={30}
        height={30}
        className="absolute left-1 top-1 size-[var(--tile)] rounded-sm border border-[#464646] object-cover bg-[#F0F3F4]"
        draggable={false}
      />
      {/* 4 corner nubs (4x4, 1px inset from the edges) */}
      <span className="absolute left-0 top-0 size-1 bg-white/30" />
      <span className="absolute right-0 top-0 size-1 bg-white/30" />
      <span className="absolute right-0 bottom-0 size-1 bg-white/30" />
      <span className="absolute left-0 bottom-0 size-1 bg-white/30" />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/GameScreen.tsx ---
"use client";

import { useGameStore } from "@/stores/gameStore";
import CountdownView from "./CountdownView";
import QuestionView from "./QuestionView";
import LobbyView from "./LobbyView";

export default function GameScreen() {
  const gameState = useGameStore((s) => s.gameState);

  const view = (() => {
    switch (gameState) {
      case "ROUND_COUNTDOWN":
        return <CountdownView />;
      case "QUESTION_ACTIVE":
      case "ANSWER_SUBMITTED":
        return <QuestionView />;
      case "LOBBY":
        return <LobbyView />;
      default:
        return <LobbyView />;
    }
  })();

  return (
    // Full-bleed container; child views handle their own max-width & padding.
    <div className="w-full min-h-[100dvh] overflow-hidden bg-figmaYay">
      {view}
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/ChatDrawer.tsx ---
"use client";

import { useState, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Image from "next/image";
import { ForwardMessageIcon, MessageIcon } from "@/components/icons";
import { useGameStore } from "@/stores/gameStore";
import { useMiniUser } from "@/hooks/useMiniUser";

export default function ChatDrawer() {
  const [open, setOpen] = useState(false);
  const [newMessage, setNewMessage] = useState("");
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { messages, sendMessage } = useGameStore();
  const user = useMiniUser();
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, open]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    const trimmed = newMessage.trim();
    if (!trimmed || !user.fid) return;
    sendMessage(trimmed, {
      fid: user.fid,
      username: user.username,
      pfpUrl: user.pfpUrl,
    });
    setNewMessage("");
  };

  return (
    <>
      {/* Trigger Input */}
      <div
        className="absolute left-0 bottom-0 w-full mx-auto flex flex-row items-start px-4 pb-5 pt-3 gap-3 bg-[#0E0E0E] z-30"
        onClick={() => setOpen(true)}
      >
        <div className="flex flex-col justify-center items-start flex-grow bg-white/5 rounded-full px-5 py-3 gap-1">
          <input
            readOnly
            placeholder="Type..."
            className="bg-transparent font-brockmann font-medium text-[14px] leading-[130%] tracking-[-0.03em] text-white opacity-40 outline-none cursor-pointer w-20 min-w-[42px] h-[18px]"
          />
        </div>
      </div>

      {/* Drawer */}
      <AnimatePresence>
        {open && (
          <motion.div
            className="fixed inset-0 z-50 flex flex-col justify-end bg-black/60 backdrop-blur-md font-display"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={() => setOpen(false)}
          >
            <motion.div
              className="relative w-full mx-auto flex flex-col rounded-t-full bg-figmaYay noise h-[85vh] max-h-[90dvh] sm:max-h-[600px] min-h-[60dvh] overflow-hidden"
              style={{
                width: "100%",
                borderTopLeftRadius: "1.25rem",
                borderTopRightRadius: "1.25rem",
              }}
              initial={{ y: "100%" }}
              animate={{ y: 0 }}
              exit={{ y: "100%" }}
              transition={{ type: "spring", stiffness: 200, damping: 25 }}
              onClick={(e) => e.stopPropagation()}
            >
              {/* Header */}
              <div className="flex flex-row items-center justify-between px-4 pt-8 pb-3 border-b border-white/5 bg-[#191919] rounded-t-2xl font-body">
                <div className="flex flex-row items-center gap-2">
                  <MessageIcon />
                  <h2 className="font-pixel text-white text-lg md:text-xl select-none">
                    lobby CHAT
                  </h2>
                </div>
                <span className="font-pixel text-white text-base md:text-lg select-none">
                  00:10
                </span>
              </div>

              {/* Messages */}
              <div className="flex flex-col items-start gap-3 sm:gap-4 pb-4 pt-6 px-4 flex-1 min-h-0 overflow-y-scroll scrollbar-none w-full">
                {messages.map((msg, idx) => (
                  <div
                    key={msg.id}
                    className="flex flex-col items-start gap-2 w-full"
                    style={{ order: idx }}
                  >
                    <div className="flex flex-row items-center gap-1.5 sm:gap-2 min-h-5 mb-0.5">
                      <div className="w-5 h-5 rounded-full bg-gray-100 overflow-hidden flex items-center justify-center">
                        {msg.avatarUrl ? (
                          <Image
                            src={msg.avatarUrl}
                            alt={msg.username}
                            width={20}
                            height={20}
                            className="w-5 h-5 object-cover"
                          />
                        ) : (
                          <span className="text-gray-400 text-xs font-semibold">
                            {msg.username?.[0]?.toUpperCase() ?? "•"}
                          </span>
                        )}
                      </div>
                      <span className="ml-1 font-brockmann font-medium text-[0.92rem] leading-[130%] tracking-[-0.03em] text-white">
                        {msg.username}
                      </span>
                      <span className="mx-1 w-[0.28rem] h-[0.28rem] bg-[#D9D9D9] rounded-full inline-block" />
                      <span className="font-brockmann font-medium text-[0.72rem] leading-[130%] tracking-[-0.03em] text-[#99A0AE]">
                        {msg.time}
                      </span>
                    </div>

                    <div className="w-full bg-white/[0.10] border border-white/[0.03] rounded-[0px_0.75rem_0.75rem_0.75rem] px-4 py-3 flex flex-col justify-center">
                      <p className="font-brockmann font-medium text-base leading-[130%] tracking-[-0.03em] text-white break-words">
                        {msg.message}
                      </p>
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>

              {/* Input */}
              <form
                onSubmit={handleSubmit}
                className="absolute left-0 bottom-0 w-full flex flex-row items-center bg-[#0E0E0E] px-4 py-5 gap-3 border-t border-white/5"
                style={{
                  minHeight: "min(90px,12vh)",
                  maxHeight: "18vh",
                }}
              >
                <div className="flex items-center bg-white/5 rounded-full flex-1 px-5 py-3">
                  <input
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder="Type a comment"
                    className="flex-1 bg-transparent outline-none text-white placeholder-white/40 text-base font-brockmann"
                  />
                </div>
                <AnimatePresence>
                  {newMessage.trim() && (
                    <motion.button
                      type="submit"
                      className="ml-3 bg-[#1B8FF5] rounded-full w-10 h-10 flex items-center justify-center active:scale-95 transition-transform shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-400"
                      initial={{ scale: 0 }}
                      animate={{ scale: 1 }}
                      exit={{ scale: 0 }}
                    >
                      <ForwardMessageIcon />
                    </motion.button>
                  )}
                </AnimatePresence>
              </form>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}

--- File: ./src/app/(authenticated)/game/_components/CountdownView.tsx ---
"use client";

import { useEffect, useMemo } from "react";
import { useGameStore } from "@/stores/gameStore";
import ChatTickerOverlay from "./ChatTickerOverlay";
import ChatDrawer from "./ChatDrawer";

/** blue used in mocks */
const BLUE = "#1E8BFF";

export default function RoundCountdownStage() {
  const { gameState, roundTimer, tickRoundTimer } = useGameStore();

  // tick every 1s while in ROUND_COUNTDOWN
  useEffect(() => {
    if (gameState !== "ROUND_COUNTDOWN") return;
    // const id = setInterval(() => tickRoundTimer(), 1000);
    // return () => clearInterval(id);
  }, [gameState, tickRoundTimer]);

  const TOTAL = 15;
  const ratio = useMemo(
    () => Math.max(0, Math.min(1, roundTimer / TOTAL)),
    [roundTimer]
  );

  return (
    <div>
      <section className="mx-auto w-full max-w-screen-sm px-4 pt-10 pb-8">
        <p className="mb-6 text-center text-white/85">PLEASE WAIT</p>

        <h1
          className="mb-8 text-center font-bold leading-tight whitespace-nowrap overflow-hidden text-ellipsis"
          style={{
            fontSize: "clamp(1.15rem, 7vw, 2.5rem)",
            letterSpacing: "-0.03em",
          }}
        >
          NEXT&nbsp;ROUND&nbsp;IN
        </h1>

        <div className="grid place-items-center">
          <CountdownCircle total={TOTAL} ratio={ratio} />
        </div>

        <p className="mt-10 text-center text-muted text-lg font-display">
          Get ready for the next round!
        </p>
      </section>
      <section>
        <ChatTickerOverlay />
        <ChatDrawer />
      </section>
    </div>
  );
}

/* ——————————— visual countdown ring ——————————— */
function CountdownCircle({ total, ratio }: { total: number; ratio: number }) {
  // SVG geometry
  const size = 240; // px
  const stroke = 14;
  const r = (size - stroke) / 2;
  const c = 2 * Math.PI * r;

  // stroke animation (start at top)
  const dashOffset = c * (1 - ratio);
  const angle = 360 * ratio - 90; // -90 to start from top

  return (
    <div
      className="relative"
      style={{ width: size, height: size }}
      aria-label="Next round countdown"
      role="timer"
      aria-live="polite"
    >
      <svg
        width={size}
        height={size}
        viewBox={`0 0 ${size} ${size}`}
        className="block"
      >
        {/* track */}
        <circle
          cx={size / 2}
          cy={size / 2}
          r={r}
          fill="none"
          stroke="rgba(255,255,255,0.15)"
          strokeWidth={stroke}
        />
        {/* progress */}
        <g transform={`rotate(-90 ${size / 2} ${size / 2})`}>
          <circle
            cx={size / 2}
            cy={size / 2}
            r={r}
            fill="none"
            stroke={BLUE}
            strokeWidth={stroke}
            strokeLinecap="round"
            strokeDasharray={c}
            strokeDashoffset={dashOffset}
            style={{ transition: "stroke-dashoffset 1s linear" }}
          />
        </g>
      </svg>

      {/* orbiting dot */}
      <div
        className="absolute left-1/2 top-1/2"
        style={{
          transform: `translate(-50%, -50%) rotate(${angle}deg)`,
          transition: "transform 1s linear",
          width: size,
          height: size,
          pointerEvents: "none",
        }}
      >
        <span
          className="absolute block rounded-full"
          style={{
            width: stroke + 6,
            height: stroke + 6,
            background: BLUE,
            left: "50%",
            top: stroke / 2,
            transform: "translate(-50%, -50%)",
            boxShadow: "0 0 0 2px rgba(30,139,255,0.35)",
          }}
        />
      </div>

      {/* numeric value */}
      <div className="pointer-events-none absolute inset-0 grid place-items-center">
        <span
          className="text-[12vw] sm:text-7xl md:text-8xl lg:text-9xl font-bold leading-none text-white"
          style={{
            // This clamp makes font-size responsive in both directions
            fontSize: "clamp(2.5rem, 10vw, 7rem)",
          }}
        >
          {String(Math.ceil(total * ratio)).padStart(2, "0")}
        </span>
      </div>
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/_components/LobbyView.tsx ---
"use client";

import { Clock } from "@/components/icons";
import { AvatarDiamond } from "./AvatarDiamond";
import ChatDrawer from "./ChatDrawer";
import ChatTickerOverlay from "./ChatTickerOverlay";

export default function LobbyView() {
  const players = 125;

  return (
    /**
     * Root takes full height and acts as the positioning context for overlays.
     * Max width lives here, so the whole lobby sits within the game screen nicely.
     */
    <div className="relative mx-auto w-full max-w-screen-sm px-4 pt-6 pb-24 min-h-[100dvh] text-foreground flex flex-col">
      {/* Main scrollable column */}
      <section className="flex-1 flex flex-col items-center gap-3 overflow-y-auto w-full pt-16 pb-4">
        {/* Top bar */}
        <div className="flex w-full h-10 min-h-[38px] items-center justify-center gap-0.5 p-2 sm:p-3">
          {/* Title + clock */}
          <div className="order-0 flex h-7 sm:h-[28px] min-w-0 flex-1 flex-col justify-center gap-3.5 font-body">
            <div className="order-0 flex h-7 sm:h-[28px] min-w-0 w-full flex-row items-center gap-2">
              <span
                className="h-7 w-7 flex-none sm:h-[28px] sm:w-[28px]"
                aria-label="Countdown"
              >
                <Clock />
              </span>
              <span
                className="truncate pl-1 select-none text-white font-normal leading-[0.92] tracking-tight"
                style={{
                  fontSize: "clamp(1rem,4vw,1.6rem)",
                  letterSpacing: "-0.03em",
                }}
              >
                GAME STARTS IN
              </span>
            </div>
          </div>

          {/* Timer pill */}
          <div className="order-1 box-border z-0 flex h-10 min-w-[64px] w-[clamp(72px,20vw,110px)] max-w-[140px] flex-none flex-row items-center justify-center rounded-full border-2 border-[var(--color-neon-pink)] bg-transparent px-4 py-1 sm:px-5 sm:py-2">
            <span className="px-0 flex items-end justify-center w-full min-w-0 select-none not-italic text-center text-xs leading-[115%] text-[var(--color-neon-pink)]">
              24M 03s
            </span>
          </div>
        </div>

        {/* Prize copy */}
        <div className="flex w-full min-h-[6rem] flex-col items-center justify-end gap-1 pb-2.5">
          <p className="w-auto min-w-[60px] sm:min-w-[80px] select-none text-center font-display font-medium leading-[1.3] tracking-tight text-muted text-[0.95rem] sm:text-base md:text-lg">
            Current prize pool
          </p>
          <div className="flex min-h-[2.5rem] sm:min-h-[2.7rem] w-full items-center justify-center px-2 sm:px-4">
            <span className="block min-w-[70px] sm:min-w-[90px] select-none text-center font-body font-normal leading-[0.92] tracking-tight text-success text-[clamp(2rem,6vw,3rem)]">
              $2,500
            </span>
          </div>
        </div>

        {/* Avatar diamond */}
        <div className="w-full flex justify-center">
          <AvatarDiamond
            avatars={[
              { id: "1", src: "/images/avatars/a.png", alt: "Avatar 1" },
              { id: "2", src: "/images/avatars/b.png", alt: "Avatar 2" },
              { id: "3", src: "/images/avatars/c.png", alt: "Avatar 3" },
              {
                id: "4",
                src: "/images/avatars/d.png",
                alt: "Avatar 4",
                opacity: 0.2,
              },
              { id: "5", src: "/images/avatars/a.png", alt: "Avatar 5" },
              { id: "6", src: "/images/avatars/a.png", alt: "Avatar 6" },
              { id: "7", src: "/images/avatars/a.png", alt: "Avatar 7" },
              { id: "8", src: "/images/avatars/a.png", alt: "Avatar 8" },
              {
                id: "9",
                src: "/images/avatars/a.png",
                alt: "Avatar 9",
                opacity: 0.2,
              },
              { id: "10", src: "/images/avatars/a.png", alt: "Avatar 10" },
              { id: "11", src: "/images/avatars/a.png", alt: "Avatar 11" },
              { id: "12", src: "/images/avatars/a.png", alt: "Avatar 12" },
              { id: "13", src: "/images/avatars/a.png", alt: "Avatar 13" },
              { id: "14", src: "/images/avatars/a.png", alt: "Avatar 14" },
              { id: "15", src: "/images/avatars/a.png", alt: "Avatar 15" },
              { id: "16", src: "/images/avatars/a.png", alt: "Avatar 16" },
              {
                id: "17",
                src: "/images/avatars/a.png",
                alt: "Avatar 17",
                opacity: 0.2,
              },
            ]}
            cellMin={32}
            cellMax={54}
            gap={2}
            className="scale-95 sm:scale-100"
          />
        </div>

        {/* joined count */}
        <p className="mt-1 min-w-[120px] text-center font-display font-medium tracking-[-0.03em] text-muted text-[clamp(13px,4vw,16px)] leading-[130%]">
          {players} players have joined
        </p>
      </section>

      {/* bottom shadow mask (kept, anchored to root) */}
      <div className="pointer-events-none absolute left-0 right-0 bottom-[78px] h-28 w-full">
        <div
          className="absolute inset-0 opacity-0"
          style={{
            background:
              "linear-gradient(180deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0) 6%, #FFFFFF 100%)",
          }}
        />
        <div className="absolute inset-0 opacity-0" />
      </div>

      {/* overlays anchored to this view */}
      <ChatTickerOverlay
        className="bottom-[7.5rem] sm:bottom-36"
        maxItems={4}
      />
      <ChatDrawer />
    </div>
  );
}

--- File: ./src/app/(authenticated)/game/page.tsx ---
// src/app/(authenticated)/game/page.tsx
// Ensure user has invite code and ticket; otherwise redirect appropriately.

"use client";

import React, { useEffect } from "react";
import { useGameStore } from "@/stores/gameStore";
import CountdownView from "./_components/CountdownView";
import QuestionView from "./_components/QuestionView";
import LobbyView from "./_components/LobbyView";
import GameOverView from "./_components/GameOverView";
import { useMiniUser } from "@/hooks/useMiniUser";
import { useRouter } from "next/navigation";
import { useLobbyStore } from "@/stores/lobbyStore";

export default function GameScreen() {
  const router = useRouter();
  const gameState = useGameStore((s) => s.gameState);
  const gameId = useGameStore((s) => s.gameId);
  const user = useMiniUser();

  const { referralStatus, ticket } = useLobbyStore();

  // Redirect if missing invite code or ticket
  useEffect(() => {
    if (referralStatus !== "success") {
      router.replace("/lobby/invite-code");
    } else if (!ticket) {
      router.replace("/lobby/buy");
    }
  }, [referralStatus, ticket, router]);

  // Fetch messages if we have a valid game and user
  useEffect(() => {
    if (gameId && user.fid && user.username && user.pfpUrl) {
      useGameStore.getState().fetchMessages(gameId, {
        fid: user.fid,
        username: user.username,
        pfpUrl: user.pfpUrl,
      });
    } else {
      console.error("No user found");
    }
  }, [gameId, user]);

  const view = (() => {
    switch (gameState) {
      case "ROUND_COUNTDOWN":
        return <CountdownView />;
      case "QUESTION_ACTIVE":
      case "ANSWER_SUBMITTED":
        return <QuestionView />;
      case "GAME_OVER":
        return <GameOverView />;
      case "LOBBY":
      default:
        return <LobbyView />;
    }
  })();

  return (
    <div className="w-full min-h-[100dvh] overflow-hidden bg-figmaYay">
      {view}
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/_components/InviteFriendsDrawer.tsx ---
"use client";

import * as React from "react";
import { createPortal } from "react-dom";
import Image from "next/image";
import { CopyIcon, InviteFriendsIcon } from "@/components/icons";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

type Props = {
  open: boolean;
  code: string;
  onClose: () => void;
};

export function InviteFriendsDrawer({ open, code, onClose }: Props) {
  const [mounted, setMounted] = React.useState(false);
  const drawerRef = React.useRef<HTMLDivElement | null>(null);
  const [toast, setToast] = React.useState<string | null>(null);

  // drag
  const startY = React.useRef<number | null>(null);
  const [dragY, setDragY] = React.useState(0);
  const isDragging = startY.current !== null;

  React.useEffect(() => setMounted(true), []);

  // Lock scroll while open
  React.useEffect(() => {
    if (!open) {
      document.documentElement.style.overflow = "";
      return;
    }
    document.documentElement.style.overflow = "hidden";
    return () => {
      document.documentElement.style.overflow = "";
    };
  }, [open]);

  // esc to close
  React.useEffect(() => {
    if (!open) return;
    const onKey = (e: KeyboardEvent) => e.key === "Escape" && onClose();
    window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onClose]);

  // drag handlers
  const onPointerDown = (e: React.PointerEvent) => {
    startY.current = e.clientY;
    setDragY(0);
    drawerRef.current?.setPointerCapture(e.pointerId);
  };
  const onPointerMove = (e: React.PointerEvent) => {
    if (startY.current == null) return;
    const dy = Math.max(0, e.clientY - startY.current);
    setDragY(dy);
  };
  const onPointerUp = () => {
    if (startY.current == null) return;
    const dy = dragY;
    startY.current = null;
    setDragY(0);
    if (dy > 140) onClose();
  };

  const copy = async () => {
    try {
      await navigator.clipboard.writeText(code);
      setToast("Code copied!");
    } catch {
      setToast("Couldn’t copy");
    } finally {
      setTimeout(() => setToast(null), 1400);
    }
  };

  const share = async () => {
    const text = `Join me on Waffle — use my invite code: ${code}`;
    if (navigator.share) {
      try {
        await navigator.share({ title: "Waffle Invite", text });
        setToast("Invite shared!");
      } catch {
        /* dismissed */
      } finally {
        setTimeout(() => setToast(null), 1400);
      }
    } else {
      await copy();
    }
  };

  if (!mounted) return null;

  return createPortal(
    <>
      {/* Backdrop */}
      <div
        aria-hidden
        className={[
          "fixed inset-0 z-[80] bg-black/60 transition-opacity",
          open
            ? "opacity-100 pointer-events-auto"
            : "opacity-0 pointer-events-none",
        ].join(" ")}
        onClick={onClose}
      />

      {/* Drawer */}
      <section
        id="invite-friends-drawer"
        role="dialog"
        aria-modal="true"
        aria-label="Invite friends"
        className={[
          "fixed inset-x-0 bottom-0 z-[81]",
          open ? "pointer-events-auto" : "pointer-events-none",
        ].join(" ")}
      >
        <div
          ref={drawerRef}
          onPointerDown={onPointerDown}
          onPointerMove={onPointerMove}
          onPointerUp={onPointerUp}
          className={[
            "relative isolate", // keeps z layering correct
            "mx-auto w-full max-w-screen-sm",
            "rounded-t-[1.25rem] overflow-hidden", // ensures radius applies visually
            "border-t border-white/5",
            "bg-gradient-to-b from-[#1E1E1E] to-black",
            "shadow-[0_-20px_60px_rgba(0,0,0,.6)]",
            "transform transition-[transform,opacity] duration-300 ease-[cubic-bezier(.2,.8,.2,1)]",
            open && !isDragging
              ? "translate-y-0 opacity-100"
              : "translate-y-full opacity-0",
          ].join(" ")}
          style={
            isDragging
              ? {
                  transform: `translateY(${dragY}px)`,
                  opacity: Math.max(0.6, 1 - dragY / 800),
                }
              : undefined
          }
        >
          {/* Handle + Title */}
          <div
            className="
            relative border-b border-white/5 bg-[#191919]
            px-4 pb-3
            pt-6

          "
          >
            <div
              className="absolute left-1/2 top-3 h-1 w-9 -translate-x-1/2 rounded-full bg-white/40"
              aria-hidden
            />
            <div className="mx-auto flex w-full max-w-xs items-center justify-center gap-2">
              <InviteFriendsIcon className="h-6 w-6 text-waffle-yellow" />
              <h2
                className="font-edit-undo text-white leading-[1.15]"
                style={{ fontSize: "clamp(1.05rem, 3.7vw, 1.25rem)" }}
              >
                INVITE FRIENDS
              </h2>
            </div>
          </div>

          {/* Body */}
          <div className="mx-auto flex w-full max-w-xs flex-col gap-3.5 px-4 py-4">
            {/* Gift + code card */}
            <div
              className="
              rounded-2xl border border-white/10
              bg-[linear-gradient(90deg,rgba(255,255,255,0)_0%,rgba(255,201,49,.12)_100%)]
              flex flex-col items-center justify-center gap-3
              px-3 py-12 sm:py-14
            "
            >
              <Image
                src="/images/icons/gift.svg"
                alt="Gift"
                width={96}
                height={96}
                className="w-24 h-24 sm:w-28 sm:h-28"
                priority
              />
              <div className="mt-1.5 flex w-full flex-col items-center">
                <p
                  className="font-brockmann text-waffle-gray tracking-[-0.03em]"
                  style={{
                    fontSize: "clamp(0.95rem, 3vw, 1rem)",
                    lineHeight: "130%",
                  }}
                >
                  Your code is
                </p>
                <p
                  className="font-edit-undo text-white"
                  style={{
                    fontSize: "clamp(1.9rem, 6vw, 2.375rem)",
                    lineHeight: "1.3",
                  }}
                >
                  {code}
                </p>
              </div>
            </div>

            {/* Share button (white tile with yellow “pixel” shadow) */}
            <FancyBorderButton onClick={share} className="border-waffle-gold">
              SHARE INVITE
            </FancyBorderButton>

            {/* Copy row */}
            <button
              onClick={copy}
              className="inline-flex w-full items-center justify-center gap-2 rounded-xl py-2.5"
            >
              <CopyIcon />
              <span
                className="font-edit-undo text-[#00CFF2] tracking-[-0.02em]"
                style={{
                  fontSize: "clamp(1rem, 3.2vw, 1.125rem)",
                  lineHeight: "1.15",
                }}
              >
                COPY CODE
              </span>
            </button>
          </div>
        </div>
      </section>

      {/* Toast */}
      <div
        aria-live="polite"
        className={[
          "fixed inset-x-0 z-[82] flex justify-center transition-opacity duration-200",
          "bottom-[calc(env(safe-area-inset-bottom,0px)+88px)]",
          toast ? "opacity-100" : "opacity-0 pointer-events-none",
        ].join(" ")}
      >
        <div className="rounded-full bg-white/10 px-3 py-2 text-sm text-white backdrop-blur">
          {toast}
        </div>
      </div>
    </>,
    document.body
  );
}

--- File: ./src/app/(authenticated)/profile/_components/GameHistory.tsx ---
// Past Games Section
import { WaffleIcon, ZapIcon } from "@/components/icons";
import type { GameHistory } from "@/stores/profileStore";
import Link from "next/link";
import React from "react";

export function GameHistory({ gameHistory }: { gameHistory: GameHistory[] }) {
  return (
    <section aria-labelledby="past-games-heading" className="w-full">
      <div className="flex items-center justify-between mb-3.5 font-semibold">
        <h2
          id="past-games-heading"
          className="font-display font-medium text-muted tracking-[-0.03em]"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)", // ~14–16
            lineHeight: "130%",
          }}
        >
          Past games
        </h2>
        <Link
          href="/profile/history"
          className="font-display font-medium text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>

      {/* Show two items like the design; spacing scales with screen */}
      <ul className="space-y-2">
        {gameHistory.slice(0, 2).map((game) => (
          <li key={game.id}>
            <GameHistoryItem game={game} />
          </li>
        ))}
      </ul>
    </section>
  );
}

export const GameHistoryItem = ({ game }: { game: GameHistory }) => {
  const amount = "$" + game.winnings;

  return (
    <div
      className={[
        "flex items-center justify-between",
        "noise rounded-2xl border border-white/20 ",
        "p-3 sm:p-4",
      ].join(" ")}
    >
      {/* Left block: avatar-ish icon + name + score */}
      <div className="flex min-w-0 items-center gap-2 sm:gap-3">
        <div className="size-10 rounded-full bg-white/10 grid place-items-center shrink-0">
          <WaffleIcon aria-hidden className="text-waffle-yellow" />
        </div>

        <div className="min-w-0 flex flex-col gap-1">
          <p
            className="font-body truncate"
            style={{
              fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)", // ~18–20
              lineHeight: "100%",
              letterSpacing: "-0.03em",
            }}
          >
            {game.name}
          </p>

          <div className="mt-1 flex items-center gap-1">
            <span className="text-waffle-yellow" aria-hidden>
              <ZapIcon />
            </span>
            <span
              className="font-display font-medium text-white/90 tracking-[-0.03em]"
              style={{
                fontSize: "clamp(0.75rem, 1.1vw, 0.875rem)", // ~12–14
                lineHeight: "1rem",
              }}
            >
              {game.score}
            </span>
          </div>
        </div>
      </div>

      {/* Right block: winnings */}
      <p
        className={[
          "font-display font-medium whitespace-nowrap ml-3",
          game.winningsColor === "green" ? "text-success" : "text-muted",
        ].join(" ")}
        style={{
          fontSize: "clamp(1rem, 1.8vw, 1rem)", // ~16
          lineHeight: "1.2rem",
          letterSpacing: "-0.03em",
        }}
      >
        {amount}
      </p>
    </div>
  );
};

--- File: ./src/app/(authenticated)/profile/_components/ProfileCard.tsx ---
"use client";

import Image from "next/image";
import { UploadIcon } from "@/components/icons";

type ProfileCardProps = {
  username: string;
  streak: number;
  /** same URL is used for avatar + blurred bg */
  avatarUrl: string;
  onUpload?: () => void;
};

export function ProfileCard({
  username,
  streak,
  avatarUrl,
  onUpload,
}: ProfileCardProps) {
  return (
    <section
      className={[
        "relative overflow-hidden rounded-2xl border border-white/10",
        "px-3 py-3 sm:px-4 sm:py-3.5",
        // gold tint like the figma
        // "bg-[linear-gradient(90deg,rgba(255,255,255,0)_0%,rgba(255,201,49,0.12)_100%)]",
      ].join(" ")}
      aria-label={`${username} profile`}
    >
      {/* background: same as avatar, soft/blurred */}
      <div aria-hidden className="absolute inset-0 -z-10">
        <Image
          src={avatarUrl}
          alt=""
          fill
          className="object-cover object-center opacity-70 blur-[18px] scale-125"
          priority
        />
        {/* subtle vignette so text pops */}
        <div className="absolute inset-0 bg-gradient-to-r from-black/10 via-transparent to-black/20" />
      </div>

      {/* row: upload • centered identity • spacer */}
      <div className="flex items-start justify-between gap-2">
        {/* upload button (left) */}
        <button
          onClick={onUpload}
          aria-label="Upload"
          className={[
            "grid size-9 place-items-center rounded-full bg-white/15",
            "transition-opacity hover:opacity-80 focus:outline-none focus:ring-2 focus:ring-white/30",
          ].join(" ")}
        >
          <UploadIcon className="h-[18px] w-[18px] text-white" />
        </button>

        {/* center block */}
        <div className="flex min-w-0 flex-col items-center gap-3">
          {/* avatar + name */}
          <div className="flex items-center gap-2">
            <Image
              src={avatarUrl}
              alt={`${username} avatar`}
              width={36}
              height={36}
              className="h-9 w-9 rounded-full bg-[#FFF7B8] ring-2 ring-black/20"
              priority
            />
            <span
              className="font-body text-white tracking-tight"
              style={{ fontSize: "clamp(1.05rem,2.6vw,1.25rem)" }}
            >
              {username}
            </span>
          </div>

          {/* streak block */}
          <div className="flex flex-col items-center gap-1">
            <span
              className="font-display text-white/95"
              style={{
                fontSize: "clamp(.85rem,2vw,1rem)",
                letterSpacing: "-0.03em",
              }}
            >
              Streak
            </span>
            <div className="flex items-center gap-2">
              <Image
                src="/images/icons/streak-flame.svg"
                alt=""
                width={20}
                height={36}
                className="h-9 w-5 object-contain"
              />
              <span
                className="font-body text-foreground leading-none"
                style={{ fontSize: "clamp(1.75rem,4.6vw,2.25rem)" }}
              >
                {streak}
              </span>
            </div>
          </div>
        </div>

        {/* right spacer (keeps center truly centered) */}
        <div className="pointer-events-none size-9 opacity-0">
          <UploadIcon className="h-[18px] w-[18px]" />
        </div>
      </div>
    </section>
  );
}

--- File: ./src/app/(authenticated)/profile/_components/Stats.tsx ---
// Stats Section
import { GamePadIcon, WinningsIcon, WinsIcon } from "@/components/icons";
import Link from "next/link";
import React from "react";

type StatCardProps = {
  icon: React.ReactNode;
  label: string;
  value: number | string;
};

export function Stats({
  stats,
}: {
  stats: { games: number; wins: number; winnings: number };
}) {
  return (
    <section aria-labelledby="stats-heading" className="w-full ">
      <div className="flex items-center justify-between mb-3.5 font-semibold">
        <h2
          id="stats-heading"
          className="font-display text-muted tracking-[-0.03em]"
          style={{
            // ~14–16px depending on width, 130% line-height
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          Stats
        </h2>
        <Link
          href="/profile/stats"
          className="font-display text-waffle-gold tracking-[-0.03em] hover:underline"
          style={{
            fontSize: "clamp(0.875rem, 1.5vw, 1rem)",
            lineHeight: "130%",
          }}
        >
          View all
        </Link>
      </div>

      {/* Always 3 cards like the design, but fluid widths & spacing */}
      <div className="grid grid-cols-3 gap-2">
        <StatCard icon={<GamePadIcon />} label="Games" value={stats.games} />
        <StatCard icon={<WinsIcon />} label="Wins" value={stats.wins} />
        <StatCard
          icon={<WinningsIcon />}
          label="Winnings"
          value={stats.winnings}
        />
      </div>
    </section>
  );
}

export const StatCard = ({ icon, label, value }: StatCardProps) => (
  <div
    className={[
      "flex-1",
      "flex flex-col justify-between",

      "noise ",
      "rounded-2xl border border-white/20 ",
      "p-3 sm:p-4 gap-5",
      // keep heights visually consistent without hardcoding 74px
      "min-h-[3.75rem] sm:min-h-[4.25rem]",
    ].join(" ")}
  >
    <p
      className="font-display font-medium text-muted tracking-[-0.03em]"
      style={{
        // ~13–14px fluid label, 130% line-height
        fontSize: "clamp(0.8125rem, 1.3vw, 0.875rem)",
        lineHeight: "130%",
      }}
    >
      {label}
    </p>

    <div className="flex items-center gap-1">
      {/* icon inherits the yellow from the design */}
      <span className="shrink-0 text-waffle-yellow" aria-hidden>
        {icon}
      </span>
      <p
        className="font-body leading-none"
        style={{
          // ~20px value on small, scales up slightly; 100% line-height like Figma
          fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)",
          lineHeight: "100%",
          letterSpacing: "-0.03em",
        }}
      >
        {value}
      </p>
    </div>
  </div>
);

--- File: ./src/app/(authenticated)/profile/history/page.tsx ---
// app/profile/history/page.tsx
"use client";

import Link from "next/link";
import { useProfileStore } from "@/stores/profileStore";
import { BottomNav } from "@/components/BottomNav";
import LogoIcon from "@/components/logo/LogoIcon";
import {
  ArrowLeftIcon,
  WalletIcon,
  WaffleIcon,
  ZapIcon,
} from "@/components/icons";
import type { GameHistory } from "@/stores/profileStore";
/* ---------- Top bar (shared look) ---------- */
const TopBar = () => (
  <header
    className={`
      sticky top-0 z-10 w-full
      border-b border-[color:var(--surface-stroke)]
      bg-[color:var(--brand-ink-900)]
    `}
  >
    <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
      <LogoIcon />
      <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
        <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
        <span
          className="text-center text-[color:var(--text-primary)] font-display"
          style={{
            fontSize: "clamp(.95rem,1.9vw,1rem)",
            lineHeight: "1.1",
          }}
        >
          $983.23
        </span>
      </div>
    </div>
  </header>
);

/* ---------- Sub-page header ---------- */
const SubPageHeader = ({ title }: { title: string }) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    <Link
      href="/profile"
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80"
      aria-label="Back"
    >
      <ArrowLeftIcon />
    </Link>

    <h1
      className="flex-grow text-center text-white font-body"
      style={{
        fontWeight: 400,
        fontSize: "clamp(1.25rem,4.5vw,1.375rem)", // ~22px target
        lineHeight: ".92",
        letterSpacing: "-0.03em",
      }}
    >
      {title}
    </h1>

    {/* spacer to balance back button */}
    <div className="h-[34px] w-[34px]" />
  </div>
);

/* ---------- List item ---------- */

const GameHistoryItem = ({ game }: { game: GameHistory }) => (
  <div
    className={`
      flex items-center justify-between
      rounded-2xl border border-white/20 bg-transparent
      p-3 sm:p-4
    `}
  >
    <div className="flex min-w-0 items-center gap-2 sm:gap-3">
      <div className="grid size-10 shrink-0 place-items-center rounded-full bg-white/10">
        <WaffleIcon aria-hidden />
      </div>

      <div className="min-w-0">
        <p
          className="truncate text-white font-body"
          style={{
            fontSize: "clamp(1.125rem, 2.2vw, 1.25rem)", // ~18–20
            lineHeight: "1",
            letterSpacing: "-0.03em",
          }}
        >
          {game.name}
        </p>

        <div className="mt-1 flex items-center gap-1">
          <span className="text-waffle-yellow" aria-hidden>
            <ZapIcon />
          </span>
          <span
            className="tracking-[-0.03em] text-white/90 font-display"
            style={{
              fontWeight: 500,
              fontSize: "clamp(.75rem,1.2vw,.875rem)", // ~12–14
              lineHeight: "1rem",
            }}
          >
            {game.score}
          </span>
        </div>
      </div>
    </div>

    <p
      className={`ml-3 whitespace-nowrap tracking-[-0.03em] font-display ${
        game.winningsColor === "green" ? "text-success" : "text-muted"
      }`}
      style={{
        fontWeight: 500,
        fontSize: "clamp(1rem,1.8vw,1rem)", // ~16
        lineHeight: "1.2rem",
      }}
    >
      ${game.winnings.toFixed(2)}
    </p>
  </div>
);

/* ---------- Page ---------- */
export default function GameHistoryPage() {
  const { gameHistory } = useProfileStore();

  return (
    <div
      className={`
        min-h-screen flex flex-col
        bg-[linear-gradient(180deg,#1E1E1E_0%,#000_100%)]
        text-[color:var(--text-primary)]
      `}
    >
      <TopBar />
      <SubPageHeader title="GAME HISTORY" />

      <main
        className={`
          mx-auto w-full max-w-lg
          px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          mt-4
        `}
      >
        {/* List */}
        <ul className="flex flex-col gap-3.5 sm:gap-4">
          {gameHistory.map((g) => (
            <li key={g.id}>
              <GameHistoryItem game={g} />
            </li>
          ))}
        </ul>
      </main>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/page.tsx ---
"use client";

import {
  ArrowRightIcon,
  InviteFriendsIcon,
  UploadIcon,
  WalletIcon,
} from "@/components/icons";
import { useProfileStore } from "@/stores/profileStore";
import { GameHistory } from "./_components/GameHistory";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";
import { ProfileCard } from "./_components/ProfileCard";
import { Stats } from "./_components/Stats";
import { InviteFriendsDrawer } from "./_components/InviteFriendsDrawer";
import { useState } from "react";

export default function ProfilePage() {
  const { username, streak, stats, gameHistory } = useProfileStore();
  const [inviteOpen, setInviteOpen] = useState(false);
  const inviteCode = "EVWE";

  return (
    <div className="min-h-screen flex flex-col bg-figmaYay noise ">
      {/* Header */}
      <header className="sticky top-0 z-10 w-full border-b border-white/20 px-4 py-3">
        <div className="mx-auto max-w-screen-sm flex w-full items-center justify-between">
          <div className="flex min-w-0 flex-row items-center justify-center">
            <LogoIcon />
          </div>
          <div className="flex items-center">
            <div className="flex h-7 min-w-[64px] flex-row items-center gap-2 rounded-full bg-white/10 px-3 py-1.5">
              <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
              <span
                className="font-edit-undo leading-[1.1] text-[color:var(--text-primary)] text-center"
                style={{ fontSize: "clamp(0.95rem, 1.9vw, 1rem)" }}
              >
                $983.23
              </span>
            </div>
          </div>
        </div>
      </header>

      {/* Main */}
      <main
        className="
          mx-auto w-full max-w-screen-sm px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          flex flex-col gap-6 sm:gap-8 pt-4
        "
      >
        {/* Title bar */}
        <div className="flex items-center justify-between">
          <button
            aria-label="Upload"
            className="flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full p-1 opacity-0"
          >
            <UploadIcon className="h-3.5 w-3.5" />
          </button>

          <h1
            className="font-edit-undo font-normal tracking-tight text-white leading-[0.92] text-center select-none"
            style={{
              fontSize: "clamp(1.2rem, 4vw, 1.375rem)",
              letterSpacing: "-0.03em",
            }}
          >
            PROFILE
          </h1>

          {/* ✨ Wire the icon to open the drawer */}
          <button
            onClick={() => setInviteOpen(true)}
            aria-label="Invite Friends"
            className="box-border flex h-8 w-8 flex-shrink-0 items-center justify-center rounded-full bg-white/15 p-2 transition-opacity hover:opacity-80"
          >
            <InviteFriendsIcon className="h-[18px] w-[18px]" />
          </button>
        </div>

        <ProfileCard
          username={username}
          streak={streak}
          avatarUrl="/images/avatars/a.png"
          onUpload={() => {
            /* open picker */
          }}
        />

        {/* Big invite CTA */}
        <button
          onClick={() => setInviteOpen(true)}
          className="
            flex flex-row items-center justify-between
            w-full max-w-screen-sm min-h-[64px] h-[74px]
            mx-auto px-3 sm:px-4 box-border gap-3 rounded-[16px]
            border border-white/40 transition-transform hover:scale-[1.02]
            bg-[#FFC931] bg-blend-overlay
            [background:linear-gradient(189.66deg,rgba(0,0,0,0)_-6.71%,rgba(0,0,0,0.8)_92.73%),_#FFC931]
          "
          aria-haspopup="dialog"
          aria-controls="invite-friends-drawer"
        >
          <span
            className="font-normal text-[clamp(1.08rem,2.7vw,1.31rem)] leading-[1.3] text-foreground tracking-tight select-none px-2"
            style={{ letterSpacing: "-0.03em", fontWeight: 400 }}
          >
            INVITE FRIENDS
          </span>
          <div className="flex items-center justify-center w-[34px] h-[34px] rounded-full bg-white/15 flex-shrink-0 p-0.5 ml-2">
            <ArrowRightIcon className="w-[18px] h-[18px]" />
          </div>
        </button>

        <div className="mt-2">
          <Stats stats={stats} />
        </div>

        <div className="mt-4">
          <GameHistory gameHistory={gameHistory} />
        </div>
      </main>

      <BottomNav />

      {/* Drawer */}
      <InviteFriendsDrawer
        open={inviteOpen}
        code={inviteCode}
        onClose={() => setInviteOpen(false)}
      />
    </div>
  );
}

--- File: ./src/app/(authenticated)/profile/stats/page.tsx ---
"use client";

import { useProfileStore } from "@/stores/profileStore";
import Link from "next/link";
import Image from "next/image";
import { ArrowLeftIcon, WalletIcon } from "@/components/icons";
import LogoIcon from "@/components/logo/LogoIcon";
import { BottomNav } from "@/components/BottomNav";

/* ---------- Header (same style as other profile screens) ---------- */
const TopBar = () => (
  <header
    className={`
      sticky top-0 z-10 w-full
      border-b border-[color:var(--surface-stroke)]
      bg-[color:var(--brand-ink-900)]
    `}
  >
    <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 py-3">
      <LogoIcon />
      <div className="flex items-center gap-1.5 rounded-full bg-white/10 px-3 py-1.5">
        <WalletIcon className="h-4 w-4 text-[color:var(--text-primary)]" />
        <span
          className="text-center text-[color:var(--text-primary)]"
          style={{
            fontFamily: "Edit Undo BRK",
            fontSize: "clamp(.95rem,1.9vw,1rem)",
            lineHeight: "1.1",
          }}
        >
          $983.23
        </span>
      </div>
    </div>
  </header>
);

/* ---------- Sub page header ---------- */
const SubPageHeader = ({ title }: { title: string }) => (
  <div className="mx-auto flex w-full max-w-lg items-center justify-between px-4 pt-4">
    <Link
      href="/profile"
      className="flex h-[34px] w-[34px] items-center justify-center rounded-full bg-white/15 transition-opacity hover:opacity-80"
      aria-label="Back"
    >
      <ArrowLeftIcon />
    </Link>

    <h1
      className="font-body flex-grow text-center text-white"
      style={{
        fontWeight: 400,
        fontSize: "clamp(0.94rem, 3vw, 0.98rem)", // ~15px target
        lineHeight: ".92",
        letterSpacing: "-0.03em",
      }}
    >
      {title}
    </h1>

    {/* spacer to balance the back button */}
    <div className="h-[34px] w-[34px]" />
  </div>
);

/* ---------- Stat atoms ---------- */
const LargeStat = ({
  label,
  value,
}: {
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-2">
    <p
      className="text-muted font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem,2.8vw,1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>
    <p
      className="text-white font-body"
      style={{
        fontSize: "clamp(1.15rem,4vw,1.25rem)", // ~20px target
        lineHeight: "1",
      }}
    >
      {value}
    </p>
  </div>
);

const IconStat = ({
  icon,
  label,
  value,
}: {
  icon: string;
  label: string;
  value: string | number;
}) => (
  <div className="flex flex-col items-center justify-center gap-1">
    <Image
      src={icon}
      alt={label}
      width={36}
      height={36}
      className="h-9 w-9"
      sizes="(max-width: 420px) 36px, 36px"
      priority
    />
    <p
      className="text-waffle-gray text-center font-display"
      style={{
        fontWeight: 500,
        fontSize: "clamp(.9rem,2.8vw,1rem)",
        lineHeight: "1.3",
        letterSpacing: "-0.03em",
      }}
    >
      {label}
    </p>
    <p
      className="text-white leading-none font-body"
      style={{
        fontSize: "clamp(1.15rem,4vw,1.25rem)", // ~20px target
        lineHeight: "1",
      }}
    >
      {value}
    </p>
  </div>
);

/* ---------- Page ---------- */
export default function AllTimeStatsPage() {
  const { allTimeStats } = useProfileStore();

  return (
    <div
      className={`
        min-h-screen flex flex-col
        bg-figmaYay
        noise
      `}
    >
      <TopBar />
      <SubPageHeader title="ALL-TIME STATS" />

      <main
        className={`
          mx-auto w-full max-w-lg
          px-4
          pb-[calc(env(safe-area-inset-bottom)+84px)]
          flex flex-col
          gap-5 sm:gap-6
          mt-4
        `}
      >
        {/* ---- Block 1: Totals ---- */}
        <section
          className={`
            rounded-2xl border border-white/20
            p-4 sm:p-5
          `}
        >
          <div
            className={`
              grid grid-cols-2
              gap-x-4 gap-y-4 sm:gap-y-6
              justify-items-center
            `}
          >
            <LargeStat label="Total games" value={allTimeStats.totalGames} />
            <LargeStat label="Wins" value={allTimeStats.wins} />
            <LargeStat label="Win rate" value={allTimeStats.winRate} />
            <LargeStat label="Total won" value={allTimeStats.totalWon} />
          </div>
        </section>

        {/* ---- Block 2: Icon stats ---- */}
        <section
          className={`
            rounded-2xl border border-white/20
            p-4 sm:p-5
          `}
        >
          <div
            className={`
              grid grid-cols-2
              gap-x-6 gap-y-6 sm:gap-y-8
              justify-items-center
            `}
          >
            <IconStat
              icon="/images/icons/trophy.svg"
              label="Highest score"
              value={allTimeStats.highestScore}
            />
            <IconStat
              icon="/images/icons/average.svg"
              label="Average score"
              value={allTimeStats.averageScore}
            />
            <IconStat
              icon="/images/icons/streak-flame.svg"
              label="Current streak"
              value={allTimeStats.currentStreak}
            />
            <IconStat
              icon="/images/icons/rank.svg"
              label="Best rank"
              value={allTimeStats.bestRank}
            />
          </div>
        </section>
      </main>

      <BottomNav />
    </div>
  );
}

--- File: ./src/app/layout.tsx ---
import DeviceGate from "@/components/DeviceGate";
import "./globals.css";
import { fontBody, fontDisplay, fontInput } from "@/lib/fonts";
import "./globals.css";

import { MinikitProvider } from "@/components/providers/MinikitProvider";
import GlobalToaster from "@/components/ui/Toaster";
import { Metadata } from "next";
import { env } from "@/lib/env";
import { OnboardingGate } from "@/components/onboarding/OnboardingGate";

export async function generateMetadata(): Promise<Metadata> {
  return {
    other: {
      "fc:miniapp": JSON.stringify({
        version: "next",
        imageUrl: `${env.rootUrl}/logo.png`,
        button: {
          title: "Waffles",
          action: {
            type: "launch_miniapp",
            name: "Waffles",
            url: env.rootUrl,
            splashImageUrl: `${env.rootUrl}/images/splash-icon.png`,
            splashBackgroundColor: "#000000",
          },
        },
      }),
    },
  };
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html
      lang="en"
      className={`${fontBody.variable} ${fontDisplay.variable} ${fontInput.variable}`}
    >
      <body className="text-foreground bg-figma noise">
        <DeviceGate continueAnyway={process.env.NODE_ENV == "production"}>
          <MinikitProvider>
            <OnboardingGate>{children}</OnboardingGate>
          </MinikitProvider>
        </DeviceGate>
        <GlobalToaster />
      </body>
    </html>
  );
}

--- File: ./src/app/api/tickets/verify/route.ts ---
import { NextResponse } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/tickets/verify
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json(
      { valid: false, message: "Unauthorized" },
      { status: 401 }
    );
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json(
      { valid: false, message: "User not found" },
      { status: 404 }
    );
  }
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json(
      { valid: false, message: "Missing gameId" },
      { status: 400 }
    );
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json(
      { valid: false, message: "Invalid gameId" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId },
  });
  if (!ticket) {
    return NextResponse.json({ valid: false, message: "Ticket not found" });
  }
  return NextResponse.json({ valid: true });
}

--- File: ./src/app/api/tickets/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { PrismaClient } from "@prisma/client";
import { randomBytes } from "crypto";

const prisma = new PrismaClient();

// GET /api/tickets
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const tickets = await prisma.ticket.findMany({
    where: { userId: user.id },
    include: { game: true },
  });
  const result = tickets.map((ticket) => ({
    ticketId: ticket.id,
    gameId: ticket.gameId,
    gameTitle: ticket.game.name,
    code: ticket.code,
    amountUSDC: ticket.amountUSDC,
    purchasedAt: ticket.purchasedAt,
  }));
  return NextResponse.json(result);
}

// POST /api/tickets
export async function POST(request: Request) {
  const schema = z.object({
    typeId: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { typeId } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  // Find game by slug or typeId
  const game = await prisma.game.findUnique({
    where: { id: parseInt(typeId, 10) },
  });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const now = new Date();
  if (game.startTime && now >= game.startTime) {
    return NextResponse.json(
      { error: "Game has already started" },
      { status: 400 }
    );
  }
  const existing = await prisma.ticket.findFirst({
    where: { userId: user.id, gameId: game.id },
  });
  if (existing) {
    return NextResponse.json(
      { error: "Ticket already purchased" },
      { status: 400 }
    );
  }
  const ticket = await prisma.ticket.create({
    data: {
      userId: user.id,
      gameId: game.id,
      amountUSDC: 50,
      code: randomBytes(4).toString("hex").toUpperCase(),
      txHash: null,
      status: "pending",
    },
  });
  return NextResponse.json({
    ticketId: ticket.id,
    waffleType: game.name,
    message: "Purchase successful",
  });
}

--- File: ./src/app/api/tickets/buy/route.ts ---
import { prisma } from "@/lib/db";
import { randomBytes } from "crypto";

export async function POST(req: Request) {
  try {
    const { userId, gameId, amount, txHash } = await req.json();
    if (!userId || !gameId || !amount)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const code = randomBytes(4).toString("hex").toUpperCase();

    const ticket = await prisma.ticket.create({
      data: {
        user: { connect: { id: userId } },
        game: { connect: { id: gameId } },
        gameId,
        amountUSDC: amount,
        code,
        txHash: txHash || null,
        status: txHash ? "confirmed" : "pending",
      },
    });

    return Response.json(ticket);
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/chat/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/chat?gameId=
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const url = new URL(request.url);
  const gameIdParam = url.searchParams.get("gameId");
  if (!gameIdParam) {
    return NextResponse.json({ error: "Missing gameId" }, { status: 400 });
  }
  const gameId = parseInt(gameIdParam, 10);
  if (isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid gameId" }, { status: 400 });
  }
  const messages = await prisma.chat.findMany({
    where: { gameId },
    include: { user: true },
    orderBy: { createdAt: "asc" },
  });
  const result = messages.map((msg) => ({
    messageId: msg.id,
    userId: msg.userId,
    userName: msg.user.name,
    message: msg.message,
    createdAt: msg.createdAt,
  }));
  return NextResponse.json(result);
}

// POST /api/chat
export async function POST(request: Request) {
  const schema = z.object({
    gameId: z.number(),
    message: z.string().min(1),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { gameId, message } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId: farcasterId },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const game = await prisma.game.findUnique({ where: { id: gameId } });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  const chat = await prisma.chat.create({
    data: {
      userId: user.id,
      gameId,
      message,
    },
  });
  return NextResponse.json(chat);
}

--- File: ./src/app/api/config/game/[gameId]/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";
import { type Prisma } from "@prisma/client";

// Define enum and config schema as before
const prizePoolTypeEnum = z.enum(["FIXED", "DYNAMIC"]);

const baseConfigSchema = z.object({
  roundTimeLimit: z.number().int().positive().max(3600).optional(),
  questionsPerGame: z.number().int().positive().max(200).optional(),
  scoreMultiplier: z.number().positive().max(100).optional(),
  scorePenalty: z.number().min(-1000).max(0).nullable().optional(),
  maxPlayers: z.number().int().positive().max(100000).optional(),
  soundEnabled: z.boolean().optional(),
  animationEnabled: z.boolean().optional(),
  prizePoolType: prizePoolTypeEnum.optional(),
  prizePoolFixedAmount: z.number().int().nonnegative().nullable().optional(),
  prizePoolDynamicTickets: z.number().int().nonnegative().nullable().optional(),
  timeBonusEnabled: z.boolean().optional(),
  difficultyScaling: z.number().positive().max(10).optional(),
});

// Helper: authorization for PUT (admins only)
function isAuthorizedAdmin(request: NextRequest): boolean {
  const headerToken = request.headers.get("x-admin-token");
  const envToken = process.env.ADMIN_TOKEN;
  return Boolean(envToken && headerToken && headerToken === envToken);
}

// --- TYPE FIX: Next.js expects "params" to be a Promise in context ---
// See type error in build output (params: Promise<{ gameId: string; }>;)
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ gameId: string }> }
) {
  try {
    const resolvedParams = await context.params;
    const gameId = Number(resolvedParams.gameId);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid gameId" }, { status: 400 });
    }

    const game = await prisma.game.findUnique({ where: { id: gameId } });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const config = await prisma.gameConfig.findUnique({ where: { gameId } });
    return NextResponse.json(config ?? null);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: NextRequest,
  context: { params: Promise<{ gameId: string }> }
) {
  try {
    if (!isAuthorizedAdmin(request)) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    const resolvedParams = await context.params;
    const gameId = Number(resolvedParams.gameId);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid gameId" }, { status: 400 });
    }

    let body: unknown;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
    }
    const parsed = baseConfigSchema.safeParse(body);
    if (!parsed.success) {
      return NextResponse.json({ error: "Invalid input" }, { status: 400 });
    }

    const game = await prisma.game.findUnique({ where: { id: gameId } });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const existing = await prisma.gameConfig.findUnique({ where: { gameId } });
    const data = {
      ...parsed.data,
      gameId,
    } as Prisma.GameConfigUncheckedUpdateInput;
    let updated;
    if (!existing) {
      updated = await prisma.gameConfig.create({
        data: data as Prisma.GameConfigCreateInput,
      });
    } else {
      updated = await prisma.gameConfig.update({ where: { gameId }, data });
    }
    return NextResponse.json(updated);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/config/global/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";
import { type Prisma } from "@prisma/client";
const prizePoolTypeEnum = z.enum(["FIXED", "DYNAMIC"]);

const baseConfigSchema = z.object({
  roundTimeLimit: z.number().int().positive().max(3600).optional(),
  questionsPerGame: z.number().int().positive().max(200).optional(),
  scoreMultiplier: z.number().positive().max(100).optional(),
  scorePenalty: z.number().min(-1000).max(0).nullable().optional(),
  maxPlayers: z.number().int().positive().max(100000).optional(),
  soundEnabled: z.boolean().optional(),
  animationEnabled: z.boolean().optional(),
  prizePoolType: prizePoolTypeEnum.optional(),
  prizePoolFixedAmount: z.number().int().nonnegative().nullable().optional(),
  prizePoolDynamicTickets: z.number().int().nonnegative().nullable().optional(),
  timeBonusEnabled: z.boolean().optional(),
  difficultyScaling: z.number().positive().max(10).optional(),
});

function isAuthorizedAdmin(request: Request): boolean {
  const headerToken = request.headers.get("x-admin-token");
  const envToken = process.env.ADMIN_TOKEN;
  return Boolean(envToken && headerToken && headerToken === envToken);
}

export async function GET() {
  try {
    let config = await prisma.globalConfig.findFirst();
    if (!config) {
      // Ensure there is always a global config row
      config = await prisma.globalConfig.create({
        data: {
          roundTimeLimit: 60,
          questionsPerGame: 10,
          scoreMultiplier: 1,
          scorePenalty: null,
          maxPlayers: 1000,
          soundEnabled: true,
          animationEnabled: true,
          prizePoolType: "FIXED",
          prizePoolFixedAmount: null,
          prizePoolDynamicTickets: null,
          timeBonusEnabled: false,
          difficultyScaling: 1,
        },
      });
    }
    return NextResponse.json(config);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

export async function PUT(request: Request) {
  try {
    if (!isAuthorizedAdmin(request)) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }

    let body: unknown;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
    }

    const parsed = baseConfigSchema.safeParse(body);
    if (!parsed.success) {
      return NextResponse.json({ error: "Invalid input" }, { status: 400 });
    }

    const existing = await prisma.globalConfig.findFirst();
    let updated;
    if (!existing) {
      updated = await prisma.globalConfig.create({
        data: parsed.data as Prisma.GlobalConfigCreateInput,
      });
    } else {
      updated = await prisma.globalConfig.update({
        where: { id: existing.id },
        data: parsed.data as Prisma.GlobalConfigUncheckedUpdateInput,
      });
    }
    return NextResponse.json(updated);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/auth/route.ts ---
import { Errors, createClient } from "@farcaster/quick-auth";
import { NextRequest, NextResponse } from "next/server";

const client = createClient();

// Helper function to determine the correct domain for JWT verification
function getUrlHost(request: NextRequest): string {
  // First try to get the origin from the Origin header (most reliable for CORS requests)
  const origin = request.headers.get("origin");
  if (origin) {
    try {
      const url = new URL(origin);
      return url.host;
    } catch (error) {
      console.warn("Invalid origin header:", origin, error);
    }
  }

  // Fallback to Host header
  const host = request.headers.get("host");
  if (host) {
    return host;
  }

  // Final fallback to environment variables (your original logic)
  let urlValue: string;
  if (process.env.VERCEL_ENV === "production") {
    urlValue = process.env.NEXT_PUBLIC_URL!;
  } else if (process.env.VERCEL_URL) {
    urlValue = `https://${process.env.VERCEL_URL}`;
  } else {
    urlValue = "http://localhost:3000";
  }

  const url = new URL(urlValue);
  return url.host;
}

export async function GET(request: NextRequest) {
  // Because we're fetching this endpoint via `sdk.quickAuth.fetch`,
  // if we're in a mini app, the request will include the necessary `Authorization` header.
  const authorization = request.headers.get("Authorization");

  // Here we ensure that we have a valid token.
  if (!authorization || !authorization.startsWith("Bearer ")) {
    return NextResponse.json({ message: "Missing token" }, { status: 401 });
  }

  try {
    // Now we verify the token. `domain` must match the domain of the request.
    // In our case, we're using the `getUrlHost` function to get the domain of the request
    // based on the Vercel environment. This will vary depending on your hosting provider.
    const payload = await client.verifyJwt({
      token: authorization.split(" ")[1] as string,
      domain: getUrlHost(request),
    });

    console.log("payload", payload);

    // If the token was valid, `payload.sub` will be the user's Farcaster ID.
    const userFid = payload.sub;

    // Return user information for your waitlist application
    return NextResponse.json({
      success: true,
      user: {
        fid: userFid,
        issuedAt: payload.iat,
        expiresAt: payload.exp,
      },
    });

  } catch (e) {
    if (e instanceof Errors.InvalidTokenError) {
      return NextResponse.json({ message: "Invalid token" }, { status: 401 });
    }
    if (e instanceof Error) {
      return NextResponse.json({ message: e.message }, { status: 500 });
    }
    throw e;
  }
}
--- File: ./src/app/api/referrals/route.ts ---
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/referrals
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const user = await prisma.user.findUnique({
    where: { farcasterId },
    include: { referrals: { include: { invitee: true } } },
  });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }
  const referrals =
    user.referrals.map((ref) => ({
      inviteeId: ref.invitee?.id,
      inviteeFarcasterId: ref.invitee?.farcasterId,
    })) ?? [];
  return NextResponse.json({ referrals });
}

// POST /api/referrals
export async function POST(request: Request) {
  const schema = z.object({
    code: z.string().min(4),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json(
      { valid: false, message: "Invalid JSON" },
      { status: 400 }
    );
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json(
      { valid: false, message: "Invalid input" },
      { status: 400 }
    );
  }
  const { code } = parseResult.data;
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json(
      { valid: false, message: "Unauthorized" },
      { status: 401 }
    );
  }
  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json(
      { valid: false, message: "User not found" },
      { status: 404 }
    );
  }
  const referral = await prisma.referral.findUnique({
    where: { code },
    include: { inviter: true },
  });
  if (!referral || !referral.inviter) {
    return NextResponse.json(
      { valid: false, message: "Invite code not found" },
      { status: 400 }
    );
  }
  const inviter = referral.inviter;
  if (inviter.id === user.id) {
    return NextResponse.json(
      { valid: false, message: "Cannot use your own invite code" },
      { status: 400 }
    );
  }
  const existing = await prisma.referral.findFirst({
    where: { inviterId: inviter.id, inviteeId: user.id },
  });
  if (existing) {
    return NextResponse.json(
      { valid: false, message: "Referral already recorded" },
      { status: 400 }
    );
  }
  await prisma.referral.create({
    data: { code, inviterId: inviter.id, inviteeId: user.id },
  });
  return NextResponse.json({ valid: true });
}

--- File: ./src/app/api/lobby/join/route.ts ---
import { prisma } from "@/lib/db";

export async function POST(req: Request) {
  try {
    const { userId, gameId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    await prisma.chat.create({
      data: {
        userId,
        gameId,
        message: "joined the lobby.",
      },
    });

    return Response.json({ success: true });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/lobby/stats/route.ts ---
import { prisma } from "@/lib/db";

export async function GET() {
  try {
    const tickets = await prisma.ticket.findMany({
      where: { status: "confirmed" },
      include: { user: true },
    });

    const totalTickets = tickets.length;
    const totalPrize = totalTickets * 50; // each ticket costs 50 USDC

    // Return top 10 players by activity
    const players = tickets.map((t) => ({
      name: t.user.name,
      wallet: t.user.wallet,
      imageUrl: t.user.imageUrl,
    }));

    return Response.json({
      totalTickets,
      totalPrize,
      players,
    });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/user/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

// GET /api/user?farcasterId=123
export async function GET(req: Request) {
  const { searchParams } = new URL(req.url);
  const farcasterId = searchParams.get("farcasterId");

  if (!farcasterId) {
    return NextResponse.json(
      { success: false, error: "Missing farcasterId parameter" },
      { status: 400 }
    );
  }

  try {
    const user = await prisma.user.findUnique({
      where: { farcasterId: farcasterId },
    });

    if (!user) {
      return NextResponse.json(
        { success: false, error: "User not found" },
        { status: 404 }
      );
    }

    return NextResponse.json({ success: true, user });
  } catch (err) {
    console.error("User get failed", err);
    return NextResponse.json(
      { success: false, error: "User get failed" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/user/sync/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { z } from "zod";

const schema = z.object({
  fid: z.number(),
  username: z.string().optional(),
  pfpUrl: z.string().url().optional(),
  wallet: z.string().optional(),
});

export async function POST(req: Request) {
  try {
    const body = await req.json();
    const data = schema.parse(body);

    const user = await prisma.user.upsert({
      where: { farcasterId: String(data.fid) },
      update: {
        name: data.username ?? undefined,
        imageUrl: data.pfpUrl ?? undefined,
        wallet: data.wallet ?? undefined,
      },
      create: {
        farcasterId: String(data.fid),
        name: data.username ?? null,
        imageUrl: data.pfpUrl ?? null,
        wallet: data.wallet ?? null,
      },
    });

    return NextResponse.json({ success: true, user });
  } catch (err) {
    console.error("User sync failed", err);
    return NextResponse.json(
      { success: false, error: "User sync failed" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/leaderboard/route.ts ---
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";
import { env } from "@/lib/env";

export type LeaderboardUser = {
  id: string;
  rank: number;
  name: string;
  imageUrl: string;
  points: number;
};

// GET /api/leaderboard?tab=current|allTime&page=0&gameId=&userId=
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const tabParam = (searchParams.get("tab") || "allTime") as
    | "current"
    | "allTime";
  const page = Number(searchParams.get("page") ?? "0");
  const gameIdParam = searchParams.get("gameId");
  const userIdParam = searchParams.get("userId");

  if (!["current", "allTime"].includes(tabParam)) {
    return NextResponse.json({ error: "Invalid tab" }, { status: 400 });
  }
  if (!Number.isFinite(page) || page < 0) {
    return NextResponse.json({ error: "Invalid page" }, { status: 400 });
  }

  let users: LeaderboardUser[] = [];

  if (tabParam === "current") {
    // Determine which game is "current"
    let game = null;
    if (gameIdParam) {
      game = await prisma.game.findUnique({
        where: { id: Number(gameIdParam) },
      });
    } else {
      const now = new Date();
      game =
        (await prisma.game.findFirst({
          where: { startTime: { lte: now }, endTime: { gte: now } },
          orderBy: { startTime: "desc" },
        })) ??
        (await prisma.game.findFirst({
          where: { endTime: { lte: now } },
          orderBy: { endTime: "desc" },
        }));
    }

    if (game) {
      const scores = await prisma.score.findMany({
        where: { gameId: game.id },
        include: { user: true },
        orderBy: { points: "desc" },
      });

      users = scores.map((s, i) => ({
        id: s.userId.toString(),
        rank: i + 1,
        name: s.user?.name || "",
        imageUrl: s.user?.imageUrl || "",
        points: s.points,
      }));
    }
  } else {
    // All-time leaderboard (sum of points per user)
    const grouped = await prisma.score.groupBy({
      by: ["userId"],
      _sum: { points: true },
      orderBy: { _sum: { points: "desc" } },
    });

    const userIds = grouped.map((g) => g.userId);
    const usersData = await prisma.user.findMany({
      where: { id: { in: userIds } },
    });

    users = grouped.map((g, i) => {
      const user = usersData.find((u) => u.id === g.userId);
      return {
        id: g.userId.toString(),
        rank: i + 1,
        name: user?.name || "",
        imageUrl: user?.imageUrl || "",
        points: g._sum.points || 0,
      };
    });
  }

  // pagination
  const start = page * env.nextPublicLeaderboardPageSize;
  const end = start + env.nextPublicLeaderboardPageSize;
  const pageUsers = users.slice(start, end);
  const hasMore = end < users.length;

  // optional "me"
  let me = null;
  if (userIdParam) {
    const userId = Number(userIdParam);
    const found = users.find((u) => Number(u.id) === userId);
    if (found) me = found;
  }

  return NextResponse.json({ users: pageUsers, hasMore, me });
}

export const dynamic = "force-dynamic";

--- File: ./src/app/api/game/answer/route.ts ---
import { prisma } from "@/lib/db";
import { calculateScore } from "@/lib/scoring";

export async function POST(req: Request) {
  try {
    const { userId, gameId, questionId, selected, timeTaken } =
      await req.json();

    if (!userId || !gameId || !questionId || !selected)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const question = await prisma.question.findUnique({
      where: { id: questionId },
    });
    if (!question)
      return Response.json({ error: "Question not found" }, { status: 404 });

    const correct = selected === question.correctAnswer;
    const points = correct ? calculateScore(timeTaken, 10) : 0;

    await prisma.score.upsert({
      where: { userId_gameId: { userId, gameId } },
      update: { points: { increment: points } },
      create: { userId, gameId, points },
    });

    return Response.json({ correct, points });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/game/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/games
export async function GET() {
  const games = await prisma.game.findMany({
    orderBy: { startTime: "asc" },
  });
  return NextResponse.json(games);
}

// POST /api/games
export async function POST(request: NextRequest) {
  const schema = z.object({
    name: z.string().min(1),
    description: z.string().optional(),
    startTime: z.string(),
    endTime: z.string(),
  });
  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }
  const parseResult = schema.safeParse(body);
  if (!parseResult.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }
  const { name, description, startTime, endTime } = parseResult.data;
  const start = new Date(startTime);
  const end = new Date(endTime);
  if (isNaN(start.getTime()) || isNaN(end.getTime())) {
    return NextResponse.json({ error: "Invalid date format" }, { status: 400 });
  }
  if (start >= end) {
    return NextResponse.json(
      { error: "startTime must be before endTime" },
      { status: 400 }
    );
  }
  const game = await prisma.game.create({
    data: {
      name,
      description,
      startTime: start,
      endTime: end,
    },
  });
  return NextResponse.json(game);
}

--- File: ./src/app/api/game/[id]/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// GET /api/games/[id]
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  const resolvedParams = await context.params;
  const gameId = parseInt(resolvedParams.id, 10);
  if (Number.isNaN(gameId)) {
    return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
  }
  const game = await prisma.game.findUnique({
    where: { id: gameId },
    include: { questions: true },
  });
  if (!game) {
    return NextResponse.json({ error: "Game not found" }, { status: 404 });
  }
  // Exclude correct answers in questions
  const questions = game.questions.map((q) => ({
    id: q.id,
    questionText: q.text,
    imageUrl: q.imageUrl,
    options: q.options,
  }));
  const { id, name, description, startTime, endTime } = game;
  return NextResponse.json({
    id,
    name,
    description,
    startTime,
    endTime,
    questions,
  });
}

--- File: ./src/app/api/game/[id]/questions/route.ts ---
import { NextResponse, type NextRequest } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/game/[id]/questions
export async function GET(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await context.params;
    const gameId = Number(resolvedParams.id);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
    }
    const questions = await prisma.question.findMany({
      where: { gameId },
      select: {
        id: true,
        text: true,
        imageUrl: true,
        options: true,
      },
    });
    return NextResponse.json(questions);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

// POST /api/game/[id]/questions
export async function POST(
  request: NextRequest,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const resolvedParams = await context.params;
    const gameId = Number(resolvedParams.id);
    if (!Number.isInteger(gameId)) {
      return NextResponse.json({ error: "Invalid game ID" }, { status: 400 });
    }

    const schema = z.object({
      text: z.string().min(1),
      imageUrl: z.string().min(1),
      options: z.array(z.string().min(1)).min(2),
      correctIndex: z.number().min(0),
    });

    let body: unknown;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
    }
    const parseResult = schema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json({ error: "Invalid input" }, { status: 400 });
    }
    const { text, imageUrl, options, correctIndex } = parseResult.data;
    if (correctIndex >= options.length) {
      return NextResponse.json(
        { error: "correctIndex out of range" },
        { status: 400 }
      );
    }

    // Check game exists
    const game = await prisma.game.findUnique({ where: { id: gameId } });
    if (!game) {
      return NextResponse.json({ error: "Game not found" }, { status: 404 });
    }

    const question = await prisma.question.create({
      data: {
        gameId,
        text,
        imageUrl,
        options,
        correctAnswer: options[correctIndex],
      },
    });

    return NextResponse.json(question);
  } catch (error) {
    console.error(error);
    return NextResponse.json(
      { error: "Internal Server Error" },
      { status: 500 }
    );
  }
}

--- File: ./src/app/api/profile/route.ts ---
// ───────────────────────── /app/api/profile/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { z } from "zod";
import { prisma } from "@/lib/db";

// GET /api/profile
export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({
    where: { farcasterId },
    select: { id: true, name: true, wallet: true, imageUrl: true },
  });

  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  return NextResponse.json(user);
}

// PUT /api/profile
export async function PUT(request: Request) {
  const schema = z.object({
    name: z.string().trim().optional(),
    wallet: z.string().trim().optional(),
    imageUrl: z.string().url().optional(),
  });

  let body;
  try {
    body = await request.json();
  } catch {
    return NextResponse.json({ error: "Invalid JSON" }, { status: 400 });
  }

  const parsed = schema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: "Invalid input" }, { status: 400 });
  }

  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const updated = await prisma.user.update({
    where: { id: user.id },
    data: parsed.data,
    select: { id: true, name: true, wallet: true, imageUrl: true },
  });

  return NextResponse.json(updated);
}

--- File: ./src/app/api/profile/history/route.ts ---
// ───────────────────────── /app/api/profile/history/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
    orderBy: { game: { endTime: "desc" } },
  });

  const history = scores.map((s) => ({
    id: s.id,
    name: s.game.name,
    score: s.points,
    winnings: s.points,
    winningsColor: s.points > 0 ? "green" : "gray",
  }));

  return NextResponse.json(history);
}

--- File: ./src/app/api/profile/stats/route.ts ---
// ───────────────────────── /app/api/profile/stats/route.ts ─────────────────────────
import { NextResponse } from "next/server";
import { prisma } from "@/lib/db";

export async function GET(request: Request) {
  const farcasterId = request.headers.get("x-farcaster-id");
  if (!farcasterId) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const user = await prisma.user.findUnique({ where: { farcasterId } });
  if (!user) {
    return NextResponse.json({ error: "User not found" }, { status: 404 });
  }

  const scores = await prisma.score.findMany({
    where: { userId: user.id },
    include: { game: true },
  });

  const totalGames = scores.length;
  if (totalGames === 0) {
    return NextResponse.json({
      totalGames: 0,
      wins: 0,
      winRate: 0,
      totalWon: 0,
      highestScore: 0,
      avgScore: 0,
      currentStreak: 0,
      bestRank: 0,
    });
  }

  let wins = 0;
  let totalWon = 0;
  let highestScore = 0;
  let bestRank = Infinity;

  // Sort by endTime (latest first)
  const sortedScores = [...scores].sort((a, b) => {
    const aTime = a.game.endTime?.getTime() ?? 0;
    const bTime = b.game.endTime?.getTime() ?? 0;
    return bTime - aTime;
  });

  // Preload all game results to calculate ranks efficiently
  const gameIds = [...new Set(sortedScores.map((s) => s.gameId))];
  const allGameScores = await prisma.score.findMany({
    where: { gameId: { in: gameIds } },
    select: { gameId: true, points: true },
  });

  // Compute stats
  let currentStreak = 0;
  for (const s of sortedScores) {
    totalWon += s.points;
    highestScore = Math.max(highestScore, s.points);

    // Rank calculation
    const rank =
      allGameScores.filter((g) => g.gameId === s.gameId && g.points > s.points)
        .length + 1;
    bestRank = Math.min(bestRank, rank);

    if (rank === 1) {
      wins++;
      currentStreak++;
    } else {
      break;
    }
  }

  const avgScore = totalWon / totalGames;
  const winRate = (wins / totalGames) * 100;

  return NextResponse.json({
    totalGames,
    wins,
    winRate: Math.round(winRate * 10) / 10,
    totalWon,
    highestScore,
    avgScore: Math.round(avgScore * 100) / 100,
    currentStreak,
    bestRank: bestRank === Infinity ? 0 : bestRank,
  });
}

--- File: ./src/app/api/final/match/route.ts ---
import { prisma } from "@/lib/db";
import { isMatch } from "@/lib/scoring";

export async function POST(req: Request) {
  try {
    const { userId, gameId, choiceId, targetId } = await req.json();
    if (!userId || !gameId)
      return Response.json({ error: "Missing fields" }, { status: 400 });

    const correct = isMatch(choiceId, targetId);
    const points = correct ? 100 : 0;

    await prisma.score.upsert({
      where: { userId_gameId: { userId, gameId } },
      update: { points: { increment: points } },
      create: { userId, gameId, points },
    });

    return Response.json({ correct, points });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/api/final/start/route.ts ---
import { prisma } from "@/lib/db";

export async function GET() {
  try {
    const allQuestions = await prisma.question.findMany({
      take: 20,
      orderBy: { id: "asc" },
    });

    const pairs = allQuestions.map((q) => ({
      id: q.id,
      originalUrl: q.imageUrl,
      generatedUrl: q.imageUrl.replace("original", "ai"), // simple mock pattern
    }));

    return Response.json({ pairs });
  } catch (e) {
    console.error(e);
    return Response.json({ error: "Internal Server Error" }, { status: 500 });
  }
}

--- File: ./src/app/og/image.tsx ---
import { ImageResponse } from "next/og";

export const runtime = "edge";

export const size = { width: 1200, height: 630 };
export const contentType = "image/png";

export default async function Image({
  searchParams,
}: {
  searchParams: { username?: string; score?: string };
}) {
  const { username = "Player", score = "0" } = searchParams;
  return new ImageResponse(
    (
      <div
        style={{
          display: "flex",
          flexDirection: "column",
          alignItems: "center",
          justifyContent: "center",
          background: "linear-gradient(180deg, #1E1E1E 0%, #000000 100%)",
          width: "100%",
          height: "100%",
          color: "white",
          fontFamily: "sans-serif",
        }}
      >
        <h1 style={{ fontSize: 64, color: "#FFD700" }}>Waffles Champion</h1>
        <p style={{ fontSize: 36 }}>{username}</p>
        <p style={{ fontSize: 28, color: "#BBB" }}>{score} pts</p>
      </div>
    ),
    { ...size }
  );
}

--- File: ./src/app/page.tsx ---
"use client";

import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function Home() {
  const router = useRouter();

  useEffect(() => {
    router.replace("/game");
  }, [router]);

  return null;
}

--- File: ./src/app/globals.css ---
@layer base, components, utilities;

@import "tailwindcss";
@import "tw-animate-css";

/* ------------------------------------------------------------
   GLOBAL BRAND + THEME TOKENS
   ------------------------------------------------------------ */
@custom-variant dark (&:is(.dark *));

:root {
  /* ── Brand Colors ───────────────────────────── */
  --brand-gold: oklch(0.83 0.17 95); /* #FFC931 */
  --brand-cyan: oklch(0.78 0.19 210); /* #00CFF2 */
  --brand-pink: oklch(0.73 0.22 342); /* #FB72FF */
  --brand-purple: oklch(0.61 0.22 303); /* Neon purple */
  --brand-orange: oklch(0.72 0.18 65);

  --brand-ink-950: oklch(0.12 0 0); /* Black */
  --brand-ink-900: oklch(0.19 0 0); /* Dark Gray */
  --brand-ink-800: oklch(0.24 0 0); /* Medium Gray */
  --brand-white: oklch(1 0 0); /* White */

  /* ── Alpha Utilities ────────────────────────── */
  --white-a07: #ffffff12;
  --white-a08: #ffffff14;
  --white-a10: #ffffff1a;
  --white-a13: #ffffff21;
  --white-a38: #ffffff61;

  /* ── Base Semantic Colors (light mode) ───────── */
  --surface-page: linear-gradient(180deg, var(--brand-ink-800) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-800) 90%, #000 10%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-800) 92%, #000 8%);
  --surface-tint: var(--white-a10);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.74 0 0); /* #99A0AE */

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a13);
  --accent-ring: var(--brand-gold);

  --success: #14b985;
  --danger: oklch(0.65 0.22 25);

  /* ── Sidebar Colors ─────────────────────────── */
  --sidebar-bg: var(--brand-white);
  --sidebar-fg: var(--brand-ink-900);
  --sidebar-primary: var(--brand-ink-800);
  --sidebar-primary-fg: var(--brand-white);
  --sidebar-accent: var(--white-a10);
  --sidebar-accent-fg: var(--brand-ink-900);
  --sidebar-border: #eaeaea;
  --sidebar-ring: #b5b5b5;

  /* ── Radii & Decorative BGs ─────────────────── */
  --radius-xs: 8px;
  --radius-sm: 12px;
  --radius-md: 16px;

  --gold-overlay: linear-gradient(
    189.66deg,
    rgba(0, 0, 0, 0) -6.71%,
    rgba(0, 0, 0, 0.8) 92.73%
  );
  --card-glint: linear-gradient(
    90deg,
    rgba(255, 255, 255, 0) 0%,
    color-mix(in oklch, var(--brand-gold) 25%, transparent) 100%
  );

  /* ── Noise Overlay ──────────────────────────── */
  --noise-opacity: 0.25;
  --noise-size: 200px;

  /* ── Dark Theme Defaults (fallbacks for base) ─ */
  --background: oklch(0.08 0 0);
  --foreground: oklch(0.98 0 0);
  --card: oklch(0.12 0 0);
  --card-foreground: oklch(0.98 0 0);
  --popover: oklch(0.1 0 0);
  --popover-foreground: oklch(0.98 0 0);
}

/* ------------------------------------------------------------
   DARK THEME OVERRIDES
   ------------------------------------------------------------ */
.dark {
  --surface-page: linear-gradient(180deg, var(--brand-ink-900) 0%, #000 100%);
  --surface-card: color-mix(in oklch, var(--brand-ink-900) 95%, #000 5%);
  --surface-popover: color-mix(in oklch, var(--brand-ink-900) 93%, #000 7%);
  --surface-tint: var(--white-a07);
  --surface-stroke: var(--white-a08);

  --text-primary: var(--brand-white);
  --text-muted: oklch(0.72 0 0);

  --accent-solid: var(--brand-gold);
  --accent-soft: var(--white-a10);
  --accent-ring: var(--brand-gold);
}

/* ------------------------------------------------------------
   TAILWIND THEME BRIDGE
   ------------------------------------------------------------ */
@theme inline {
  /* fonts */
  --font-display: var(--font-display);
  --font-body: var(--font-body);

  /* semantic colors */
  --color-background: var(--surface-page);
  --color-card: var(--surface-card);
  --color-popover: var(--surface-popover);
  --color-foreground: var(--text-primary);
  --color-muted: var(--text-muted);
  --color-primary: var(--accent-solid);
  --color-secondary: var(--brand-purple);

  --color-border: var(--surface-stroke);
  --color-input: var(--surface-tint);
  --color-ring: var(--accent-ring);

  /* brand aliases */
  --color-waffle-gold: var(--brand-gold);
  --color-neon-cyan: var(--brand-cyan);
  --color-neon-pink: var(--brand-pink);
  --color-neon-purple: var(--brand-purple);
  --color-success: var(--success);
  --color-danger: var(--danger);

  /* radii */
  --radius-sm: var(--radius-xs);
  --radius-md: var(--radius-sm);
  --radius-lg: var(--radius-md);
}

/* ------------------------------------------------------------
   BASE LAYER
   ------------------------------------------------------------ */
@layer base {
  html,
  body {
    height: 100%;
  }
  body {
    @apply bg-background text-foreground antialiased;
    font-family: var(--font-body);
  }
}

/* ------------------------------------------------------------
   UTILITIES
   ------------------------------------------------------------ */

/* Page gradient background */
@utility bg-figma {
  background-image: var(--surface-page);
  background-attachment: fixed;
  background-repeat: no-repeat;
  background-size: cover;
}

/* Gold overlay card */
@utility bg-gold-overlay {
  background: var(--gold-overlay), var(--brand-gold);
  background-blend-mode: overlay, normal;
}

/* Card glint */
@utility bg-card-glint {
  background-image: var(--card-glint);
}

/* Subtle panel style */
@utility panel {
  background: var(--white-a10);
  border: 1px solid var(--surface-stroke);
  border-radius: var(--radius-md);
}

/* Noise overlay container */
@utility noise {
  position: relative;
  isolation: isolate;
}

.noise::after {
  content: "";
  position: absolute;
  inset: 0;
  pointer-events: none;
  z-index: 1;
  opacity: var(--noise-opacity);
  mix-blend-mode: overlay;
  background-size: var(--noise-size) var(--noise-size);
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 200'><filter id='n'><feTurbulence type='fractalNoise' baseFrequency='1.4' numOctaves='4' stitchTiles='stitch'/></filter><rect width='100%' height='100%' filter='url(%23n)' fill='white'/></svg>");
}

/* Neon glow */
@utility neon {
  text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
}

/* Global transition curve */
@media (prefers-reduced-motion: no-preference) {
  * {
    transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  }
}

/* ------------------------------------------------------------
   ANIMATIONS
   ------------------------------------------------------------ */
@keyframes glow-pulse {
  0%,
  100% {
    opacity: 1;
    filter: brightness(1);
  }
  50% {
    opacity: 0.85;
    filter: brightness(1.15);
  }
}

@keyframes slide-up {
  from {
    transform: translateY(20px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

@keyframes slide-in-x {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@utility animate-glow {
  animation: glow-pulse 2s ease-in-out infinite;
}
@utility animate-up {
  animation: slide-up 0.28s ease-out both;
}
@utility animate-in-right {
  animation: slide-in-x 0.28s ease-out both;
}

@utility pixel-corners {
  /* The precise polygon shape for the pixelated corners */
  clip-path: polygon(
    0px 12px,
    6px 12px,
    6px 6px,
    12px 6px,
    12px 0px,
    calc(100% - 12px) 0px,
    calc(100% - 12px) 6px,
    calc(100% - 6px) 6px,
    calc(100% - 6px) 12px,
    100% 12px,
    100% calc(100% - 12px),
    calc(100% - 6px) calc(100% - 12px),
    calc(100% - 6px) calc(100% - 6px),
    calc(100% - 12px) calc(100% - 6px),
    calc(100% - 12px) 100%,
    12px 100%,
    12px calc(100% - 6px),
    6px calc(100% - 6px),
    6px calc(100% - 12px),
    0% calc(100% - 12px)
  );
}

/* ───────────────────────── Base Interaction Animations ───────────────────────── */

/* Fade-in */
.fade-in {
  animation: fadeIn 0.6s ease forwards;
}
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Slide-up */
.slide-up {
  animation: slideUp 0.5s ease forwards;
}
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Subtle scale pop for tap feedback */
.tap-pop {
  transition: transform 0.12s ease;
}
.tap-pop:active {
  transform: scale(0.96);
}

--- File: ./src/stores/finalRoundStore.ts ---
import { create } from "zustand";

interface Pair {
  id: number;
  originalUrl: string;
  generatedUrl: string;
}

interface FinalRoundState {
  pairs: Pair[];
  score: number;
  timeLeft: number;
  status: "idle" | "playing" | "ended";
  fetchPairs: () => Promise<void>;
  submitMatch: (choiceId: number, targetId: number) => Promise<void>;
  startTimer: () => void;
  reset: () => void;
}

export const useFinalRoundStore = create<FinalRoundState>((set, get) => ({
  pairs: [],
  score: 0,
  timeLeft: 30,
  status: "idle",

  fetchPairs: async () => {
    const res = await fetch("/api/final/start");
    const data = await res.json();
    set({ pairs: data.pairs, status: "playing" });
    get().startTimer();
  },

  submitMatch: async (choiceId, targetId) => {
    try {
      const res = await fetch("/api/final/match", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userId: 1, gameId: 1, choiceId, targetId }),
      });
      const { points } = await res.json();
      set((s) => ({ score: s.score + points }));
    } catch (e) {
      console.error(e);
    }
  },

  startTimer: () => {
    const interval = setInterval(() => {
      set((s) => {
        if (s.timeLeft <= 1) {
          clearInterval(interval);
          return { ...s, status: "ended", timeLeft: 0 };
        }
        return { ...s, timeLeft: s.timeLeft - 1 };
      });
    }, 1000);
  },

  reset: () => set({ pairs: [], score: 0, timeLeft: 30, status: "idle" }),
}));

--- File: ./src/stores/leaderboardStore.ts ---
"use client";
import { create } from "zustand";

export type TabKey = "current" | "allTime";

export interface Entry {
  rank: number;
  username: string;
  points: number;
  pfpUrl: string | null;
}

interface Slice {
  entries: Entry[];
  page: number;
  hasMore: boolean;
  isLoading: boolean;
  error?: string | null;
  scrollTop?: number;
}

interface LeaderboardState {
  activeTab: TabKey;
  slices: Record<TabKey, Slice>;
  me: Entry | null;

  // Actions
  setActiveTab: (tab: TabKey) => void;
  rememberScroll: (tab: TabKey, scrollY: number) => void;
  fetchLeaderboard: (tab: TabKey) => Promise<void>;
  reset: () => void;
}

export const useLeaderboardStore = create<LeaderboardState>((set, get) => ({
  activeTab: "current",
  slices: {
    current: {
      entries: [],
      page: 0,
      hasMore: true,
      isLoading: false,
      scrollTop: 0,
    },
    allTime: {
      entries: [],
      page: 0,
      hasMore: true,
      isLoading: false,
      scrollTop: 0,
    },
  },
  me: null,

  setActiveTab: (tab) => set({ activeTab: tab }),

  rememberScroll: (tab, scrollY) =>
    set((state) => ({
      slices: {
        ...state.slices,
        [tab]: { ...state.slices[tab], scrollTop: scrollY },
      },
    })),

  fetchLeaderboard: async (tab) => {
    const { slices } = get();
    const slice = slices[tab];

    if (slice.isLoading || !slice.hasMore) return;

    set({
      slices: {
        ...slices,
        [tab]: { ...slice, isLoading: true, error: null },
      },
    });

    try {
      const res = await fetch(`/api/leaderboard?tab=${tab}&page=${slice.page}`);
      if (!res.ok) throw new Error(`Failed to fetch ${tab} leaderboard`);
      const data = await res.json();

      const newEntries: Entry[] = (data.users || []).map(
        (u: {
          rank: number;
          name: string;
          points: number;
          imageUrl: string | null;
        }) => ({
          rank: u.rank,
          username: u.name,
          points: u.points,
          pfpUrl: u.imageUrl || null,
        })
      );

      set((state) => ({
        slices: {
          ...state.slices,
          [tab]: {
            ...state.slices[tab],
            entries: [...state.slices[tab].entries, ...newEntries],
            page: state.slices[tab].page + 1,
            hasMore: data.hasMore,
            isLoading: false,
          },
        },
        me: data.me
          ? {
              rank: data.me.rank,
              username: data.me.name,
              points: data.me.points,
              pfpUrl: data.me.imageUrl || null,
            }
          : state.me,
      }));
    } catch (err: unknown) {
      set((state) => ({
        slices: {
          ...state.slices,
          [tab]: {
            ...state.slices[tab],
            isLoading: false,
            error: err instanceof Error ? err.message : "Unknown error",
          },
        },
      }));
    }
  },

  reset: () =>
    set({
      slices: {
        current: {
          entries: [],
          page: 0,
          hasMore: true,
          isLoading: false,
          scrollTop: 0,
        },
        allTime: {
          entries: [],
          page: 0,
          hasMore: true,
          isLoading: false,
          scrollTop: 0,
        },
      },
      me: null,
    }),
}));

--- File: ./src/stores/profileStore.ts ---
// ───────────────────────── src/stores/profileStore.ts ─────────────────────────
import { create } from "zustand";

export interface GameHistory {
  id: number | string;
  name: string;
  score: number;
  winnings: number;
  winningsColor?: "green" | "gray";
}

export interface AllTimeStats {
  totalGames: number;
  wins: number;
  winRate: string; // formatted "80%"
  totalWon: string; // formatted "$50.00"
  highestScore: number;
  averageScore: number;
  currentStreak: number;
  bestRank: number | string;
}

interface ProfileState {
  id: number | null;
  username: string;
  wallet: string;
  imageUrl: string;
  streak: number;

  stats: { games: number; wins: number; winnings: number };
  gameHistory: GameHistory[];
  allTimeStats: AllTimeStats;

  loading: boolean;
  error: string | null;

  fetchProfile: () => Promise<void>;
  updateProfile: (
    payload: Partial<{ name: string; wallet: string; imageUrl: string }>
  ) => Promise<void>;
}

// ───────────────────────── STORE ─────────────────────────
export const useProfileStore = create<ProfileState>((set) => ({
  id: null,
  username: "",
  wallet: "",
  imageUrl: "",
  streak: 0,

  stats: { games: 0, wins: 0, winnings: 0 },
  gameHistory: [],
  allTimeStats: {
    totalGames: 0,
    wins: 0,
    winRate: "0%",
    totalWon: "$0",
    highestScore: 0,
    averageScore: 0,
    currentStreak: 0,
    bestRank: "-",
  },

  loading: false,
  error: null,

  // Unified fetch (calls 3 API routes)
  fetchProfile: async () => {
    set({ loading: true, error: null });

    try {
      // 1️⃣ Fetch basic info
      const [profileRes, statsRes, historyRes] = await Promise.all([
        fetch("/api/profile"),
        fetch("/api/profile/stats"),
        fetch("/api/profile/history"),
      ]);

      if (!profileRes.ok) throw new Error("Profile fetch failed");
      if (!statsRes.ok) throw new Error("Stats fetch failed");
      if (!historyRes.ok) throw new Error("History fetch failed");

      const profile = await profileRes.json();
      const stats = await statsRes.json();
      const history = await historyRes.json();

      const winRateStr = `${Math.round(stats.winRate)}%`;
      const totalWonStr = `$${stats.totalWon.toFixed(2)}`;

      set({
        id: profile.id,
        username: profile.name || "Anonymous",
        wallet: profile.wallet || "",
        imageUrl: profile.imageUrl || "/images/avatars/a.png",
        streak: stats.currentStreak || 0,

        stats: {
          games: stats.totalGames || 0,
          wins: stats.wins || 0,
          winnings: stats.totalWon || 0,
        },
        allTimeStats: {
          totalGames: stats.totalGames,
          wins: stats.wins,
          winRate: winRateStr,
          totalWon: totalWonStr,
          highestScore: stats.highestScore,
          averageScore: stats.avgScore,
          currentStreak: stats.currentStreak,
          bestRank: stats.bestRank,
        },
        gameHistory: history,
        loading: false,
      });
    } catch (err: unknown) {
      console.error("Profile load failed:", err);
      set({
        error: err instanceof Error ? err.message : "Failed to load profile",
        loading: false,
      });
    }
  },

  // Update basic info
  updateProfile: async (payload) => {
    try {
      const res = await fetch("/api/profile", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error("Failed to update profile");
      const updated = await res.json();
      set({
        username: updated.name ?? "",
        wallet: updated.wallet ?? "",
        imageUrl: updated.imageUrl ?? "",
      });
    } catch (e: unknown) {
      console.error("Profile update failed:", e);
      set({
        error: e instanceof Error ? e.message : "Failed to update profile",
        loading: false,
      });
    }
  },
}));

--- File: ./src/stores/gameStore.ts ---
// ───────────────────────── src/stores/gameStore.ts ─────────────────────────
"use client";

import { create } from "zustand";
import { RealtimeChannel } from "@supabase/supabase-js";
import { supabase } from "@/lib/supabaseClient";
import SoundManager from "@/lib/SoundManager";

export interface User {
  fid: number;
  username: string;
  pfpUrl: string;
}

// ───────────────────────── TYPES ─────────────────────────
export interface ChatMessage {
  id: number;
  username: string;
  message: string;
  avatarUrl: string;
  time: string;
}

export interface ChatApiResponse {
  messageId: number;
  userId: number;
  userName: string | null;
  message: string;
  createdAt: string;
  avatarUrl?: string | null;
}

export interface AnswerOption {
  id: string;
  text: string;
}

export interface Question {
  id: number;
  questionText: string;
  imageUrl: string;
  options: AnswerOption[];
  correctAnswerId?: string;
}

export type GameState =
  | "LOBBY"
  | "ROUND_COUNTDOWN"
  | "QUESTION_ACTIVE"
  | "ANSWER_SUBMITTED"
  | "GAME_OVER";

export interface GameStore {
  gameId: number | null;
  gameState: GameState;
  round: number;
  current: number;
  questions: Question[];
  timeLeft: number;
  score: number;
  selectedAnswer: string | null;
  visualCue: "none" | "correct" | "wrong";

  // Derived
  currentQuestion: Question | null;
  currentQuestionIndex: number;
  totalQuestions: number;
  questionTimer: number;
  roundTimer: number;

  // Chat
  messages: ChatMessage[];
  fetchMessages: (gameId: number, user: User) => Promise<void>;
  sendMessage: (text: string, user: User) => Promise<void>;

  // Realtime
  subscribeToChat: (gameId: number) => void;
  unsubscribeFromChat: () => void;

  // Game flow
  fetchQuestions: (gameId: number, user: User) => Promise<void>;
  startRoundCountdown: () => void;
  tickRoundTimer: () => void;
  selectAnswer: (answerId: string) => void;
  advanceToNextQuestion: () => void;
  resetGame: () => void;
  gameOver: () => void;

  _chatChannel?: RealtimeChannel | null;
}

// ───────────────────────── CONSTANTS ─────────────────────────
const QUESTION_DURATION = 15;

// ───────────────────────── STORE ─────────────────────────
export const useGameStore = create<GameStore>((set, get) => ({
  gameId: null,
  gameState: "LOBBY",
  round: 1,
  current: 0,
  questions: [],
  timeLeft: QUESTION_DURATION,
  score: 0,
  selectedAnswer: null,
  visualCue: "none",
  messages: [],
  _chatChannel: null,

  // Derived fields
  get currentQuestion() {
    const { questions, current } = get();
    return questions[current] ?? null;
  },
  get currentQuestionIndex() {
    return get().current;
  },
  get totalQuestions() {
    return get().questions.length;
  },
  get questionTimer() {
    return get().timeLeft;
  },
  get roundTimer() {
    return get().timeLeft;
  },

  // ───────── Chat Logic ─────────
  fetchMessages: async (
    gameId: number,
    user: { fid: number; username: string; pfpUrl: string }
  ) => {
    try {
      const res = await fetch(`/api/chat?gameId=${gameId}`, {
        headers: { "x-farcaster-id": String(user.fid) },
      });
      if (!res.ok) throw new Error("Failed to fetch chat");
      const data: ChatApiResponse[] = await res.json();

      const formatted: ChatMessage[] = data.map((m) => ({
        id: m.messageId,
        username: user.username,
        message: m.message,
        avatarUrl: user.pfpUrl,
        time: new Date(m.createdAt).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
      }));

      set({ messages: formatted });
    } catch (err) {
      console.error("fetchMessages error:", err);
    }
  },

  sendMessage: async (text: string, user: User) => {
    const { gameId, messages } = get();
    if (!user.fid || !gameId) {
      console.error("No Farcaster ID or game ID found");
      return;
    }

    try {
      const temp: ChatMessage = {
        id: Date.now(),
        username: user.username,
        message: text,
        avatarUrl: user.pfpUrl,
        time: new Date().toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
      };
      set({ messages: [...messages, temp] });

      await fetch(`/api/chat`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-farcaster-id": String(user.fid),
        },
        body: JSON.stringify({ gameId, message: text }),
      });
    } catch (err) {
      console.error("sendMessage error:", err);
    }
  },

  // ───────── Realtime Chat ─────────
  subscribeToChat: (gameId: number) => {
    const store = get();
    if (store._chatChannel) {
      store._chatChannel.unsubscribe();
      set({ _chatChannel: null });
    }

    const channel = supabase
      .channel(`chat_game_${gameId}`)
      .on(
        "postgres_changes",
        {
          event: "INSERT",
          schema: "public",
          table: "Chat",
          filter: `gameId=eq.${gameId}`,
        },
        (payload) => {
          const msg = payload.new as {
            id: number;
            message: string;
            createdAt: string;
          };
          set((s) => ({
            messages: [
              ...s.messages,
              {
                id: msg.id,
                username: "Player",
                message: msg.message,
                avatarUrl: "/images/avatars/default.png",
                time: new Date(msg.createdAt).toLocaleTimeString([], {
                  hour: "2-digit",
                  minute: "2-digit",
                }),
              },
            ],
          }));
        }
      )
      .subscribe();

    // ✅ Cleanup automatically when tab closes
    const cleanup = () => {
      channel.unsubscribe();
      set({ _chatChannel: null });
      window.removeEventListener("beforeunload", cleanup);
    };
    window.addEventListener("beforeunload", cleanup);

    set({ _chatChannel: channel });
  },

  unsubscribeFromChat: () => {
    const { _chatChannel } = get();
    if (_chatChannel) {
      _chatChannel.unsubscribe();
      set({ _chatChannel: null });
    }
  },

  // ───────── Game Logic ─────────
  fetchQuestions: async (gameId: number, user: User) => {
    if (!gameId) {
      console.warn("fetchQuestions called without a gameId");
      return;
    }
    try {
      const res = await fetch(`/api/games/${gameId}`);
      const data = await res.json();
      set({
        questions: data.questions || [],
        gameId,
        current: 0,
        gameState: "LOBBY",
        messages: [],
      });
      await get().fetchMessages(gameId, user);
      get().subscribeToChat(gameId);
    } catch (e) {
      console.error("Failed to fetch questions:", e);
    }
  },

  startRoundCountdown: () => {
    SoundManager.play("countdown");
    set({ gameState: "ROUND_COUNTDOWN" });
    setTimeout(() => {
      set({
        gameState: "QUESTION_ACTIVE",
        timeLeft: QUESTION_DURATION,
        selectedAnswer: null,
        visualCue: "none",
      });
    }, 3000);
  },

  tickRoundTimer: () => {
    const { gameState, timeLeft } = get();
    if (gameState !== "QUESTION_ACTIVE") return;
    if (timeLeft <= 1) get().selectAnswer("");
    else set({ timeLeft: timeLeft - 1 });
  },

  selectAnswer: (answerId: string) => {
    const { current, questions, timeLeft, score, gameState } = get();
    if (gameState !== "QUESTION_ACTIVE") return;

    const q = questions[current];
    const isCorrect = q?.correctAnswerId
      ? q.correctAnswerId === answerId
      : Math.random() > 0.5;

    set({
      selectedAnswer: answerId,
      gameState: "ANSWER_SUBMITTED",
      visualCue: isCorrect ? "correct" : "wrong",
    });

    SoundManager.play("click");
    SoundManager.play(isCorrect ? "correct" : "wrong");

    if (q) {
      fetch("/api/game/answer", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          userId: 1,
          gameId: get().gameId,
          questionId: q.id,
          selected: answerId,
          timeTaken: QUESTION_DURATION - timeLeft,
        }),
      })
        .then((r) => r.json())
        .then(({ correct, points }: { correct: boolean; points: number }) => {
          if (correct) set({ score: score + (points || 0) });
        })
        .catch(console.error);
    }

    setTimeout(() => {
      set({ visualCue: "none" });
      get().advanceToNextQuestion();
    }, 1800);
  },

  advanceToNextQuestion: () => {
    const { current, questions } = get();
    if (current < questions.length - 1) {
      set({
        current: current + 1,
        timeLeft: QUESTION_DURATION,
        selectedAnswer: null,
      });
      SoundManager.play("nextQuestion");
      get().startRoundCountdown();
    } else get().gameOver();
  },

  resetGame: () => {
    get().unsubscribeFromChat();
    set({
      round: 1,
      current: 0,
      questions: [],
      score: 0,
      gameState: "LOBBY",
      selectedAnswer: null,
      visualCue: "none",
      timeLeft: QUESTION_DURATION,
      messages: [],
      gameId: null,
      _chatChannel: null,
    });
  },

  gameOver: () => {
    get().unsubscribeFromChat();
    set({ gameState: "GAME_OVER", messages: [] });
    SoundManager.play("gameOver");
  },
}));

--- File: ./src/stores/lobbyStore.ts ---
// ───────────────────────── src/stores/lobbyStore.ts ─────────────────────────
// Fully fixed for Zustand v5 typing + persistence + single ticket per game.

"use client";

import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

// ───────────────────────── TYPES ─────────────────────────
interface Player {
  username: string;
  wallet: string;
  pfpUrl: string | null;
}

interface LobbyStats {
  totalTickets: number;
  totalPrize: number;
  players: Player[];
}

interface ReferralData {
  code: string;
  inviterId: number;
  inviteeId?: number;
}

type ReferralStatus = "idle" | "validating" | "success" | "failed";
type TicketStatus = "idle" | "pending" | "confirmed" | "failed";

interface Ticket {
  id?: number;
  txHash?: string;
  amountUSDC?: number;
  status: TicketStatus;
  gameId?: number;
}

// ───────────────────────── STATE INTERFACE ─────────────────────────
interface LobbyState {
  // Referral
  referralCode: string;
  referralStatus: ReferralStatus;
  referralData?: ReferralData;
  createReferral: (inviterId: number, farcasterId: number) => Promise<void>;
  validateReferral: (code: string, farcasterId: number) => Promise<void>;

  // Stats
  stats: LobbyStats | null;
  countdown: string;
  fetchStats: () => Promise<void>;
  startCountdown: (target: Date) => void;
  stopCountdown: () => void;

  // Ticket
  ticket: Ticket | null;
  purchaseStatus: TicketStatus;
  buyTicket: (userId: number, gameId: number, amount: number) => Promise<void>;
  confirmTicket: (ticketId: number) => Promise<void>;
}

// ───────────────────────── STORE ─────────────────────────
export const useLobbyStore = create<LobbyState>()(
  persist(
    (set, get) => {
      let countdownInterval: ReturnType<typeof setInterval> | null = null;

      return {
        // ───────────────────────── REFERRAL ─────────────────────────
        referralCode: "",
        referralStatus: "idle",
        referralData: undefined,

        // Note: createReferral kept as-is (hits /api/referral/create), adjust if not used

        async createReferral(inviterId: number, farcasterId: number) {
          set({ referralStatus: "validating" });
          try {
            const res = await fetch("/api/referral/create", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "x-farcaster-id": farcasterId.toString(),
              },
              body: JSON.stringify({ inviterId }),
            });
            if (!res.ok) throw new Error("Failed to create referral");
            const data: ReferralData = await res.json();
            set({
              referralCode: data.code,
              referralData: data,
              referralStatus: "success",
            });
          } catch {
            set({ referralStatus: "failed" });
          }
        },

        async validateReferral(code: string, farcasterId: number) {
          set({ referralStatus: "validating" });
          try {
            const res = await fetch("/api/referrals", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "x-farcaster-id": farcasterId.toString(),
              },
              body: JSON.stringify({ code }),
            });
            const data = await res.json();
            if (!res.ok || data.valid !== true) {
              set({ referralStatus: "failed" });
              return;
            }
            set({
              referralStatus: "success",
              referralCode: code,
              // The /api/referrals POST does not return full referralData.
              // For consistency, only set code here. Extend if backend returns more.
              referralData: data.referral ?? { code },
            });
          } catch {
            set({ referralStatus: "failed" });
          }
        },

        // ───────────────────────── STATS ─────────────────────────
        stats: null,
        countdown: "00:00",
        async fetchStats() {
          try {
            const res = await fetch("/api/lobby/stats");
            if (!res.ok) throw new Error("Failed to fetch lobby stats");
            const data = await res.json();
            set({ stats: data });
          } catch (e) {
            console.error("fetchStats error:", e);
          }
        },
        startCountdown(target) {
          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = setInterval(() => {
            const diff = target.getTime() - Date.now();
            if (diff <= 0) {
              clearInterval(countdownInterval!);
              countdownInterval = null;
              set({ countdown: "00:00" });
            } else {
              const m = Math.floor(diff / 60000);
              const s = Math.floor((diff % 60000) / 1000);
              set({
                countdown: `${String(m).padStart(2, "0")}:${String(s).padStart(
                  2,
                  "0"
                )}`,
              });
            }
          }, 1000);
        },
        stopCountdown() {
          if (countdownInterval) clearInterval(countdownInterval);
          countdownInterval = null;
        },

        // ───────────────────────── TICKETS ─────────────────────────
        ticket: null,
        purchaseStatus: "idle",
        async buyTicket(userId, gameId, amount) {
          // 🧠 One-ticket-per-game rule
          const current = get().ticket;
          if (current && current.gameId === gameId) {
            console.warn("User already owns a ticket for this game.");
            set({ purchaseStatus: "confirmed" });
            return;
          }

          set({ purchaseStatus: "pending" });
          try {
            const res = await fetch("/api/tickets/buy", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ userId, gameId, amount }),
            });
            if (!res.ok) throw new Error("Ticket purchase failed");
            const data = await res.json();
            set({
              ticket: {
                id: data.ticketId,
                status: "confirmed",
                amountUSDC: amount,
                gameId,
              },
              purchaseStatus: "confirmed",
            });
            await get().fetchStats();
          } catch (e) {
            console.error("buyTicket error:", e);
            set({ purchaseStatus: "failed" });
          }
        },

        async confirmTicket(ticketId) {
          try {
            const res = await fetch("/api/tickets/confirm", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ ticketId }),
            });
            if (!res.ok) throw new Error("Failed to confirm ticket");
            set((s) => ({
              ticket: s.ticket
                ? { ...s.ticket, status: "confirmed" }
                : { id: ticketId, status: "confirmed" },
              purchaseStatus: "confirmed",
            }));
          } catch (e) {
            console.error("confirmTicket error:", e);
          }
        },
      };
    },
    {
      name: "lobby-store",
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        referralCode: state.referralCode,
        referralStatus: state.referralStatus,
        referralData: state.referralData,
        ticket: state.ticket,
        purchaseStatus: state.purchaseStatus,
      }),
    }
  )
);

--- File: ./src/stores/configStore.ts ---
import { create } from "zustand";

type PrizePoolType = "FIXED" | "DYNAMIC";

export interface BaseConfig {
  roundTimeLimit: number;
  questionsPerGame: number;
  scoreMultiplier: number;
  scorePenalty: number | null;
  maxPlayers: number;
  soundEnabled: boolean;
  animationEnabled: boolean;
  prizePoolType: PrizePoolType;
  prizePoolFixedAmount: number | null;
  prizePoolDynamicTickets: number | null;
  timeBonusEnabled: boolean;
  difficultyScaling: number;
}

type PartialConfig = Partial<BaseConfig>;

interface ConfigState {
  global: BaseConfig | null;
  byGameId: Record<number, BaseConfig | null>;
  loading: boolean;
  error: string | null;
  fetchGlobal: () => Promise<void>;
  fetchGame: (gameId: number) => Promise<void>;
  updateGlobal: (input: PartialConfig, adminToken: string) => Promise<void>;
  updateGame: (
    gameId: number,
    input: PartialConfig,
    adminToken: string
  ) => Promise<void>;
  getEffectiveForGame: (gameId: number) => BaseConfig | null;
}

export const useConfigStore = create<ConfigState>((set, get) => ({
  global: null,
  byGameId: {},
  loading: false,
  error: null,

  fetchGlobal: async () => {
    set({ loading: true, error: null });
    try {
      const res = await fetch("/api/config/global");
      if (!res.ok) throw new Error("Failed to load global config");
      const data = await res.json();
      set({ global: data, loading: false });
    } catch (e) {
      console.error(e);
      set({
        error: "Failed to load global config",
        loading: false,
      });
    }
  },

  fetchGame: async (gameId) => {
    set({ loading: true, error: null });
    try {
      const res = await fetch(`/api/config/game/${gameId}`);
      if (!res.ok) throw new Error("Failed to load game config");
      const data = await res.json();
      set((s) => ({
        byGameId: { ...s.byGameId, [gameId]: data },
        loading: false,
      }));
    } catch (e) {
      console.error(e);
      set({
        error: "Failed to load game config",
        loading: false,
      });
    }
  },

  updateGlobal: async (input, adminToken) => {
    set({ loading: true, error: null });
    try {
      const res = await fetch("/api/config/global", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "x-admin-token": adminToken,
        },
        body: JSON.stringify(input),
      });
      if (!res.ok) throw new Error("Failed to update global config");
      const data = await res.json();
      set({ global: data, loading: false });
    } catch (e) {
      console.error(e);
      set({
        error: "Failed to update global config",
        loading: false,
      });
    }
  },

  updateGame: async (gameId, input, adminToken) => {
    set({ loading: true, error: null });
    try {
      const res = await fetch(`/api/config/game/${gameId}`, {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          "x-admin-token": adminToken,
        },
        body: JSON.stringify(input),
      });
      if (!res.ok) throw new Error("Failed to update game config");
      const data = await res.json();
      set((s) => ({
        byGameId: { ...s.byGameId, [gameId]: data },
        loading: false,
      }));
    } catch (e) {
      console.error(e);
      set({
        error: "Failed to update game config",
        loading: false,
      });
    }
  },

  getEffectiveForGame: (gameId) => {
    const { global, byGameId } = get();
    const game = byGameId[gameId];
    if (!global && !game) return null;
    return { ...(global ?? ({} as BaseConfig)), ...(game ?? {}) } as BaseConfig;
  },
}));

--- File: ./src/components/ui/ChatBox.tsx ---
"use client";

import { useState, useEffect, useRef } from "react";

interface Message {
  user: string;
  text: string;
  time: string;
}

export default function ChatBox() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [input, setInput] = useState("");
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    ref.current?.scrollTo(0, ref.current.scrollHeight);
  }, [messages]);

  const sendMessage = async () => {
    if (!input.trim()) return;
    const msg: Message = {
      user: "You",
      text: input,
      time: new Date().toLocaleTimeString(),
    };
    setMessages((prev) => [...prev, msg]);
    setInput("");
    await fetch("/api/chat/send", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: msg.text }),
    });
  };

  return (
    <div className="flex flex-col h-64 w-full max-w-md bg-zinc-900 rounded-xl overflow-hidden">
      <div ref={ref} className="flex-1 overflow-y-auto p-3 space-y-2">
        {messages.map((m, i) => (
          <div key={i} className="text-sm text-gray-300">
            <span className="font-semibold text-purple-400">{m.user}:</span>{" "}
            {m.text}
          </div>
        ))}
      </div>
      <div className="flex p-2 border-t border-zinc-800">
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          className="flex-1 bg-transparent outline-none px-2"
          placeholder="Type a message..."
        />
        <button onClick={sendMessage} className="text-purple-500 font-semibold">
          Send
        </button>
      </div>
    </div>
  );
}

--- File: ./src/components/ui/Toaster.tsx ---
"use client";
import { Toaster, toast } from "sonner";

export const notify = {
  success: (msg: string) => toast.success(msg),
  error: (msg: string) => toast.error(msg),
  info: (msg: string) => toast(msg),
};

export default function GlobalToaster() {
  return <Toaster position="bottom-center" theme="dark" />;
}

--- File: ./src/components/ui/sonner.tsx ---
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

--- File: ./src/components/buttons/FancyBorderButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils";

interface FancyBorderButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  fullWidth?: boolean;
  ref?: React.RefObject<HTMLButtonElement>;
}

export function FancyBorderButton({
  ref,
  children,
  fullWidth = true,
  className,
  ...props
}: FancyBorderButtonProps) {
  return (
    <button
      ref={ref}
      className={cn(
        "relative flex items-center justify-center h-[54px] px-6 bg-white text-[#191919] font-[var(--font-pixel)] text-sm uppercase tracking-wider max-w-sm mx-auto",
        "rounded-[12px] border-[5px] border-t-0 border-l-0 border-[#00CFF2]",
        fullWidth && "w-full",
        "transition-all active:translate-y-[1px]",
        "disabled:cursor-not-allowed disabled:opacity-50 ",
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
}

--- File: ./src/components/buttons/PixelButton.tsx ---
"use client";

import * as React from "react";
import { cn } from "@/lib/utils"; // Assuming a utility like tailwind-merge

interface PixelButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: React.ReactNode;
  asChild?: boolean;
  backgroundColor?: string;
  borderColor?: string;
  textColor?: string;
  borderWidth?: number; // Border width in pixels
}

const PixelButton = React.forwardRef<HTMLButtonElement, PixelButtonProps>(
  (
    {
      className,
      children,
      backgroundColor = "#000000",
      borderColor = "#FFC931",
      textColor = "#FFD972",
      borderWidth = 4, // Default to a 4px border
      ...props
    },
    ref
  ) => {
    const containerStyle = {
      backgroundColor: borderColor,
      padding: `${borderWidth}px`,
    };

    const buttonStyle = {
      backgroundColor: backgroundColor,
      color: textColor,
    };

    return (
      <div
        style={containerStyle}
        className={cn(
          // This is now a full-width block by default to fill its container
          "pixel-corners w-full transition-transform duration-100 ease-in-out",
          // Apply hover/active states to the container to move the whole unit
          "hover:-translate-y-0.5 active:translate-y-0"
        )}
      >
        <button
          style={buttonStyle}
          className={cn(
            "pixel-corners flex h-full w-full items-center justify-center px-6 py-3 font-mono text-sm uppercase tracking-wider",
            "disabled:cursor-not-allowed disabled:opacity-60",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </button>
      </div>
    );
  }
);

PixelButton.displayName = "PixelButton";

export { PixelButton };

--- File: ./src/components/DeviceGate.tsx ---
"use client";

import { useIsMobile } from "@/hooks/useIsMobile";
import Image from "next/image";
import { useEffect } from "react";

type Props = {
  children: React.ReactNode;
  /** show a tiny bypass for QA in non-prod */
  continueAnyway?: boolean;
  /** optional store/deeplink helpers */
  appLinks?: {
    ios?: string;
    android?: string;
    webFallback?: string;
  };
  /** optional QR image path in /public (or remote) */
  qrSrc?: string;
};

export default function DeviceGate({
  children,
  continueAnyway = false,
  appLinks,
  qrSrc = "/qr-mobile.png",
}: Props) {
  const isMobile = useIsMobile();

  // lock background scroll when blocked
  useEffect(() => {
    if (!isMobile) {
      const prev = document.body.style.overflow;
      document.body.style.overflow = "hidden";
      return () => {
        document.body.style.overflow = prev;
      };
    }
  }, [isMobile]);

  if (isMobile) return <>{children}</>;

  return (
    <div className="relative min-h-dvh w-full bg-figmaYay text-foreground noise">
      {/* subtle radial glow */}
      <div className="pointer-events-none absolute inset-0 -z-10 bg-[radial-gradient(ellipse_at_top,rgba(255,255,255,0.06),transparent_60%)]" />

      <div className="mx-auto flex min-h-dvh max-w-screen-md items-center px-4 sm:px-6">
        <section
          role="dialog"
          aria-labelledby="dg-title"
          aria-describedby="dg-desc"
          className="w-full rounded-[var(--radius-md)] border border-[var(--surface-stroke)] bg-[var(--surface-card)]/95 backdrop-blur p-6 sm:p-8 animate-up"
        >
          <header className="flex items-center justify-between gap-4">
            <h1
              id="dg-title"
              className="text-xl sm:text-2xl font-semibold tracking-tight"
            >
              Open on your phone
            </h1>
            {/* badge */}
            <span className="hidden sm:inline-flex items-center rounded-full bg-[var(--white-a10)] px-3 py-1 text-xs text-[color:var(--text-muted)]">
              Mobile only
            </span>
          </header>

          <p
            id="dg-desc"
            className="mt-3 text-sm sm:text-base leading-6 text-[color:var(--text-muted)]"
          >
            This experience is optimized for mobile. Please scan the code or
            open the link on your phone.
          </p>

          <div className="mt-6 grid gap-4 sm:grid-cols-2">
            {/* QR / preview */}
            <div className="flex items-center justify-center rounded-[var(--radius-md)] border border-[var(--surface-stroke)] bg-black/40 p-4">
              {/* Replace with your QR; or remove block */}
              <Image
                src={qrSrc}
                alt="Open on mobile"
                width={160}
                height={160}
                className="rounded-md"
              />
            </div>

            <div className="flex flex-col justify-center gap-3">
              {appLinks?.ios && (
                <a
                  href={appLinks.ios}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Download on the App Store
                </a>
              )}
              {appLinks?.android && (
                <a
                  href={appLinks.android}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Get it on Google Play
                </a>
              )}
              {appLinks?.webFallback && (
                <a
                  href={appLinks.webFallback}
                  className="inline-flex items-center justify-center rounded-full px-4 py-3 text-sm font-medium text-foreground bg-[var(--accent-soft)] hover:bg-[var(--white-a13)] focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[var(--accent-ring)]"
                >
                  Send link to my phone
                </a>
              )}

              {continueAnyway && (
                <button
                  onClick={() => {
                    sessionStorage.setItem("forceDesktop", "1");
                    location.reload();
                  }}
                  className="mt-1 self-start text-xs text-[color:var(--text-muted)] underline underline-offset-4 hover:text-foreground"
                >
                  Continue on desktop (not supported)
                </button>
              )}
            </div>
          </div>

          <footer className="mt-6 text-center text-xs text-[color:var(--text-muted)]">
            If you’re already on mobile and still see this, disable desktop mode
            or try rotating your device.
          </footer>
        </section>
      </div>
    </div>
  );
}

--- File: ./src/components/BottomNav.tsx ---
"use client";

import { usePathname, useRouter } from "next/navigation";
import { cn } from "@/lib/utils";
import { HomeIcon, LeaderboardIcon, ProfileIcon } from "./icons";

const navItems = [
  { icon: HomeIcon, label: "Lobby", href: "/lobby" },
  { icon: LeaderboardIcon, label: "Leaderboard", href: "/leaderboard" },
  { icon: ProfileIcon, label: "Profile", href: "/profile" },
];

export function BottomNav() {
  const pathname = usePathname();
  const router = useRouter();

  return (
    <nav className="fixed bottom-0 left-0 right-0 bg-figmaYay noise border-t-2 border-border z-50">
      <div className="flex items-center justify-around max-w-2xl mx-auto">
        {navItems.map((item) => {
          const Icon = item.icon;
          // Active if path starts with href as a segment (e.g. '/lobby' matches '/lobby/buy')
          const isActive =
            pathname === item.href || pathname.startsWith(item.href + "/");

          return (
            <button
              key={item.href}
              onClick={() => router.push(item.href)}
              className={cn(
                "flex flex-col items-center gap-1 py-3 px-6 transition-colors flex-1 ",
                isActive
                  ? "text-secondary-foreground"
                  : "text-muted-foreground hover:text-foreground"
              )}
            >
              <Icon
                className={cn(
                  "h-5 w-5 text-muted-foreground",
                  isActive && "animate-pulse-glow text-primary"
                )}
              />
              <span className="text-xs font-medium font-display">
                {item.label}
              </span>
            </button>
          );
        })}
      </div>
    </nav>
  );
}

--- File: ./src/components/providers/MinikitProvider.tsx ---
"use client";

import { OnchainKitProvider } from "@coinbase/onchainkit";
import { base } from "wagmi/chains";
import { env } from "@/lib/env";
import { useSyncUser } from "@/hooks/useSyncUser";
import { useMiniKit } from "@coinbase/onchainkit/minikit";

import { useEffect } from "react";

interface Props {
  children: React.ReactNode;
}

export function MinikitProvider({ children }: Props) {
  return (
    <OnchainKitProvider
      apiKey={env.nextPublicOnchainkitApiKey}
      chain={base}
      config={{
        appearance: {
          mode: "auto",
        },
        wallet: {
          display: "modal",
          preference: "all",
        },
      }}
      miniKit={{
        enabled: true,
        autoConnect: true,
        notificationProxyUrl: undefined,
      }}
    >
      <IsMiniAppReady>{children}</IsMiniAppReady>
    </OnchainKitProvider>
  );
}

function IsMiniAppReady({ children }: { children: React.ReactNode }) {
  useSyncUser();
  const { isFrameReady, setFrameReady } = useMiniKit();

  // Initialize the  miniapp
  useEffect(() => {
    if (!isFrameReady) {
      setFrameReady();
    }
  }, [setFrameReady, isFrameReady]);

  return <>{children}</>;
}

--- File: ./src/components/logo/Logo.tsx ---
import React from "react";

import Image from "next/image";

export default function Logo(props: React.ComponentProps<"div">) {
  return (
    <div {...props}>
      <Image src="/logo.png" alt="Logo" width={40} height={40} priority />
    </div>
  );
}

--- File: ./src/components/logo/LogoIcon.tsx ---
import React from "react";

// Use next/image for optimal .png rendering in Next.js apps.
import Image from "next/image";

// You must provide the image file at the given path in your project.
export default function LogoIcon(props: React.ComponentProps<"div">) {
  return (
    <div {...props}>
      <Image src="/logo-icon.png" alt="Logo" width={100} height={40} priority />
    </div>
  );
}

--- File: ./src/components/icons.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";
import * as React from "react";

export function HomeIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.58 2H10.58V4H8.58002V6H6.58002V8H4.58002V10H2.58002V12H4.58002V22H11.58V16H13.58V22H20.58V12H22.58V10H20.58V8H18.58V6H16.58V4H14.58V2ZM14.58 4V6H16.58V8H18.58V10H20.58V12H18.58V20H15.58V14H9.58002V20H6.58002V12H4.58002V10H6.58002V8H8.58002V6H10.58V4H14.58Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function LeaderboardIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M12.5 1H14.5V9H22.5V13H20.5V11H12.5V5H10.5V3H12.5V1ZM8.5 7V5H10.5V7H8.5ZM6.5 9V7H8.5V9H6.5ZM4.5 11V9H6.5V11H4.5ZM14.5 19V21H12.5V23H10.5V15H2.5V11H4.5V13H12.5V19H14.5ZM16.5 17V19H14.5V17H16.5ZM18.5 15V17H16.5V15H18.5ZM18.5 15H20.5V13H18.5V15Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function ProfileIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={25}
      height={24}
      viewBox="0 0 25 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.41998 3H21.42V21H3.41998V3ZM19.42 19V5H5.41998V19H19.42ZM14.42 7H10.42V11H14.42V7ZM15.42 13H9.41998V15H7.41998V17H9.41998V15H15.42V17H17.42V15H15.42V13Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function WalletIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M2 6.19998H13.4C13.5591 6.19998 13.7117 6.26319 13.8243 6.37571C13.9368 6.48823 14 6.64085 14 6.79998V12.8C14 12.9591 13.9368 13.1117 13.8243 13.2242C13.7117 13.3368 13.5591 13.4 13.4 13.4H2.6C2.44087 13.4 2.28826 13.3368 2.17574 13.2242C2.06321 13.1117 2 12.9591 2 12.8V6.19998ZM2.6 2.59998H11.6V4.99998H2V3.19998C2 3.04085 2.06321 2.88823 2.17574 2.77571C2.28826 2.66319 2.44087 2.59998 2.6 2.59998ZM9.8 9.19998V10.4H11.6V9.19998H9.8Z"
        fill="currentColor"
      />
    </svg>
  );
}
export function InviteIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={21}
      height={21}
      viewBox="0 0 21 21"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M15.5 2.16663H10.5V3.83329H8.83331V8.83329H10.5V3.83329H15.5V2.16663ZM15.5 8.83329H10.5V10.5H15.5V8.83329ZM15.5 3.83329H17.1666V8.83329H15.5V3.83329ZM6.33331 13.8333H7.99998V12.1666H18V13.8333H7.99998V17.1666H18V13.8333H19.6666V18.8333H6.33331V13.8333ZM2.99998 7.16663H4.66665V8.83329H6.33331V10.5H4.66665V12.1666H2.99998V10.5H1.33331V8.83329H2.99998V7.16663Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function InviteFriendsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M13.5 1.5H9V3H7.5V7.5H9V3H13.5V1.5ZM13.5 7.5H9V9H13.5V7.5ZM13.5 3H15V7.5H13.5V3ZM5.25 12H6.75V10.5H15.75V12H6.75V15H15.75V12H17.25V16.5H5.25V12ZM2.25 6H3.75V7.5H5.25V9H3.75V10.5H2.25V9H0.75V7.5H2.25V6Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function UploadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.25 3.75V2.25H9.75V3.75H11.25V5.25H12.75V6.75H11.25V5.25H9.75V12.75H8.25V5.25H6.75V6.75H5.25V5.25H6.75V3.75H8.25ZM2.25 11.25V15.75H15.75V11.25H14.25V14.25H3.75V11.25H2.25Z"
        fill="currentColor"
      />
    </svg>
  );
}

export function ArrowRightIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={18}
      height={18}
      viewBox="0 0 18 18"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3 8.25V9.75H12V11.25H13.5V9.75H15V8.25H13.5V6.75H12V8.25H3ZM10.5 5.25H12V6.75H10.5V5.25ZM10.5 5.25H9V3.75H10.5V5.25ZM10.5 12.75H12V11.25H10.5V12.75ZM10.5 12.75H9V14.25H10.5V12.75Z"
        fill="currentColor"
      />
    </svg>
  );
}

export const ArrowLeftIcon = (props: React.SVGProps<SVGSVGElement>) => (
  <svg
    width="18"
    height="18"
    viewBox="0 0 18 18"
    fill="none"
    xmlns="http://www.w3.org/2000/svg"
    {...props}
  >
    <path
      d="M15 8.25V9.75H6V11.25H4.5V9.75H3V8.25H4.5V6.75H6V8.25H15ZM7.5 5.25H6V6.75H7.5V5.25ZM7.5 5.25H9V3.75H7.5V5.25ZM7.5 12.75H6V11.25H7.5V12.75ZM7.5 12.75H9V14.25H7.5V12.75Z"
      fill="white"
    />
  </svg>
);

export function GamePadIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.33334 3.3335H14.6667V12.6668H1.33334V3.3335ZM13.3333 11.3335V4.66683H2.66668V11.3335H13.3333ZM5.33334 6.00016H6.66668V7.3335H8.00001V8.66683H6.66668V10.0002H5.33334V8.66683H4.00001V7.3335H5.33334V6.00016ZM9.33334 6.00016H10.6667V7.3335H9.33334V6.00016ZM12 8.66683H10.6667V10.0002H12V8.66683Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M4.00001 1.3335H10.6667V2.66683H4.00001V1.3335ZM2.66668 4.00016V2.66683H4.00001V4.00016H2.66668ZM2.66668 12.0002H1.33334V4.00016H2.66668V12.0002ZM4.00001 13.3335H2.66668V12.0002H4.00001V13.3335ZM12 13.3335H4.00001V14.6668H12V13.3335ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 12.0002H14.6667V5.3335H13.3333V12.0002ZM8.00001 4.00016H5.33334V5.3335H4.00001V10.6668H5.33334V12.0002H10.6667V10.6668H12V8.00016H10.6667V10.6668H5.33334V5.3335H8.00001V4.00016ZM9.33334 9.3335V6.66683H10.6667V5.3335H12V4.00016H14.6667V2.66683H13.3333V1.3335H12V4.00016H10.6667V5.3335H9.33334V6.66683H6.66668V9.3335H9.33334Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WinningsIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M3.99999 1.3335H12V2.66683H3.99999V1.3335ZM2.66666 4.00016V2.66683H3.99999V4.00016H2.66666ZM2.66666 12.0002V4.00016H1.33333V12.0002H2.66666ZM3.99999 13.3335V12.0002H2.66666V13.3335H3.99999ZM12 13.3335V14.6668H3.99999V13.3335H12ZM13.3333 12.0002V13.3335H12V12.0002H13.3333ZM13.3333 4.00016H14.6667V12.0002H13.3333V4.00016ZM13.3333 4.00016V2.66683H12V4.00016H13.3333ZM7.33333 3.3335H8.66666V4.66683H10.6667V6.00016H6.66666V7.3335H10.6667V11.3335H8.66666V12.6668H7.33333V11.3335H5.33333V10.0002H9.33333V8.66683H5.33333V4.66683H7.33333V3.3335Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function ZapIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M8.00001 0.666504H9.33334V5.99984H14.6667V8.6665H13.3333V7.33317H8.00001V3.33317H6.66668V1.99984H8.00001V0.666504ZM5.33334 4.6665V3.33317H6.66668V4.6665H5.33334ZM4.00001 5.99984V4.6665H5.33334V5.99984H4.00001ZM2.66668 7.33317V5.99984H4.00001V7.33317H2.66668ZM9.33334 12.6665V13.9998H8.00001V15.3332H6.66668V9.99984H1.33334V7.33317H2.66668V8.6665H8.00001V12.6665H9.33334ZM10.6667 11.3332V12.6665H9.33334V11.3332H10.6667ZM12 9.99984V11.3332H10.6667V9.99984H12ZM12 9.99984H13.3333V8.6665H12V9.99984Z"
        fill="#FFC931"
      />
    </svg>
  );
}

export function WaffleIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="13"
      viewBox="0 0 16 13"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M1.04242 2.73877H3.72203V11.3731H1.04242V2.73877Z"
        fill="#FFC931"
      />
      <path
        d="M13.1901 0.0595703H15.8697L15.8548 8.64922L13.1901 8.69388V0.0595703Z"
        fill="#FFC931"
      />
      <path
        d="M1.04242 11.3735V8.69385H6.40164V11.3735H1.04242Z"
        fill="#FFC931"
      />
      <path
        d="M10.5104 11.3735V8.69385H13.19V11.3735H10.5104Z"
        fill="#FFC931"
      />
      <path
        d="M3.72208 2.73918V0.0595703H15.8696V2.73918H3.72208Z"
        fill="#FFC931"
      />
      <path
        d="M9.66196 9.51262L10.4807 8.69385H12.2522V9.55728L9.66196 9.51262Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 9.5275L3.72208 8.69385L6.32726 8.72362L5.56804 9.5275H2.88843Z"
        fill="#FB72FF"
      />
      <path
        d="M2.88843 3.72168H3.69231V8.69385L2.88843 9.49773V3.72168Z"
        fill="#00CFF2"
      />
      <path
        d="M15.8995 2.76894H15.8948L15.8846 8.64926V8.67847L15.8555 8.67898L13.2199 8.72313V11.4032H10.4808V9.5564L9.66138 9.54241L9.59133 9.54121L10.4685 8.66409H13.1604V2.76894H3.75195V8.66409H6.43156V11.4032H1.01279V2.7094H3.6924V0.0297852H15.8995V2.76894Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M0.149292 3.63184H2.8289V12.2661H0.149292V3.63184Z"
        fill="#FFC931"
      />
      <path
        d="M12.2969 0.952637H14.9765V9.58694H12.2969V0.952637Z"
        fill="#FFC931"
      />
      <path
        d="M0.149292 12.2665V9.58691H5.50852V12.2665H0.149292Z"
        fill="#FFC931"
      />
      <path
        d="M9.61728 12.2665V9.58691H12.2969V12.2665H9.61728Z"
        fill="#FFC931"
      />
      <path
        d="M2.82895 3.63225V3.58759V2.73904V0.952637H14.9765V3.63225H2.82895Z"
        fill="#FFC931"
      />
      <path
        d="M5.57784 7.97606V7.09321H4.61276V6.34748H5.57784V5.35498H6.27972V6.34748H7.25027V7.09321H6.27972V7.97606H5.57784Z"
        fill="#FB72FF"
      />
      <path
        d="M11.2249 6.6694C11.2249 7.40936 10.625 8.0092 9.88509 8.0092C9.14513 8.0092 8.54529 7.40936 8.54529 6.6694C8.54529 5.92944 9.14513 5.32959 9.88509 5.32959C10.625 5.32959 11.2249 5.92944 11.2249 6.6694Z"
        fill="#00CFF2"
      />
      <path
        d="M14.9764 0.952536V3.63215V9.58684L15.8547 8.67875V0.0742188L14.9764 0.952536Z"
        fill="#00CFF2"
      />
      <path
        d="M12.2969 0.952774H14.9765L15.8548 0.074457L3.67749 0.0595703L2.82895 0.952774H12.2969Z"
        fill="#FB72FF"
      />
      <path
        d="M2.8289 2.73877H1.0425L0.149292 3.58731H2.8289V2.73877Z"
        fill="#FB72FF"
      />
      <path
        d="M13.1901 11.3589L12.4085 12.2522C12.3904 12.2727 12.3564 12.2599 12.3564 12.2325V9.64697H13.1901V11.3589Z"
        fill="#00CFF2"
      />
      <path
        d="M9.88512 5.29972C10.6417 5.29972 11.2547 5.9129 11.2547 6.6693C11.2547 7.42569 10.6417 8.03888 9.88512 8.03888C9.12873 8.03888 8.51554 7.42569 8.51554 6.6693C8.51554 5.9129 9.12873 5.29972 9.88512 5.29972ZM6.30936 5.32544V6.31794H7.27994V7.12322H6.30936V8.00607H5.54796V7.12322H4.58288V6.31794H5.54796V5.32544H6.30936ZM15.8845 8.69103L15.8761 8.6997L14.9978 9.60794L14.9889 9.61687H13.2197V11.3699L13.2123 11.3783L12.4308 12.2715C12.3947 12.3129 12.3265 12.2873 12.3265 12.2322V12.2965H9.58739V9.55732H12.267V3.66218H2.85858V9.55732H5.5382V12.2965H0.119425V3.61752H0.0746155L0.128714 3.56616L1.02192 2.71761L1.03052 2.70943H2.79904V0.940913L2.80723 0.932308L3.65577 0.0391039L3.66458 0.0297852L3.67738 0.0298142L15.8547 0.044701L15.8845 0.04473V8.69103Z"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
      <path
        d="M6.36393 8.70556C6.38463 8.68931 6.41666 8.70369 6.41666 8.73156V11.37L6.40943 11.3783L5.61406 12.2992C5.57779 12.3415 5.50884 12.3153 5.50943 12.2599L5.53834 9.60201L5.53846 9.5904L5.54635 9.58206L6.35997 8.70923L6.36393 8.70556Z"
        fill="#00CFF2"
        stroke="#1E1E1E"
        strokeWidth="0.0595469"
      />
    </svg>
  );
}

export function LeaveGameIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width={16}
      height={16}
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      {...props}
    >
      <path
        d="M14.5228 15.9831V14.531H13.0686V15.9831H14.5228Z"
        fill="#331A39"
      />
      <path
        d="M13.0685 15.9999V14.5479H11.6165V15.9999H13.0685Z"
        fill="#331A39"
      />
      <path
        d="M11.6166 15.9662V14.5142H10.1646V15.9662H11.6166Z"
        fill="#331A39"
      />
      <path
        d="M10.1645 15.9662V14.5142H8.7124V15.9662H10.1645Z"
        fill="#331A39"
      />
      <path
        d="M8.71232 15.9662V14.5142H7.26025V15.9662H8.71232Z"
        fill="#331A39"
      />
      <path
        d="M7.26031 15.9662V14.5142L5.81665 14.531V15.983L7.26031 15.9662Z"
        fill="#331A39"
      />
      <path
        d="M5.79142 15.9662V14.5142H4.33936V15.9662H5.79142Z"
        fill="#331A39"
      />
      <path
        d="M4.33927 15.9662V14.5142H2.88721V15.9662H4.33927Z"
        fill="#331A39"
      />
      <path d="M14.506 15.9662V14.5142H1.4353V15.9662H14.506Z" fill="#331A39" />
      <path
        d="M14.5396 14.5142H15.9916V13.0601H14.5396V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 14.5311H14.5311V13.0769H13.0769V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 14.5079H13.0771V13.0537H11.625V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 14.5079H11.6249V13.0537H10.1729V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 14.5079H10.1728V13.0537H8.7207V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 14.5079H8.72086V13.0537H7.2688V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 14.5079H7.26871V13.0537H5.81665V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 14.5079H5.81657V13.0537H4.3645V14.5079Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9126 14.5311H4.36466V13.0769H2.9126V14.5311Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 14.5311H2.91471V13.0769H1.46265V14.5311Z"
        fill="#EA7EBD"
      />
      <path d="M0 14.5311H1.45206V13.0769H0V14.5311Z" fill="#331A39" />
      <path d="M14.5396 13.06H15.9916V11.6079H14.5396V13.06Z" fill="#331A39" />
      <path
        d="M13.0769 13.0768H14.5311V11.6248H13.0769V13.0768Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 13.0539H11.6249V11.6018H10.1729V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 13.0539H10.1728V11.6018H8.7207V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 13.0539H8.72086V11.6018H7.2688V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 13.0539H7.26871V11.6018H5.81665V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 13.0539H5.81657V11.6018H4.3645V13.0539Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 13.0768H2.91471V11.6248H1.46265V13.0768Z"
        fill="#EA7EBD"
      />
      <path d="M0 13.0768H1.45206V11.6248H0V13.0768Z" fill="#331A39" />
      <path
        d="M14.5396 11.608H15.9916V10.1538H14.5396V11.608Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 11.6248H14.5311V10.1707H13.0769V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 11.6016H13.0771V10.1475H11.625V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 11.6016H10.1728V10.1475H8.7207V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 11.6016H8.72086V10.1475H7.2688V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 11.6016H7.26871V10.1475H5.81665V11.6016Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 11.6248H4.36661V10.1707H2.91455V11.6248Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 11.6248H2.91471V10.1707H1.46265V11.6248Z"
        fill="#EA7EBD"
      />
      <path d="M0 11.6248H1.45206V10.1707H0V11.6248Z" fill="#331A39" />
      <path
        d="M14.5396 10.1537H15.9916V8.70166H14.5396V10.1537Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 10.1706H14.5311V8.71851H13.0769V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 10.1475H13.0771V8.69336H11.625V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 10.1475H11.6249V8.69336H10.1729V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 10.1475H8.72086V8.69336H7.2688V10.1475Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 10.1706H5.81657V8.71851H4.3645V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 10.1706H4.36661V8.71851H2.91455V10.1706Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 10.1706H2.91471V8.71851H1.46265V10.1706Z"
        fill="#EA7EBD"
      />
      <path d="M0 10.1706H1.45206V8.71851H0V10.1706Z" fill="#331A39" />
      <path
        d="M14.5059 8.70172H15.9579V7.24756H14.5059V8.70172Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 8.71857H14.5311V7.2644H13.0769V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 8.69327H13.0771V7.24121H11.625V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 8.69327H11.6249V7.24121H10.1729V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 8.69327H10.1728V7.24121H8.7207V8.69327Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 8.71857H7.26871V7.2644H5.81665V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 8.71857H5.81657V7.2644H4.3645V8.71857Z" fill="#EA7EBD" />
      <path
        d="M2.91455 8.71857H4.36661V7.2644H2.91455V8.71857Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 8.71857H2.91471V7.2644H1.46265V8.71857Z"
        fill="#EA7EBD"
      />
      <path d="M0 8.71857H1.45206V7.2644H0V8.71857Z" fill="#331A39" />
      <path
        d="M14.5059 7.24772H15.9579V5.79565H14.5059V7.24772Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 7.26432H14.5311V5.81226H13.0769V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 7.24127H13.0771V5.78711H11.625V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 7.24127H11.6249V5.78711H10.1729V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 7.24127H8.72086V5.78711H7.2688V7.24127Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 7.26432H5.81657V5.81226H4.3645V7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.9147 7.26432H4.36676L4.36466 5.81226H2.9126L2.9147 7.26432Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 7.26432H2.91471V5.81226H1.46265V7.26432Z"
        fill="#EA7EBD"
      />
      <path d="M0 7.26432H1.45206V5.81226H0V7.26432Z" fill="#331A39" />
      <path
        d="M14.5059 5.79547H15.9579V4.34131H14.5059V5.79547Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 5.81232H14.5311V4.35815H13.0769V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M11.625 5.78702H13.0771V4.33496H11.625V5.78702Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 5.81232H10.1728V4.35815H8.7207V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 5.81232H8.72086V4.35815H7.2688V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.83984 5.81232H7.29191V4.35815H5.83984V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M2.91455 5.81232H4.36661V4.35815H2.91455V5.81232Z"
        fill="#EA7EBD"
      />
      <path
        d="M1.46265 5.81232H2.91471V4.35815H1.46265V5.81232Z"
        fill="#EA7EBD"
      />
      <path d="M0 5.81232H1.45206V4.35815H0V5.81232Z" fill="#331A39" />
      <path
        d="M14.5059 4.34147H15.9579V2.8894H14.5059V4.34147Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 4.35831H14.5311V2.90625H13.0769V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M10.1729 4.35831H11.6249V2.90625H10.1729V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M8.7207 4.35831H10.1728V2.90625H8.7207V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M7.2688 4.35831H8.72086V2.90625H7.2688V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M5.81665 4.35831H7.26871V2.90625H5.81665V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M4.3645 4.35831H5.81657V2.90625H4.3645V4.35831Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 13.0768H13.0771V11.6248H11.625V13.0768Z" fill="white" />
      <path d="M2.9126 13.0768H4.36466V11.6248H2.9126V13.0768Z" fill="white" />
      <path
        d="M10.1729 11.6248H11.6249V10.1707H10.1729V11.6248Z"
        fill="white"
      />
      <path
        d="M4.36475 11.6248H5.81681V10.1707H4.36475V11.6248Z"
        fill="white"
      />
      <path d="M8.72095 10.1706H10.173V8.71851H8.72095V10.1706Z" fill="white" />
      <path
        d="M5.81665 10.1706H7.26871V8.71851H5.81665V10.1706Z"
        fill="white"
      />
      <path d="M7.2688 8.71857H8.72086V7.2644H7.2688V8.71857Z" fill="white" />
      <path d="M8.72095 7.26456H10.173V5.8125H8.72095V7.26456Z" fill="white" />
      <path d="M5.81665 7.26456H7.26871V5.8125H5.81665V7.26456Z" fill="white" />
      <path
        d="M10.1729 5.81232H11.6249V4.35815H10.1729V5.81232Z"
        fill="white"
      />
      <path
        d="M4.36475 5.81232H5.81681V4.35815H4.36475V5.81232Z"
        fill="white"
      />
      <path d="M11.625 4.35831H13.0771V2.90625H11.625V4.35831Z" fill="white" />
      <path d="M2.9126 4.35831H4.36466V2.90625H2.9126V4.35831Z" fill="white" />
      <path
        d="M1.46265 4.35831H2.91471V2.90625H1.46265V4.35831Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 4.35831H1.46036V2.90625H0.00830078V4.35831Z"
        fill="#331A39"
      />
      <path
        d="M14.5312 14.5142H15.9833V1.4519H14.5312V14.5142Z"
        fill="#331A39"
      />
      <path
        d="M13.0769 2.90607H14.5311V1.4519H13.0769V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M11.625 2.90607H13.0771V1.4519H11.625V2.90607Z" fill="#E97BBB" />
      <path
        d="M10.1729 2.90607H11.6249V1.4519H10.1729V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M8.7207 2.90607H10.1728V1.4519H8.7207V2.90607Z" fill="#EA7EBD" />
      <path d="M7.2688 2.90607H8.72086V1.4519H7.2688V2.90607Z" fill="#EA7EBD" />
      <path
        d="M5.81665 2.90607H7.26871V1.4519H5.81665V2.90607Z"
        fill="#EA7EBD"
      />
      <path d="M4.3645 2.90607H5.81657V1.4519H4.3645V2.90607Z" fill="#EA7EBD" />
      <path d="M2.9126 2.90607H4.36466V1.4519H2.9126V2.90607Z" fill="#EA7EBD" />
      <path
        d="M1.46265 2.90607H2.91471V1.4519H1.46265V2.90607Z"
        fill="#EA7EBD"
      />
      <path
        d="M0.00830078 2.90607H1.46036V1.4519H0.00830078V2.90607Z"
        fill="#331A39"
      />
      <path d="M13.0769 0V1.45206H14.5311V0H13.0769Z" fill="#331A39" />
      <path d="M11.625 0V1.45206H13.0771V0H11.625Z" fill="#331A39" />
      <path d="M10.1729 0V1.45206H11.6249V0H10.1729Z" fill="#331A39" />
      <path d="M8.7207 0V1.45206H10.1728V0H8.7207Z" fill="#331A39" />
      <path
        d="M7.26245 0.00634766V1.45841H8.71451V0.00634766H7.26245Z"
        fill="#331A39"
      />
      <path
        d="M5.81665 0V1.45206L7.26241 1.45837V0.00630392L5.81665 0Z"
        fill="#331A39"
      />
      <path
        d="M4.3645 0V1.45206L5.81026 1.45837V0.00630392L4.3645 0Z"
        fill="#331A39"
      />
      <path d="M2.9126 0V1.45206H4.36466V0H2.9126Z" fill="#331A39" />
      <path d="M1.46265 0V1.45206H14.5396V0H1.46265Z" fill="#331A39" />
    </svg>
  );
}

export function Clock({
  className = "",
  style,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) {
  return (
    <span className={cn("w-20 h-20", className)} style={style} {...props}>
      <Image
        src="/images/icons/clock.svg"
        alt="Clock"
        fill
        style={{ objectFit: "contain" }}
        className="!relative w-full h-full"
        draggable={false}
        priority={false}
      />
    </span>
  );
}

export function ForwardMessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M14 5H12V9H6V11H4V17H6V15H12V19H14V17H16V15H18V13H20V11H18V9H16V7H14V5Z"
        fill="white"
      />
    </svg>
  );
}

export function MessageIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M22 2H2V16H4V4H20V16H12V18H10V20H8V16H2V18H6V22H10V20H12V18H22V2Z"
        fill="#1B8FF5"
      />
    </svg>
  );
}

export function CopyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M17.5 14.9998H5.83333V1.6665H12.5V3.33317H14.1667V4.99984H12.5V6.6665H14.1667V4.99984H15.8333V6.6665H17.5V14.9998ZM7.5 3.33317V13.3332H15.8333V8.33317H10.8333V3.33317H7.5ZM2.5 4.99984H4.16667V16.6665H14.1667V18.3332H2.5V4.99984Z"
        fill="#00CFF2"
      />
    </svg>
  );
}

export function TrophyIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="20"
      height="20"
      viewBox="0 0 20 20"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <path
        d="M10.75 13.7035V15.25H14.5V16.75H5.5V15.25H9.25V13.7035C7.80002 13.5207 6.46661 12.8149 5.5 11.7188C4.53339 10.6227 4.00002 9.21146 4 7.75V3.25H16V7.75C16 9.21146 15.4666 10.6227 14.5 11.7188C13.5334 12.8149 12.2 13.5207 10.75 13.7035ZM1.75 4.75H3.25V7.75H1.75V4.75ZM16.75 4.75H18.25V7.75H16.75V4.75Z"
        fill={props.color || "#34C759"}
      />
    </svg>
  );
}

export function UsdcIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      width="16"
      height="16"
      viewBox="0 0 16 16"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
      aria-hidden="true"
      {...props}
    >
      <g clipPath="url(#clip0_268_39833)">
        <path
          d="M7.87865 15.5198C12.0512 15.5198 15.4081 12.1629 15.4081 7.99035C15.4081 3.81778 12.0512 0.460938 7.87865 0.460938C3.70608 0.460938 0.349243 3.81778 0.349243 7.99035C0.349243 12.1629 3.70608 15.5198 7.87865 15.5198Z"
          fill="#2775CA"
        />
        <path
          d="M9.94932 9.1832C9.94932 8.08518 9.29051 7.70871 7.97288 7.55187C7.03172 7.42635 6.84348 7.1754 6.84348 6.73613C6.84348 6.29686 7.15723 6.01458 7.78465 6.01458C8.34934 6.01458 8.66309 6.20282 8.81993 6.67341C8.85132 6.76753 8.94544 6.83025 9.03956 6.83025H9.54146C9.66697 6.83025 9.76109 6.73613 9.76109 6.61069V6.57929C9.63558 5.88907 9.07088 5.35576 8.34934 5.29304V4.54009C8.34934 4.41458 8.25523 4.32046 8.09839 4.28906H7.62781C7.5023 4.28906 7.40818 4.38318 7.37678 4.54009V5.26164C6.43562 5.38716 5.8396 6.01458 5.8396 6.79893C5.8396 7.83422 6.46702 8.24202 7.78465 8.39893C8.66309 8.55577 8.94544 8.74401 8.94544 9.246C8.94544 9.74798 8.50618 10.0931 7.91016 10.0931C7.09443 10.0931 6.81209 9.74791 6.71797 9.27732C6.68665 9.15188 6.59253 9.08908 6.49841 9.08908H5.96504C5.8396 9.08908 5.74548 9.1832 5.74548 9.30872V9.34011C5.87092 10.1244 6.3729 10.6891 7.40818 10.846V11.5989C7.40818 11.7244 7.5023 11.8185 7.65913 11.8499H8.12971C8.25523 11.8499 8.34934 11.7558 8.38074 11.5989V10.846C9.32191 10.6891 9.94932 10.0303 9.94932 9.1832Z"
          fill="white"
        />
        <path
          d="M6.27942 12.4778C3.83236 11.5994 2.57743 8.86997 3.48729 6.45423C3.95787 5.13658 4.99317 4.13269 6.27942 3.6621C6.40493 3.59938 6.46765 3.50526 6.46765 3.34835V2.90916C6.46765 2.78364 6.40493 2.68953 6.27942 2.6582C6.24802 2.6582 6.1853 2.6582 6.1539 2.68953C3.17354 3.6307 1.54214 6.79938 2.48331 9.77975C3.04802 11.5366 4.39706 12.8856 6.1539 13.4503C6.27942 13.5131 6.40493 13.4503 6.43626 13.3248C6.46765 13.2935 6.46765 13.2621 6.46765 13.1994V12.7601C6.46765 12.666 6.37354 12.5406 6.27942 12.4778ZM9.60493 2.68953C9.47942 2.62681 9.3539 2.68953 9.32258 2.81504C9.29118 2.84644 9.29118 2.87776 9.29118 2.94056V3.37975C9.29118 3.50526 9.3853 3.6307 9.47942 3.6935C11.9265 4.57188 13.1814 7.30129 12.2715 9.71703C11.801 11.0347 10.7657 12.0386 9.47942 12.5092C9.3539 12.5719 9.29118 12.666 9.29118 12.8229V13.2621C9.29118 13.3876 9.3539 13.4817 9.47942 13.5131C9.51082 13.5131 9.57354 13.5131 9.60493 13.4817C12.5853 12.5406 14.2167 9.37188 13.2755 6.39151C12.7108 4.60328 11.3304 3.25423 9.60493 2.68953Z"
          fill="white"
        />
      </g>
      <defs>
        <clipPath id="clip0_268_39833">
          <rect width="16" height="16" fill="white" />
        </clipPath>
      </defs>
    </svg>
  );
}

--- File: ./src/components/onboarding/OnboardingGate.tsx ---
"use client";

import { useOnboarding } from "@/hooks/useOnboarding";
import { OnboardingOverlay } from "./OnboardingOverlay";

interface Props {
  children: React.ReactNode;
}

/**
 * Wraps the app to present the onboarding overlay to first-time users.
 * Blocks interaction until onboarding is completed to ensure key concepts are seen.
 */
export function OnboardingGate({ children }: Props) {
  const { isReady, shouldShowOnboarding, completeOnboarding } = useOnboarding();

  if (!isReady) return null;

  return (
    <>
      {children}
      {shouldShowOnboarding && (
        <OnboardingOverlay onComplete={completeOnboarding} />
      )}
    </>
  );
}

--- File: ./src/components/onboarding/OnboardingOverlay.tsx ---
"use client";

import Image from "next/image";
import { OnboardingCarousel } from "./OnboardingCarousel";

interface OnboardingOverlayProps {
  onComplete: () => void;
}

/**
 * Full-screen onboarding overlay that reuses the existing onboarding UI.
 * Renders above the app and blocks interaction until completion.
 */
export function OnboardingOverlay({ onComplete }: OnboardingOverlayProps) {
  return (
    <div className="fixed inset-0 z-50 bg-figma noise flex flex-col">
      <div className="p-8 flex items-center justify-center">
        <Image
          src="/logo-icon.png"
          alt="Logo"
          width={150}
          height={80}
          priority
        />
      </div>
      <div className="flex-1">
        <OnboardingCarousel onComplete={onComplete} />
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/OnboardingCarousel.tsx ---
"use client";

import { useState } from "react";
import { OnboardingSlide } from "./OnboardingSlide";
import { FancyBorderButton } from "@/components/buttons/FancyBorderButton";

interface Slide {
  icon: string;
  title: string;
  description: string;
}

const slides: Slide[] = [
  {
    icon: "/images/illustration/waffle-ticket.png",
    title: "Buy a Waffle",
    description:
      "Buy your ticket, play the game, and share in the prize pool with other winners",
  },
  {
    icon: "/images/illustration/money-bag.png",
    title: "Win Big",
    description: "The faster you connect the dots, the bigger your share",
  },
  {
    icon: "/images/illustration/crown.png",
    title: "Take Your",
    description: "Recognize the images, climb the leaderboard. EZ",
  },
];

interface OnboardingCarouselProps {
  onComplete: () => void;
}

export function OnboardingCarousel({ onComplete }: OnboardingCarouselProps) {
  const [currentSlide, setCurrentSlide] = useState(0);

  const handleNext = () => {
    if (currentSlide < slides.length - 1) {
      setCurrentSlide(currentSlide + 1);
    } else {
      onComplete();
    }
  };

  return (
    <div className="flex flex-col h-full">
      <div className="flex-1 flex items-center justify-center">
        <OnboardingSlide
          key={currentSlide}
          icon={slides[currentSlide].icon}
          title={slides[currentSlide].title}
          description={slides[currentSlide].description}
        />
      </div>

      <div className="p-6 space-y-3 mb-10">
        <FancyBorderButton onClick={handleNext} className="w-full">
          {currentSlide === 0 ? "Next" : "Let's Go"}
        </FancyBorderButton>
      </div>
    </div>
  );
}

--- File: ./src/components/onboarding/OnboardingSlide.tsx ---
import { cn } from "@/lib/utils";
import Image from "next/image";

interface OnboardingSlideProps {
  icon: string;
  title: string;
  description: string;
  className?: string;
}

export function OnboardingSlide({
  icon,
  title,
  description,
  className,
}: OnboardingSlideProps) {
  return (
    <div
      className={cn(
        "flex flex-col items-center justify-center text-center px-8 py-12",
        className
      )}
    >
      <div className="mb-8 animate-in-right relative w-48 h-48">
        <Image src={icon} alt={title} fill className="object-contain" />
      </div>
      <h2 className="text-3xl font-bold mb-4 text-balance animate-in-right uppercase tracking-wider">
        {title}
      </h2>
      <p className="text-lg text-center font-display text-muted max-w-md text-pretty animate-in-right">
        {description}
      </p>
    </div>
  );
}

--- File: ./src/components/inputs/PixelInput.tsx ---
import type { InputHTMLAttributes } from "react";
import { cn } from "@/lib/utils";

interface PixelInputProps extends InputHTMLAttributes<HTMLInputElement> {
  className?: string;
}

export function PixelInput({ className, ...props }: PixelInputProps) {
  return (
    <input
      type="text"
      className={cn(
        "w-full h-14 bg-[#2a2a2a] border-none text-[#a0a0a0] placeholder:text-[#5a5a5a]",
        "text-center font-input text-xl tracking-wider rounded-lg",
        "focus-visible:ring-[#00cff2] focus-visible:ring-2",
        className
      )}
      {...props}
    />
  );
}

--- File: ./src/hooks/useMiniUser.ts ---
"use client";

import { useMiniKit } from "@coinbase/onchainkit/minikit";
import { useAccount } from "wagmi";

/**
 * Merges Farcaster + wallet identity into one consistent hook.
 */
export function useMiniUser() {
  const { context, isMiniAppReady } = useMiniKit();
  const { address, isConnected } = useAccount();

  const user = {
    fid: context?.user?.fid ?? null,
    username: context?.user?.username ?? "",
    pfpUrl: context?.user?.pfpUrl ?? "",
    wallet: address ?? "",
    isConnected,
    isMiniAppReady,
  };

  return user;
}

--- File: ./src/hooks/useVibration.ts ---
export function useVibration() {
  const vibrate = (pattern: number | number[] = 80) => {
    if (typeof window !== "undefined" && "vibrate" in navigator)
      navigator.vibrate(pattern);
  };
  return { vibrate };
}

--- File: ./src/hooks/useFlowRedirect.ts ---
"use client";

import { useEffect } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useLobbyStore } from "@/stores/lobbyStore";
import { useGameStore } from "@/stores/gameStore";

/**
 * Ensures user flow stays consistent:
 * - skips invite if already entered
 * - skips buy if ticket exists
 * - skips lobby if ready to play
 */
export function useFlowRedirect() {
  const router = useRouter();
  const pathname = usePathname();

  const { referralCode, referralStatus, ticket, purchaseStatus } =
    useLobbyStore();

  const { gameState } = useGameStore();

  useEffect(() => {
    // wait until store is hydrated
    if (referralStatus === "idle") return;

    const hasInvite = referralCode && referralStatus === "success";
    const hasTicket = !!ticket;
    const isConfirmed = purchaseStatus === "confirmed";

    if (!hasInvite && pathname !== "/lobby/invite-code") {
      router.replace("/lobby/invite-code");
      return;
    }

    if (hasInvite && !hasTicket && pathname !== "/lobby/buy") {
      router.replace("/lobby/buy");
      return;
    }

    if (hasTicket && !isConfirmed && pathname !== "/lobby/confirm") {
      router.replace("/lobby/confirm");
      return;
    }

    if (hasInvite && hasTicket && isConfirmed) {
      // if in lobby pages but user already ready
      if (pathname.startsWith("/lobby")) {
        router.replace("/game");
      }
      return;
    }

    // if game already in progress, always go to /game
    if (gameState && gameState !== "LOBBY" && pathname !== "/game") {
      router.replace("/game");
    }
  }, [
    router,
    pathname,
    referralCode,
    referralStatus,
    ticket,
    purchaseStatus,
    gameState,
  ]);
}

--- File: ./src/hooks/useOnboarding.ts ---
"use client";

import { useCallback, useEffect, useState } from "react";

const ONBOARDING_STORAGE_KEY = "waffles:onboarded:v1";

/**
 * Manages first-time user onboarding state with safe, persistent storage.
 * We intentionally scope persistence to the device (localStorage) to avoid
 * leaking cross-account state and to keep UX snappy without server roundtrips.
 */
export function useOnboarding() {
  const [isOnboarded, setIsOnboarded] = useState<boolean>(true);
  const [isReady, setIsReady] = useState<boolean>(false);

  useEffect(() => {
    try {
      const stored =
        typeof window !== "undefined"
          ? window.localStorage.getItem(ONBOARDING_STORAGE_KEY)
          : null;
      setIsOnboarded(stored === "true");
    } catch (_err) {
      console.log(_err);
      // If storage is blocked, default to showing onboarding once
      setIsOnboarded(false);
    } finally {
      setIsReady(true);
    }
  }, []);

  const completeOnboarding = useCallback(() => {
    try {
      if (typeof window !== "undefined") {
        window.localStorage.setItem(ONBOARDING_STORAGE_KEY, "true");
      }
    } catch (_err) {
      console.log(_err);
      // Non-fatal: proceed even if storage fails
    }
    setIsOnboarded(true);
  }, []);

  return {
    isReady,
    isOnboarded,
    shouldShowOnboarding: isReady && !isOnboarded,
    // for testing
    // shouldShowOnboarding: true,
    completeOnboarding,
  };
}

--- File: ./src/hooks/useSyncUser.ts ---
"use client";

import { useEffect } from "react";
import { useMiniUser } from "@/hooks/useMiniUser";

export function useSyncUser() {
  const { fid, username, pfpUrl, wallet, isMiniAppReady } = useMiniUser();

  useEffect(() => {
    if (!isMiniAppReady || !fid || !wallet) return;

    const syncUser = async () => {
      try {
        await fetch("/api/user/sync", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            fid,
            username,
            pfpUrl,
            wallet,
          }),
        });
      } catch (err) {
        console.error("Failed to sync user:", err);
      }
    };

    syncUser();
  }, [fid, wallet, username, pfpUrl, isMiniAppReady]);
}

--- File: ./src/hooks/useSound.ts ---
export function useSound() {
  const play = (src: string, volume = 0.6) => {
    const audio = new Audio(src);
    audio.volume = volume;
    audio.play().catch(() => {});
  };
  return { play };
}

--- File: ./src/hooks/useIsMobile.ts ---
"use client";

import { useEffect, useMemo, useState } from "react";

const UA_MOBILE_REGEX =
  /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile|WPDesktop|Mobile/i;

export function useIsMobile() {
  const [vw, setVw] = useState<number | null>(null);
  const [ua, setUa] = useState<string>("");

  useEffect(() => {
    // viewport width
    const update = () => setVw(window.innerWidth);
    update();
    window.addEventListener("resize", update);
    return () => window.removeEventListener("resize", update);
  }, []);

  useEffect(() => {
    setUa(navigator.userAgent || "");
  }, []);

  // heuristics: UA OR small viewport
  return useMemo(() => {
    const uaLooksMobile = UA_MOBILE_REGEX.test(ua);
    const viewportLooksMobile = (vw ?? 0) <= 900; // tweak threshold as you like
    return uaLooksMobile || viewportLooksMobile;
  }, [ua, vw]);
}

--- File: ./src/lib/supabaseClient.ts ---
// src/lib/supabaseClient.ts
import { createClient } from "@supabase/supabase-js";
import { env } from "./env";

export const supabase = createClient(
  env.nextPublicSupabaseUrl,
  env.nextPublicSupabaseAnonKey,
  {
    realtime: { params: { eventsPerSecond: 1 } },
  }
);

--- File: ./src/lib/utils.ts ---
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

--- File: ./src/lib/scoring.ts ---
export function calculateScore(timeTaken: number, maxTime: number): number {
  const speedRatio = (maxTime - timeTaken) / maxTime;
  const basePoints = 300 + speedRatio * 2700; // between 300–3000
  return Math.round(basePoints);
}

export function isMatch(choiceId: number, targetId: number): boolean {
  // In real version: compare identifiers for correct pair
  return choiceId === targetId;
}

--- File: ./src/lib/SoundManager.ts ---
// src/utils/SoundManager.ts
class SoundManager {
  private static instance: SoundManager;
  private audioContext?: AudioContext;
  private sounds: Map<string, HTMLAudioElement> = new Map();

  private constructor() {
    // Preload sound files
    const soundFiles: Record<string, string> = {
      click: "/sounds/click.mp3",
      countdown: "/sounds/countdown.mp3",
      correct: "/sounds/correct.mp3",
      wrong: "/sounds/wrong.mp3",
      gameOver: "/sounds/gameOver.mp3",
      // Add more sounds as needed
    };
    for (const [key, url] of Object.entries(soundFiles)) {
      const audio = new Audio(url);
      audio.load();
      this.sounds.set(key, audio);
    }
  }

  public static getInstance(): SoundManager {
    if (!SoundManager.instance) {
      SoundManager.instance = new SoundManager();
    }
    return SoundManager.instance;
  }

  /** Call this on first user interaction (click/tap) to enable audio on browsers */
  public async init(): Promise<void> {
    if (!this.audioContext) {
      this.audioContext = new (window.AudioContext ||
        (window as unknown as { webkitAudioContext: AudioContext })
          .webkitAudioContext)();
      // Resume context (needed for mobile autoplay policy)
      await this.audioContext.resume();
    }
  }

  /** Play a loaded sound effect by name */
  public play(soundName: string): void {
    const audio = this.sounds.get(soundName);
    if (!audio) {
      console.warn(`Sound "${soundName}" not found`);
      return;
    }
    try {
      audio.currentTime = 0;
      audio.play();
    } catch (error) {
      // Playback might fail if not initiated by user gesture yet; safe to ignore or log
      console.warn(`Failed to play sound "${soundName}":`, error);
    }
  }
}

export default SoundManager.getInstance();

--- File: ./src/lib/env.ts ---
export const env = {
  rootUrl:
    // "https://0b967d9de060.ngrok-free.app" ||
    process.env.NEXT_PUBLIC_URL ||
    (process.env.VERCEL_PROJECT_PRODUCTION_URL
      ? `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`
      : "http://localhost:3000"),

  neynarApiKey: process.env.NEYNAR_API_KEY!,
  databaseUrl: process.env.DATABASE_URL!,
  nextPublicAppUrl: process.env.NEXT_PUBLIC_APP_URL!,
  nextPublicOnchainkitApiKey: process.env.NEXT_PUBLIC_ONCHAINKIT_API_KEY!,
  waffleMainAddress: process.env.WAFFLE_MAIN_ADDRESS as `0x${string}`,
  nextPublicReceiverAddress: process.env
    .NEXT_PUBLIC_RECEIVER_ADDRESS! as `0x${string}`, // EOA receiving funds
  nextPublicUsdcAddress: process.env.NEXT_PUBLIC_USDC_ADDRESS! as `0x${string}`, // Base USDC token address
  nextPublicLeaderboardPageSize:
    Number(process.env.NEXT_PUBLIC_LEADERBOARD_PAGE_SIZE!) || 25,
  nextPublicSupabaseUrl: process.env.NEXT_PUBLIC_SUPABASE_URL!,
  nextPublicSupabaseAnonKey: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
};

--- File: ./src/lib/neynarClient.ts ---
import { env } from "@/lib/env";
import { NeynarAPIClient } from "@neynar/nodejs-sdk";

export const neynar = new NeynarAPIClient({
  apiKey: env.neynarApiKey,
});

--- File: ./src/lib/fonts/ndot47_bd.woff2 ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/index.ts ---
import localFont from "next/font/local";

export const fontDisplay = localFont({
  src: [
    {
      path: "./brockmann_bd.otf",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-display",
});

export const fontBody = localFont({
  src: [
    {
      path: "./editundo_bd.ttf",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-body",
});

export const fontInput = localFont({
  src: [
    {
      path: "./ndot47_bd.woff2",
      weight: "400",
      style: "normal",
    },
  ],
  display: "swap",
  variable: "--font-input",
});

--- File: ./src/lib/fonts/brockmann_bd.otf ---
[Content not included: Binary file]

--- File: ./src/lib/fonts/editundo_bd.ttf ---
[Content not included: Binary file]

--- File: ./src/lib/db.ts ---
// /src/server/db.ts
import { PrismaClient } from "@prisma/client";

declare global {
  // Prevent multiple instances of PrismaClient in development
  // (prevents exhausting database connections on hot-reload)
  var prisma: PrismaClient | undefined;
}

export const prisma: PrismaClient =
  global.prisma ||
  new PrismaClient({
    log: ["query"], // optional: log queries for debugging
  });

if (process.env.NODE_ENV !== "production") {
  global.prisma = prisma;
}

--- File: ./src/lib/time.ts ---
export function formatCountdown(target: Date): string {
  const diff = target.getTime() - Date.now();
  if (diff <= 0) return "00:00";

  const minutes = Math.floor(diff / 60000);
  const seconds = Math.floor((diff % 60000) / 1000);
  return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(
    2,
    "0"
  )}`;
}

--- File: ./src/lib/wagmiConfig.ts ---
import { createConfig, http } from "wagmi";
import { base } from "wagmi/chains";
import { injected } from "wagmi/connectors";

export const wagmiConfig = createConfig({
  chains: [base],
  transports: {
    [base.id]: http(),
  },
  connectors: [injected()],
  ssr: true,
});

--- File: ./src/lib/streaks.ts ---
export function calculateStreak(gameDates: Date[]): number {
  if (gameDates.length === 0) return 0;

  const sorted = gameDates.sort((a, b) => b.getTime() - a.getTime());
  let streak = 1;
  for (let i = 1; i < sorted.length; i++) {
    const diff =
      (sorted[i - 1].getTime() - sorted[i].getTime()) / (1000 * 60 * 60 * 24);
    if (diff <= 1.1) streak++;
    else break;
  }
  return streak;
}

